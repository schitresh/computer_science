{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Computer Science","text":"<ul> <li>Object Oriented Programming</li> <li>Database System</li> <li>Operating System</li> <li>Computer Networks</li> </ul>"},{"location":"computer_networks","title":"Computer Networks","text":"<ul> <li>Introduction</li> <li>Network Devices</li> <li>OSI Model</li> <li>TCP/IP Model</li> <li>Network Security</li> <li>Physical Layer</li> <li>Data Link Layer</li> <li>Network Layer</li> <li>Transport Layer</li> <li>Session Layer</li> <li>Presentation Layer</li> <li>Application Layer</li> </ul>"},{"location":"computer_networks/introduction","title":"Introduction","text":"<ul> <li>Collection of computers &amp; devices connected together to enable communication and data exchange</li> <li>System connected to network and ready for communication is called open system (vs closed system)</li> <li>Basic building blocks of a computer network are nodes and links</li> <li>Nodes: Devices capable of sending &amp; receiving data like computers, servers, printers, routers, switches</li> <li>Links: Wires, cables, wireless networks</li> </ul>"},{"location":"computer_networks/introduction#basic-terminology","title":"Basic Terminology","text":"<ul> <li>Protocol</li> <li>A set of rules and standards that govern how data is transmitted over a network</li> <li>Examples: TCP/IP, HTTP, FTP</li> <li>Protocol Data Unit: Single unit of information transmission among peer entities</li> <li>Topology</li> <li>Physical and logical arrangement of nodes in a network</li> <li>Examples: Bus, star, ring, mesh, tree</li> <li>IP Address (Internet Protocol Address)</li> <li>Unique numerical identifier that is assigned to every device in a network</li> <li>Used for identification &amp; communication</li> <li>MAC Address (Media Access Control Address)</li> <li>Unique identifier of each host associated with its Network Interface Card (NIC)</li> <li>Used to identify a device in a local network</li> <li>DNS (Domain Name System)</li> <li>Translates human readable domain names to IP addresses that computers can understand</li> <li>For example, getting the IP address of www.google.com</li> <li>Dynamic Host Configuration Protocol (DHCP)</li> <li>Automatically assigns IP addresses and network configuration settings to devices in a network</li> <li>Firewall</li> <li>Monitors &amp; controls incoming &amp; outgoing network traffic</li> <li>Protects networks from unauthorized access and other security threats</li> </ul>"},{"location":"computer_networks/introduction#network-criteria","title":"Network Criteria","text":"<ul> <li>Performance</li> <li>Transit time: Time for a message to travel from one device to another</li> <li>Response time: Time elapsed between an inquiry and a response</li> <li>Throughput: Rate of message delivery</li> <li>Delay</li> <li>Factors<ul> <li>Number of users</li> <li>Transmission medium and distance</li> <li>Hardware or software limitations</li> <li>Bandwidth (Capacity of network)</li> <li>Topology and protocols</li> <li>Congestion</li> </ul> </li> <li>Reliability</li> <li>Failure frequency</li> <li>Recovery time after failure</li> <li>Reducing single points of failure</li> <li>Security</li> <li>Authentication</li> <li>Authorisation</li> <li>Damage and recovery</li> </ul>"},{"location":"computer_networks/introduction#internet","title":"Internet","text":"<ul> <li>Global network of smaller networks interconnected using standardized protocols</li> <li>Allows people to communicate, share information, and access resources from anywhere in the world</li> <li>Consists of private, public, academic, business and government networks of local to global scope</li> </ul>"},{"location":"computer_networks/introduction#world-wide-web-www","title":"World Wide Web (WWW)","text":"<ul> <li>Provides a way to access information through internet</li> <li>Only a subset of internet is connected through the web</li> <li>System of internet servers that support specially formatted documents in HTML</li> <li>Which are interlinked using hypertext links and are accessible via internet</li> <li>HTML (HyperText Markup Language): Markup language in which the documents are formatted</li> <li>HTTP (HyperText Transfer Protocol): Transfer protocol</li> <li>URI (Uniform Resource Identifier): Address of resource, can be a name or location or both</li> <li>URL (Uniform Resource Locator)</li> <li>Human readable text designed to substitute the IP addresses</li> <li>protocol://website_name.top_level_domain/path</li> <li>https://youtube.com/videos/id</li> </ul>"},{"location":"computer_networks/introduction#working-of-browser","title":"Working of Browser","text":""},{"location":"computer_networks/introduction#step-1-client-side","title":"Step 1: Client-side","text":"<ul> <li>We type a URL and the browser converts it to a file containing</li> <li>GET /HTTP/1.1 (1.1 refers to the version of HTTP)</li> <li>Host (www.google.com)</li> <li>Other information</li> <li>If connected to ethernet</li> <li>It is converted to binary code and sent down the wires</li> <li>If connected to wifi</li> <li>It is converted to a radio-signal which is decoded by a router in a very low level</li> <li>It is then converted to binary code and sent to the servers</li> <li>It is transmitted through routers until it reaches the destination</li> </ul>"},{"location":"computer_networks/introduction#step-2-server-side","title":"Step 2: Server-side","text":"<ul> <li>Receives the binary code and decodes it</li> <li>Generates a response</li> <li>HTTP/1.1 200 ok</li> <li>Content-type: type/html</li> <li>Body of the page</li> <li>Converts it to binary and sends it to IP requesting it</li> </ul>"},{"location":"computer_networks/introduction#step-3-client-side","title":"Step 3: Client-side","text":"<ul> <li>Receives the response and decodes it</li> <li>Checks the status</li> <li>Starts reading the html and constructs a tree like structure</li> <li>The HTML tree is converted to binary code and rendered on screen</li> </ul>"},{"location":"computer_networks/network_devices","title":"Network Devices","text":""},{"location":"computer_networks/network_devices#domains","title":"Domains","text":"<ul> <li>The more the number of collision domains &amp; broadcast domains</li> <li>The better bandwidth the network provides</li> </ul>"},{"location":"computer_networks/network_devices#collision-domain","title":"Collision Domain","text":"<ul> <li>When a device sends out a message to a network</li> <li>All the other devices in its collision domain have to pay attention to it</li> <li>No matter if it was destined for them or not</li> <li>When two devices send out their messages simultaneously</li> <li>Collision will occur leading them to wait and retransmit their messages one at a time</li> <li>It happens only in the case of half duplex mode</li> </ul>"},{"location":"computer_networks/network_devices#broadcast-domain","title":"Broadcast Domain","text":"<ul> <li>When a device sends out a broadcast message</li> <li>All the devices present in its broadcast domain have to pay attention to it</li> <li>It creates a lot of congestion in the network (commonly called LAN congestion)</li> <li>It affects the bandwidth of the users present in that network</li> </ul>"},{"location":"computer_networks/network_devices#basic-network-devices","title":"Basic Network Devices","text":"<ul> <li>Cables and connectors</li> <li>Modem: Connects computer to internet over telephone line</li> </ul>"},{"location":"computer_networks/network_devices#network-interface-card-nic","title":"Network Interface Card (NIC)","text":"<ul> <li>Operates at physical and data link layer</li> <li>Helps computer to connect to network and communicate with other devices</li> <li>Contains hardware addresses (MAC address) used by data link layer</li> <li>Has a connector to connect a cable</li> <li>That acts as an interface between the computer and the router or modem</li> </ul>"},{"location":"computer_networks/network_devices#repeater","title":"Repeater","text":"<ul> <li>Basic info</li> <li>Operates at physical layer</li> <li>Two ports (input &amp; output)</li> <li>Collision domain and broadcast domain remains same</li> <li>Regenerates the signal over the same network before it becomes too weak or corrupted</li> <li>Not only amplifies the signal but also regenerates it by copying it bit by bit</li> </ul>"},{"location":"computer_networks/network_devices#hub","title":"Hub","text":"<ul> <li>Basic info</li> <li>Operates at physical layer</li> <li>Basically a multi-port repeater</li> <li>Collision domain and broadcast domain remains same</li> <li>Connects multiple devices from different branches or wires</li> <li>Computer request is sent to hub which distributes it to interconnected computers</li> <li>Cannot filter data so data packets are sent to all the connected devices</li> <li>Does not have capability to find out the best path for data packets</li> </ul>"},{"location":"computer_networks/network_devices#types","title":"Types","text":"<ul> <li>Active Hub</li> <li>Has their own power supply</li> <li>Can clean, boost, relay signal along a network</li> <li>Serves as a repeater as well as a wiring center</li> <li>Used to extend the maximum distance between nodes</li> <li>Passive Hub</li> <li>Collects wiring from nodes and power supply from the active hub</li> <li>Relays signals onto a network without cleaning or boosting them</li> <li>Can't be used to extend distance between nodes</li> <li>Intelligent Hub</li> <li>Works like an active hub and includes remote management capabilities</li> <li>Provide flexible data rates</li> <li>Enables an administrator to monitor the passing network</li> </ul>"},{"location":"computer_networks/network_devices#bridge","title":"Bridge","text":"<ul> <li>Basic info</li> <li>Operates at data link layer</li> <li>Two ports (input &amp; output)</li> <li>Breaks only collision domain, broadcast domain remains same</li> <li>Repeater with functionality of filtering content</li> <li>By reading the MAC address of the source &amp; destination</li> <li>Local internetworking device used to connect network segments together</li> <li>Used where the full power of router is not required (e.g. within the same organization)</li> <li>Uses MAC addresses to make forwarding decisions</li> <li>Hosts are unaware of the bridges and it appears to them as a single network</li> <li>Also used to divide large networks into smaller segments</li> <li>To improve network performance and reduce network congestion</li> </ul>"},{"location":"computer_networks/network_devices#types_1","title":"Types","text":"<ul> <li>Transparent Bridge</li> <li>Stations are completely unaware of the bridge's existence</li> <li>Makes use of bridge forwarding and bridge learning</li> <li>Source Routing Bridge</li> <li>Routing operation is performed by the source station</li> <li>Frames specify which route to follow</li> <li>Hosts can discover the frame by sending a special frame called discovery frame</li> </ul>"},{"location":"computer_networks/network_devices#switch","title":"Switch","text":"<ul> <li>Basic info</li> <li>Operates at data link layer</li> <li>Multiport bridge with a buffer and a better efficiency</li> <li>Every port is in different collision domain but the broadcast domain remains the same</li> <li>Groups all devices over network to transfer data to another device</li> <li>Can perform error checking before forwarding data</li> <li>Doesn't broadcast over network like hub</li> <li>Sends message to the destination device based on the MAC address</li> <li>Learns the MAC address of the device on the switch port on which it received the frame</li> </ul>"},{"location":"computer_networks/network_devices#types_2","title":"Types","text":"<ul> <li>Unmanaged: Simple configuration, suitable for small networks</li> <li>Managed: Advanded configuration like VLAN, QoS, suitable for large networks</li> <li>Layer 2: Operate at data link layer, forwards data between devices on the same network segment</li> <li>Layer 3: Operate at network layer, can route data between different network segments</li> <li>There are many other types of switches for different functionalities</li> </ul>"},{"location":"computer_networks/network_devices#router","title":"Router","text":"<ul> <li>Basic info</li> <li>Operates at network layer</li> <li>Most routers include many ports that can connect a variety of devices to internet</li> <li>It separates both the collision domain and the broadcast domain</li> <li>Connects two or more network segments like LANs to a single network</li> <li>Device like switch that routes data packets based on their IP addresses</li> <li>By sending data packets to their intended IP addresses</li> <li>It manages traffic between different networks</li> <li>And permits several devices to share an internet connection</li> <li>Whenever a web request (packets) is sent from a browser</li> <li>It goes through a series of routers which accept these packets</li> <li>And forwards them to a correct path</li> <li>Working</li> <li>Examines the destination IP address from the header of a packet<ul> <li>And compares it to the routing database</li> </ul> </li> <li>A list of routing tables outline how to send data to a specific network location<ul> <li>Dynamic routing tables are updated by dynamic routers based on network activity</li> <li>Static routing tables are configured manually</li> </ul> </li> </ul>"},{"location":"computer_networks/network_devices#bridging-router-brouter","title":"Bridging Router (BRouter)","text":"<ul> <li>Operates at data link and network layer</li> <li>Combines features of both bridge and router</li> <li>Capable of routing packets across networks as router and filtering LAN traffic as bridge</li> </ul>"},{"location":"computer_networks/network_devices#gateway","title":"Gateway","text":"<ul> <li>Operates at network layer, also call protocol converters</li> <li>Passage to connect two networks that may work upon different networking models</li> <li>Works as messenger agent that take data from one system</li> <li>Then interpret it and transfer to another system</li> <li>Generally more complex than switches or routers</li> </ul>"},{"location":"computer_networks/osi_model","title":"Open Systems Interconnection (OSI) Model","text":"<ul> <li>Basic info</li> <li>Acts as a reference model</li> <li>Not implemented on internet because of its late invention</li> <li>The current model being used is the TCP/IP model</li> <li>Software or Upper layers</li> <li>Application, presentation, session layers</li> <li>Responsibility of host</li> <li>Hardware or Lower layers</li> <li>Transport, network, data link, physical layers</li> <li>Responsibility of network</li> </ul>"},{"location":"computer_networks/osi_model#flow-of-data","title":"Flow of Data","text":"<ul> <li>The data to be transferred travels through 7 layers of the model</li> <li>First it travels down the layers from the sender</li> <li>And then climbs back the layers towards the receiver</li> </ul>"},{"location":"computer_networks/osi_model#example-x-sends-an-email-to-y","title":"Example: X sends an email to Y","text":"<ul> <li>Application: X sends an email using an application like gmail</li> <li>Presentation: Mail application prepares for data transmission like encryption &amp; formatting</li> <li>Session: Connection is established between the sender and the receiver on internet</li> <li>Transport</li> <li>Email data is broken into small segments</li> <li>Sequence number and error checking info is added to keep the data reliable</li> <li>Network: Addressing of packets is done to find the best route for transfer</li> <li>Data Link</li> <li>Data packets are encapsulated into frames</li> <li>MAC address is added for local devices</li> <li>Errors are detected</li> <li>Physical</li> <li>Data is transmitted in the form of electrical or optical signals</li> <li>Over a network medium like ethernet or wifi</li> <li>After the email reaches the receiver</li> <li>The process is reversed</li> <li>The email content is decrypted and shown to the receiver</li> </ul>"},{"location":"computer_networks/osi_model#physical-layer","title":"Physical Layer","text":"<ul> <li>Physical medium through which bits are transmitted</li> <li>PDU (Protocol Data Unit): Bit</li> <li>Devices: Cables, Fibers, Wirelessm Modem, Repeater, Hub</li> </ul>"},{"location":"computer_networks/osi_model#data-link-layer","title":"Data Link Layer","text":"<ul> <li>Error free transfer of data frames</li> <li>PDU: Frame</li> <li>Devices: NIC/Adaptor/Chip, Device driver, Bridge, Switch</li> <li>Addressing: MAC address</li> </ul>"},{"location":"computer_networks/osi_model#network-layer","title":"Network Layer","text":"<ul> <li>Moving packets from source to destination</li> <li>PDU: Packet, Datagram</li> <li>Devices: Router, Brouter</li> <li>Addressing: IP address</li> <li>Protocols: IP, ICMP, ARP</li> </ul>"},{"location":"computer_networks/osi_model#transport-layer","title":"Transport Layer","text":"<ul> <li>Reliable message delivery from process to process</li> <li>PDU: Segment</li> <li>Devices: OS, Gateways, Firewalls</li> <li>Addressing: Port Number</li> <li>Protocols: TCP, UDP</li> </ul>"},{"location":"computer_networks/osi_model#session-layer","title":"Session Layer","text":"<ul> <li>Establish, manage and terminate sessions</li> <li>Packet: Data</li> <li>Devices: OS, Gateways, Firewalls</li> <li>Protocols: SSL, API</li> </ul>"},{"location":"computer_networks/osi_model#presentation-layer","title":"Presentation Layer","text":"<ul> <li>Translation, compression, encryption</li> <li>Packet: Data</li> <li>Devices: OS, Gateways, Firewalls</li> <li>Protocols: SSL, SSH, IMAP</li> </ul>"},{"location":"computer_networks/osi_model#application-layer","title":"Application Layer","text":"<ul> <li>Services for the user</li> <li>Packet: Data</li> <li>Devices: Network applications, Browser, Messenger, Gateways, Firewalls</li> <li>Protocols: HTTP, DHCP, FTP, SSH, SMTP, DNS</li> </ul>"},{"location":"computer_networks/tcp_ip_model","title":"TCP/IP Model","text":"<ul> <li>Basic info</li> <li>The OSI model just acts as a reference model because of its late invention</li> <li>Used to transfer data reliably and accurately from one device to another</li> <li>Divides data into packets at the sender and recombines them at the receiver</li> <li>Protocols</li> <li>TCP (Transmission Control Protocol): Sends and receives data</li> <li>IP (Internet Protocol): Finds the destination of the data</li> </ul>"},{"location":"computer_networks/tcp_ip_model#network-access-layer","title":"Network Access Layer","text":"<ul> <li>OSI counterparts: Data link, Physical</li> <li>Physical layer: Responsible for generating the data and requesting connections</li> <li>Data link layer: Error prevention and dividing data into frames</li> </ul>"},{"location":"computer_networks/tcp_ip_model#network-or-internet-layer","title":"Network or Internet Layer","text":"<ul> <li>OSI counterparts: Network</li> <li>Protocols: IP, ICMP, ARP</li> <li>Responsible for routing data packets from one device to another across a network</li> </ul>"},{"location":"computer_networks/tcp_ip_model#transport-layer","title":"Transport Layer","text":"<ul> <li>OSI counterparts: Transport</li> <li>Protocols: TCP, UDP</li> <li>Exchanges data receipt acknowledgements</li> <li>Retransmits missing packets to ensure that packets arrive in order and without error</li> </ul>"},{"location":"computer_networks/tcp_ip_model#application-layer","title":"Application Layer","text":"<ul> <li>OSI counterparts: Application, Presentation, Session</li> <li>Protocols: HTTP, HTTPS, FTP, SSH, SMTP, DNS, DHCP</li> <li>Responsiible for end to end communication and error free delivery of data</li> <li>Shields the upper layer applications from the complexities of data</li> <li>Also called Process or Software layer</li> </ul>"},{"location":"computer_networks/network_security","title":"Network Security","text":"<ul> <li>Introduction</li> <li>Threat Modeling</li> <li>Malware</li> <li>Denial of Service</li> <li>Miscellaneous Attacks</li> <li>Firewall</li> <li>Message Authentication Codes</li> </ul>"},{"location":"computer_networks/network_security/introduction","title":"Introduction","text":""},{"location":"computer_networks/network_security/introduction#system-security","title":"System Security","text":"<ul> <li>Security can be compromised via any of these breaches</li> <li>Breach of confidentiality: Unauthorized reading of data</li> <li>Breach of integrity: Uauthorized modification of data</li> <li>Break of availability: Unauthorized destruction of data</li> <li>Theft of service: Unauthorized use of resources</li> <li>Denial of service: Preventing legitimate use of system</li> <li>The security of a system can be threatened via two violations</li> <li>Threat: A program that has the potential to cause serious damage to the system<ul> <li>Program Threats</li> <li>A program is written to hijack the security or change the behavior</li> <li>A user program is altered and make to perform malicious unwanted tasks</li> <li>Examples: Virus, worm, trojan horse, trap door, logic bomb</li> <li>Security Threats</li> <li>System services, resources or user files are misused</li> <li>Also used as medium to launch program threats</li> <li>Examples: Worm, port scanning, denial of service</li> </ul> </li> <li>Attack: An attempt to break security and make unauthorized use of an asset</li> </ul>"},{"location":"computer_networks/network_security/introduction#cia-triad","title":"CIA Triad","text":""},{"location":"computer_networks/network_security/introduction#confidentiality","title":"Confidentiality","text":"<ul> <li>Only authorized individuals or systems</li> <li>Should be permitted to view sensitive or classified information</li> <li>A primary way to safegaurd data is to use encryption techniques</li> <li>AES (Advanced Encryption Standard)</li> <li>DES (Data Encryption Standard)</li> <li>Another way to protect data is through VPN (Virtual Private Network) tunnel</li> </ul>"},{"location":"computer_networks/network_security/introduction#integrity","title":"Integrity","text":"<ul> <li>The system should make sure that data has not been modified</li> <li>Corruption of data is a failure to maintain data integrity</li> <li>To check this, a hash value is generated using hash functions like</li> <li>SHA (Secure Hash Algorithm): 160-bit hash in SHA-1</li> <li>MD5 (Message Direct 5): 128-bit hash</li> <li>This hash value is attached to the data</li> <li>When the target host receives the packet, it runs the same function<ul> <li>And checks if the generated hash matches the received hash</li> </ul> </li> </ul>"},{"location":"computer_networks/network_security/introduction#availability","title":"Availability","text":"<ul> <li>Network (systems, data) should be readily available to its users</li> <li>Or else it may impact the business</li> <li>Network administrator should maintain hardware and make regular upgrades</li> <li>Should have a plan for fail-over and prevent bottlenecks</li> <li>Attacks like DoS or DDoS may render a network unavailable</li> <li>As the network resources get exhausted</li> </ul>"},{"location":"computer_networks/network_security/threat_modeling","title":"Threat Modeling","text":"<ul> <li>Threat can be anything that can take advantage of a vulnerability to breach security</li> <li>And negatively alter, erase, or harm objects of interest</li> <li>Threat modeling is used to identify, communicate, understand &amp; mitigate threats</li> <li>Documentation from this process provides system analysts and defenders</li> <li>With a complete analysis of probable attacker profiles, attack vectors, assets of interest</li> </ul>"},{"location":"computer_networks/network_security/threat_modeling#process","title":"Process","text":"<ul> <li>Aim</li> <li>Establish the aim for carrying this process</li> <li>Pay attention to the CIA triad</li> <li>Visualization &amp; Identification</li> <li>Understand the flow of data</li> <li>Find processes with user interactions</li> <li>Mitigation</li> <li>Continuous investigation of each vulnerability</li> <li>Action plan to deal with threats</li> <li>Validation</li> <li>Check if the threats have been mitigated or not</li> </ul>"},{"location":"computer_networks/network_security/threat_modeling#methodologies","title":"Methodologies","text":""},{"location":"computer_networks/network_security/threat_modeling#stride","title":"STRIDE","text":"<ul> <li>Spoofing: An adversary posing as another user or component existing in system</li> <li>Tampering: Modification of data within the system</li> <li>Repudiation: Ability of user to deny having performed a particular action</li> <li>Can be done using false identity, manipulation of logs, deletion or evidence</li> <li>Information Disclosure: Exposure of protected data to non-allowed user</li> <li>Denial of Service</li> <li>Elevation of Privilege: Breaching administrative controls and tampering privileges</li> </ul>"},{"location":"computer_networks/network_security/threat_modeling#dread","title":"DREAD","text":"<ul> <li>Damage Potential</li> <li>Reproducibility: How easy it is to reproduce an attack</li> <li>Exploitability: Effort required to launch an attack</li> <li>Affected Users</li> <li>Discoverability: How easy it is to discover the threat</li> </ul>"},{"location":"computer_networks/network_security/threat_modeling#others","title":"Others","text":"<ul> <li>PASTA (Process for Attack Simulation and Threat Analysis)</li> <li>Dynamic threat identification, enumeration, scoring process</li> <li>Develops an asset centric mitigation strategy by analyzing attacker centric view of system</li> <li>Trike: Establishes stakeholder defined acceptable level of risk assigned to each asset class</li> <li>Vast (Visual, Agile, and Simple Threat modeling)</li> <li>Provides an application and infrastructure visualization schemme</li> <li>Attack Tree: Conceptual diagram about how an asset might be attacked</li> <li>CVSS (Common Vulnerability Scooring System)</li> <li>Captures principal characteristics of a vulnerability with a numerical score</li> <li>T-Map: Calculates weights of attack paths</li> </ul>"},{"location":"computer_networks/network_security/malware","title":"Malware","text":"<ul> <li>Designed to disrupt, damage or gain unauthorized access to a system</li> <li>Tries to replicate from one infected host to new hosts</li> <li>Virus</li> <li>Malware that requires some form of user interaction to infect a device</li> <li>Attaches itself to a system file and rapidly replicates itself<ul> <li>Modifying and destroying essential files leading to a system breakdown</li> </ul> </li> <li>For example, email attachment with malicious executable code<ul> <li>Which when opened runs malware on the device</li> </ul> </li> <li>Worm</li> <li>Malware that can enter a device without any explicit user interaction</li> <li>For example, an attacker can send malware to a vulnerable network application</li> <li>Botnet</li> <li>A network of private computers infected with malicious software<ul> <li>And contrrolled as a group without the owner's knowledge</li> </ul> </li> <li>For example, to send spams</li> <li>Rootkit</li> <li>Stealthy packages designed to benefit administrative rights<ul> <li>And get the right of entry to a community toll</li> </ul> </li> <li>Once installed, can have complete and unrestrictive get right of entry to a tool<ul> <li>And can execute any movement like spying customers or stealing data</li> </ul> </li> <li>Logic Bomb</li> <li>Malicious program which is inserted into the system and triggers on specific conditions</li> </ul>"},{"location":"computer_networks/network_security/malware#trojan-horse","title":"Trojan Horse","text":"<ul> <li>A code segment that misuses its environment</li> <li>Seem to be attractive and harmless cover programs</li> <li>That are harmful hidden programs that can be used as virus carrier</li> <li>In one of the versions, user is fooled to enter confidential login details on an application</li> <li>These details are stolen by a login emulator and used to breach information</li> <li>Spyware is another variance</li> <li>Accompanies a program or website and displays ads by creating pop-up browser windows</li> <li>Captures essential information and sends it over to a remote server</li> </ul>"},{"location":"computer_networks/network_security/malware#zeus-malware-or-zbot","title":"Zeus Malware or Zbot","text":"<ul> <li>Malware bundle that utilizes client-server model and to make gigantic botnets</li> <li>Assists with acquiring unapproved admittance to monetary frameworks</li> <li>By taking accreditations, banking data, monetory infromation</li> <li>The penetrated information is then sent back to the assailants</li> <li>Through zeus order and control server</li> <li>Has compromised significant associations like NASA &amp; Bank of America</li> <li>And north of 3 million PCs in USA</li> </ul>"},{"location":"computer_networks/network_security/dos_denial_of_service","title":"Denial of Service (DoS)","text":"<ul> <li>Renders a network, host or other pieces of infrastructure unusable by legitimate users</li> <li>May target servers, routers or communication links</li> <li>Example</li> <li>Ping of death: Uses pings with malformed ICMP packets of non standard sizes</li> <li>Smurf attack: Sending emails with fake return addresses and automatic responses</li> </ul>"},{"location":"computer_networks/network_security/dos_denial_of_service#types","title":"Types","text":"<ul> <li>Vulnerability attack</li> <li>Well-crafted messages are sent to a vulnerable application or operating system<ul> <li>Running on a targeted host</li> <li>To stop or crash the service</li> </ul> </li> <li>Bandwidth flooding</li> <li>Target's access link becomes clogged and legitimate packets cannot reach the server</li> <li>Connection flooding</li> <li>A large number of half or fully open TCP connections are established</li> <li>The host becomes bogged down with these bogus connections<ul> <li>And stops accepting legitimate connections</li> </ul> </li> </ul>"},{"location":"computer_networks/network_security/dos_denial_of_service#ddos-distributed-ddos","title":"DDoS (Distributed DDoS)","text":"<ul> <li>Multiple compromised systems are used to target a single system causing a DoS</li> <li>Can leverage botnets with thousands of comprised hosts</li> <li>Harder to detect and defend against than DoS attack from a single host</li> </ul>"},{"location":"computer_networks/network_security/dos_denial_of_service#types_1","title":"Types","text":"<ul> <li>Application layer attacks</li> <li>Responding to a request takes a considerable load for the server<ul> <li>To build webpages, compute queries, load the results form database</li> </ul> </li> <li>But a client can generate and send multiple requests without any load</li> <li>Examples: HTTP flood attack, attack on DNS services</li> <li>Protocol attacks</li> <li>Focuses on vulnerabilites in layer 3 &amp; 4</li> <li>Consumes resources like servers, firewalls, load balancers</li> <li>Examples: SYN flood attack, ping of death</li> <li>Volumetric attacks</li> <li>Consumes network bandwidth and saturates it by amplification or botnet</li> <li>Directs a massive amount of traffic to target server</li> <li>Examples: NTP amplification, DNS amplification, UDP flood attack, TCP flood attack</li> </ul>"},{"location":"computer_networks/network_security/dos_denial_of_service#common-attacks","title":"Common Attacks","text":"<ul> <li>SYN flood attack</li> <li>Exploits TCP handshake by sending SYN messages with a spoofed IP address</li> <li>The victim server keeps on responding but does not receive a final acknowledgement</li> <li>HTTP flood attack</li> <li>Multiple HTTP requests are generated simultaneously against a server</li> <li>This exhausts network resources of that server and fails to serve actual requests</li> <li>DNS amplification</li> <li>DNS server is requested from a spoofed IP address</li> <li>The request is structured such that the DNS server responds with a large amount of data</li> </ul>"},{"location":"computer_networks/network_security/dos_denial_of_service#mitigation","title":"Mitigation","text":"<ul> <li>Preventing DDoS attack is harder than DoS attack since traffic comes from multiple sources</li> <li>And it becomes difficult to separate malicious hosts from actual hosts</li> <li>Blackhole routing: All traffic is diverted to a black hole where it gets lost</li> <li>Rate limiting</li> <li>Controls the rate of traffic and reduces the pace of web scrapers and brute force logins</li> <li>Unlikely to prevent compound DDoS attacks</li> <li>Blacklisting / whitelisting IP addresses</li> </ul>"},{"location":"computer_networks/network_security/miscellaneous_attacks","title":"Miscellaneous Attacks","text":""},{"location":"computer_networks/network_security/miscellaneous_attacks#spoofing-phishing","title":"Spoofing &amp; Phishing","text":"<ul> <li>IP Spoofing</li> <li>Injects packet into the interrnet with a false source address</li> <li>Can be solved using end-point authentication</li> <li>DNS spoofing or DNS cache poisoning</li> <li>Corrupt DNS data is introduced into a DNS resolver's cache<ul> <li>Causing the name server to return an incorrect IP address</li> </ul> </li> <li>Phishing</li> <li>Sending emails purporting to be from reputable companies</li> <li>In order to induce individuals to reveal personal information &amp; sensitive data</li> <li>When done through phone calls, it's called vishing (voice phishing)</li> <li>Packet Sniffer</li> <li>A passive receiver that records a copy of every packet that flies by</li> <li>Placed in the vicinity of a wireless transmitter</li> <li>Some of the best defenses involve cryptography</li> </ul>"},{"location":"computer_networks/network_security/miscellaneous_attacks#hacking-attacks","title":"Hacking Attacks","text":"<ul> <li>Man in the Middle attack</li> <li>Someone between the source &amp; destination<ul> <li>Actively monitors, captures and controls the communication transparently</li> </ul> </li> <li>For example, re-route a data exchange</li> <li>When communicating at low levels of network layer<ul> <li>Computers might not be able to determine with whom they are exchanging data</li> </ul> </li> <li>Compromized Key attacks</li> <li>A key is a secret code or number necessary to interpret secured information</li> <li>Obtaining a key is difficult and resource intensive process for an attacker</li> <li>But it is possible and referred as compromised key when obtained</li> </ul>"},{"location":"computer_networks/network_security/miscellaneous_attacks#vulnerability-attacks","title":"Vulnerability Attacks","text":"<ul> <li>Trap Door</li> <li>The designer of a program or system might leave a hole that only he is capable of using</li> <li>Quite difficult to detect as one needs to go through the source code of all the components</li> <li>Port Scanning</li> <li>Automated process that creates a TCP/IP connection to a specific port</li> <li>To protect the identity of attacker, they are launched from zombie systems</li> </ul>"},{"location":"computer_networks/network_security/miscellaneous_attacks#brute-force-attacks","title":"Brute Force Attacks","text":"<ul> <li>Birthday Attack</li> <li>Type of cryptographic attack that belongs to a class of brute force attacks</li> <li>Exploits the mathematics behind the birthday problem in probability theory</li> <li>Success of this attack largely depends upon likelihood of collisions<ul> <li>Found between random attack attempts and a fixed degree of permutations</li> </ul> </li> <li>Birthday paradox problem<ul> <li>Let's say there is a classroom of 30 students and a teacher</li> <li>The teacher wants to find pairs of students that have the same birthday</li> <li>For a particular date, probability of at least one student born is</li> <li>1 - (364 / 365)^n = 7.9% for n = 30</li> <li>Probability that at least one student has the same birthday as any other is</li> <li>1 - (365! / ((365 - n!) * 365^n)) = 70% for n = 30</li> </ul> </li> </ul>"},{"location":"computer_networks/network_security/firewall","title":"Firewall","text":"<ul> <li>Network security device</li> <li>That prevents unauthorized access to a network</li> <li>Monitors both incoming &amp; outgoing traffic to detect and prevent threats</li> <li>Can be either hardware or software based</li> <li>Actions</li> <li>Accept: Allow th traffic</li> <li>Reject: Block the traffic and reply with an unreachable error</li> <li>Drop: Block the traffic with no reply</li> <li>History</li> <li>Before firewalls, network security was performed by ACLs residing on routers</li> <li>ACL: Access Control List</li> <li>ACL rules can determine whether network access should be granted or denied</li> <li>But they cannot determine the nature of the packet it is blocking</li> <li>And they do not have capacity to keep threats out of the network</li> <li>Hence, firewall was introduced</li> </ul>"},{"location":"computer_networks/network_security/firewall#working","title":"Working","text":"<ul> <li>Firewall matches the network traffic against the set rules defined in its table</li> <li>Maintains distinct set of rules for outgoing and incoming traffic</li> <li>Most traffic that reaches on the firewall</li> <li>Is one of the three major transport layer protocols</li> <li>TCP, UDP, ICMP which all have a source &amp; a destination address</li> <li>TCP &amp; UDP have port numbers while ICMP uses type code instead of port number</li> <li>It is difficult to explicitly cover every possible rule</li> <li>Hence a firewall must always have a default policy</li> </ul>"},{"location":"computer_networks/network_security/firewall#types","title":"Types","text":"<ul> <li>Static Packet Filtering</li> <li>Monitors outgoing &amp; incoming packets to control network access<ul> <li>Works on the network &amp; transport layer</li> </ul> </li> <li>Based on source &amp; destination IP address, protocols, ports present in IP headers<ul> <li>Maintains a filtering table with these attributes</li> <li>To decide if a packet will be forwarded or discarded</li> </ul> </li> <li>Stateful Packet Filtering</li> <li>Based on the same attributes as static packet filtering</li> <li>Determines the connection state of packet travelling across it like TCP streams</li> <li>Which makes it more efficient than packet filtering</li> <li>So the filtering decisions are based on defined rules<ul> <li>As well as packet's history in the state table</li> </ul> </li> <li>Application Gateways or Proxy Firewalls</li> <li>Multiple application gateways can run with separate servers on the same host</li> <li>Examines &amp; filters packets on any OSI layer upto application layer</li> <li>Recognizes when certain application and protocols are being misused</li> <li>Next Generation Firewalls (NGFW)</li> <li>Deep packet inspection, application inspection, SSL/SSH inspection</li> <li>Many functionalities to protect the network from modern threats</li> </ul>"},{"location":"computer_networks/network_security/firewall#zone-based-firewall","title":"Zone-based Firewall","text":"<ul> <li>If an organization cannot afford a hardware firewall, it can use an alternative</li> <li>Implement the firewall features on router By using<ul> <li>CBAC (by maintaining access list)</li> <li>Zone-based firewall (new approach than CBAC)</li> </ul> </li> <li>Zone</li> <li>Logical area in which the devices have the same trust levels</li> <li>By default, traffic is not allowed from one zone to another</li> <li>There are two zones: inside (private network) and outside (WAN connection)</li> <li>Zone pair</li> <li>We can define zone pairs to allow traffic based on direction<ul> <li>Inside to outside</li> <li>Outside to inside</li> <li>Self zone (traffic within the zone)</li> </ul> </li> </ul>"},{"location":"computer_networks/network_security/message_authentication_codes","title":"Message Authentication Codes (MAC)","text":"<ul> <li>Also known as error detection code or cyptographic checksum</li> <li>Let's say user A wants to send a message to user B</li> <li>A encrypts and sends the message using shared-cryptosystem</li> <li>A sends the key to B using public-key cryptosystem</li> <li>B uses the key to decrypt to ciphertext and obtains the message</li> <li>What if a malicious user falsifies the ciphertext during the transmission</li> <li>Or the message alters due to external problems like noise</li> <li>When B decrypts the message, it will get the wrong message</li> <li>B has to check whether the ciphertext is falsified or not<ul> <li>By using message authentication code</li> <li>Ciphertext + Key = Message Authentication Code</li> </ul> </li> </ul>"},{"location":"computer_networks/network_security/message_authentication_codes#hmac-hashed-mac","title":"HMAC (Hashed MAC)","text":"<ul> <li>Involves a cryptographic hash function and a secret cryptographic key</li> <li>For example, SHA-256 or MD-5</li> <li>Uses two passes of hash computation</li> <li>First pass produces an internal hash from the message and the inner key</li> <li>Second pass produces the final HMAC code from the internal hash and the outer key</li> <li>Message (encrypted or not) is sent along with the HMAC hash</li> <li>Parties with the secret key will hash the message again</li> <li>If it is authentic, the received and computed hashes will match</li> </ul>"},{"location":"computer_networks/network_security/message_authentication_codes#rsa-algorithm","title":"RSA Algorithm","text":"<ul> <li>RSA is the acronym for the names of the developers</li> <li>Asymmetric cryptography algorithm</li> <li>Means that it works on two different keys: public key &amp; private key</li> <li>Considered very secure and widely used</li> <li>Working</li> <li>A client sends its public key to the server and requests some data</li> <li>The server encrypts the data using the client's public key and sends to client</li> <li>The client receives this data and decrypts it using private key</li> <li>Concept</li> <li>It is difficult to factorize a large integer</li> <li>Public key consists of multiplication of two large prime numbers</li> <li>Private key is also derived from the same two prime numbers<ul> <li>If somebody can factorize the large number, private key is compromised</li> </ul> </li> <li>Hence, encryption strength lies on the key size<ul> <li>Key size is typically 1024 or 2048 bits</li> <li>Due to this, it is slower than other encryption algorithms</li> </ul> </li> </ul>"},{"location":"computer_networks/L1_physical_layer","title":"L1 Physical Layer","text":"<ul> <li>Introduction</li> <li>Architecture</li> <li>Transmission</li> </ul>"},{"location":"computer_networks/L1_physical_layer/introduction","title":"Introduction","text":"<ul> <li>Basic info</li> <li>Packet: Bit</li> <li>Devices: Hub, Repeater, Modem, Cables, Fibers, Wireless</li> <li>Features</li> <li>Physical medium through which bits are transmitted from one node to the next</li> <li>Converts the received data into binary and sends them to the data link layer</li> </ul>"},{"location":"computer_networks/L1_physical_layer/introduction#functions","title":"Functions","text":"<ul> <li>Establish, maintain &amp; deactivate physical connection</li> <li>Defines the transmission media, mode &amp; rate</li> <li>Line Configuration: How to connect devices physically</li> <li>Specifies the topology and network interface for the devices</li> <li>Bit transfer from node to node</li> <li>Provides a clock that helps with bit synchronization</li> </ul>"},{"location":"computer_networks/L1_physical_layer/architecture","title":"Architecture","text":""},{"location":"computer_networks/L1_physical_layer/architecture#line-configuration","title":"Line Configuration","text":"<ul> <li>A link is a communication pathway that transfers data from one device to another</li> <li>Point to point connection</li> <li>Provides a dedicated link between two devices</li> <li>Reserves the entire capacity of the link for transmission between the two devices</li> <li>Multi-point connection</li> <li>Multiple devices share a single link</li> <li>Prone to network congestion</li> <li>Types<ul> <li>Spatial sharing: Several devices can share the link simultaneously</li> <li>Temporal sharing: Users must take turns to use the link</li> </ul> </li> </ul>"},{"location":"computer_networks/L1_physical_layer/architecture#connection-types","title":"Connection Types","text":""},{"location":"computer_networks/L1_physical_layer/architecture#peer-to-peer-p2p","title":"Peer to Peer (P2P)","text":"<ul> <li>All computer linked with equal privileges</li> <li>Special permissions are assigned to each computer for resource sharing</li> <li>Used for small setups like 10 computers</li> <li>Advantages</li> <li>No server: less costly, easy setup &amp; maintainence</li> <li>No single point of failure: others will work even if one stops</li> <li>Disadvantages</li> <li>No centralized system</li> <li>Devices manage themselves which can be a security issue</li> </ul>"},{"location":"computer_networks/L1_physical_layer/architecture#client-server","title":"Client Server","text":"<ul> <li>Server performs all major operations like security, network &amp; resource management</li> <li>All clients communicate through server</li> <li>Advantages</li> <li>Centralized system and backup</li> <li>Server improves overall performance including speed &amp; security</li> <li>Disadvantages</li> <li>Server needs resources which are costly<ul> <li>E.g. large memory, Network Operating System (NOS)</li> </ul> </li> <li>Requires dedicated network administrator to manage resources</li> </ul>"},{"location":"computer_networks/L1_physical_layer/architecture#network-types","title":"Network Types","text":"<ul> <li>Primary</li> <li>LAN (Local Area Network)</li> <li>MAN (Metropolitan Area Network)</li> <li>WAN (Wide Area Network)</li> <li>Others</li> <li>PAN (Personal Area Network)</li> <li>SAN (Storage Area Network)</li> <li>EPN (Enterprise Private Network)</li> <li>VPN (Virtual Private Network)</li> </ul>"},{"location":"computer_networks/L1_physical_layer/architecture#topology","title":"Topology","text":"<ul> <li>The way in which computers, devices, and links are arranged in a network</li> <li>Mesh: Every device is connected to another device</li> <li>Star: All the devices are connected to a single hub (or central node) through a cable</li> <li>Bus: Every device is connected with extension cables to a single bi-directional cable</li> <li>Ring: All the devices are connected to each other in a cyclic manner</li> <li>Tree: A central hub is at the root, secondary hubs are the internal nodes, systems are at the leaves</li> <li>Hybrid</li> </ul>"},{"location":"computer_networks/L1_physical_layer/transmission","title":"Transmission","text":""},{"location":"computer_networks/L1_physical_layer/transmission#modes","title":"Modes","text":""},{"location":"computer_networks/L1_physical_layer/transmission#simplex","title":"Simplex","text":"<ul> <li>Unidirectional communication</li> <li>Only one of the devices on the link can transmit, the other can only receive</li> <li>Useful where feedback or response is not required, like broadcasting or surveillance</li> <li>Examples: radio, monitor, keyboard</li> </ul>"},{"location":"computer_networks/L1_physical_layer/transmission#half-duplex","title":"Half-duplex","text":"<ul> <li>Each station can transmit and receive, but one at a time</li> <li>When one device is sending, the other can only receive</li> <li>Examples: walkie-talkie</li> </ul>"},{"location":"computer_networks/L1_physical_layer/transmission#full-duplex","title":"Full-duplex","text":"<ul> <li>Both stations can transmit and receive simultaneously</li> <li>Signals in both the directions share the capacity of the link with each other</li> <li>Either the link must contain two physically separated transmission path<ul> <li>One for sending &amp; the other for receiving</li> </ul> </li> <li>Or the capacity must be divided between signals travelling in both the directions</li> <li>Requires a high level of bandwidth</li> <li>May not be suitable for all types of applications</li> <li>Examples: phone, video conferencing, online gaming</li> </ul>"},{"location":"computer_networks/L1_physical_layer/transmission#transmission-types","title":"Transmission Types","text":"<ul> <li>Unicast</li> <li>Message is sent from one sender to one receiver</li> <li>Examples: email, file transfer</li> <li>Broadcast</li> <li>Message is sent from one sender to all receivers</li> <li>Examples: DHCP requests, ARP (Address Resolution Protocol) requests</li> <li>Multicast</li> <li>Message is sent from one sender to a group of receivers</li> <li>Examples: video streaming, online gaming</li> </ul>"},{"location":"computer_networks/L1_physical_layer/transmission#transmission-media","title":"Transmission Media","text":"<ul> <li>The channel through which data is sent from the transmitter to the receiver</li> <li>Guided Media</li> <li>Wired or bounded media</li> <li>High speed &amp; secure</li> <li>Unguided Media</li> <li>Wireless or unbounded media</li> <li>Less secure, transmitted through electromagnetic signal</li> </ul>"},{"location":"computer_networks/L1_physical_layer/transmission#guided-media","title":"Guided Media","text":""},{"location":"computer_networks/L1_physical_layer/transmission#twisted-pair-cable","title":"Twisted Pair Cable","text":"<ul> <li>Consists of two separately insulated conductor wires wound about each other</li> <li>Several such pairs are bundled together in a protective sheath</li> <li>Unshielded Twisted Pair</li> <li>Consists of two insulated copper wires twisted around one another</li> <li>Block interferences without depending on a physical shield</li> <li>Used for telephone connections and LAN networks</li> <li>Shielded Twisted Pair</li> <li>Consists of a special jacket to block external interference<ul> <li>Copper braid covering or foil shield</li> </ul> </li> <li>Better performance at higher data rate than unshielded one<ul> <li>But more expensive &amp; difficult to install</li> </ul> </li> <li>Used in fast-data-rate ethernet and in voice &amp; data channels of telephone lines</li> </ul>"},{"location":"computer_networks/L1_physical_layer/transmission#coaxial-cable","title":"Coaxial Cable","text":"<ul> <li>Has two parallel co-axial conductors each having a separate insulated cover</li> <li>Transmits information in two modes</li> <li>Baseband mode: Dedicated cable bandwidth</li> <li>Broadband mode: Cable bandwidth split into separate ranges</li> <li>Widely used by cable TVs and analog television networks</li> </ul>"},{"location":"computer_networks/L1_physical_layer/transmission#optical-fiber-cable","title":"Optical Fiber Cable","text":"<ul> <li>Uses refraction of light through a core made up of glass or plastic</li> <li>Used for transmission of large volumes of data</li> <li>Supports unidirectional and bidirectional modes</li> </ul>"},{"location":"computer_networks/L1_physical_layer/transmission#stripline","title":"Stripline","text":"<ul> <li>Transverse electromagnetic transmission line</li> <li>Uses a conducting material to transmit high frequency waves</li> <li>Conducting material is sandwiched between two layers of the ground plane</li> <li>Which are usually shorted to provide EMI immunity</li> <li>Microstripline</li> <li>Conducting material is separated from the ground plane by a layer of dielectric</li> </ul>"},{"location":"computer_networks/L1_physical_layer/transmission#unguided-media","title":"Unguided Media","text":"<ul> <li>Radiowaves</li> <li>Easy to generate and can penetrate through buildings</li> <li>Sending and receiving antennas need not be aligned</li> <li>Frequency range: 3KHz to 1GHz</li> <li>Used by AM &amp; FM radios, cordless phones</li> <li>Microwaves</li> <li>Sending &amp; receiving antennas need to be properly aligned</li> <li>Frequency range: 1GHz to 300 GHz</li> <li>Majorly used for mobile phone communication and television distribution</li> <li>Infrared</li> <li>Used for very short distance communication</li> <li>Can penetrate through obstacles and prevents interference between systems</li> <li>Frequency range: 300GHz - 400THz</li> <li>Used in TV remotes, wireless mouse &amp; keyboard</li> </ul>"},{"location":"computer_networks/L2_data_link_layer","title":"L2 Data Link Layer","text":"<ul> <li>Introduction</li> <li>Switching</li> <li>Multiple Access Control</li> <li>Sliding Window Protocol</li> <li>Error Detection</li> <li>Virtual LAN</li> <li>Mobile Communication</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/introduction","title":"Introduction","text":"<ul> <li>Basic info</li> <li>Packet: Frame</li> <li>Devices: Switch, Bridge, NIC/adaptor/chip, device driver</li> <li>Features</li> <li>Error free transfer of data from one node to another over the physical layer</li> <li>Transmits a packet arrived in a network to the host using the MAC address</li> <li>Receiver's MAC address is obtained by placing an ARP (Address Resolution Protocol) request</li> <li>Has two sublayers</li> <li>Logical Link Control (LLC)</li> <li>Media Access Control (MAC)</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/introduction#functions","title":"Functions","text":"<ul> <li>Framing</li> <li>The packet received from the network layer is divided into frames</li> <li>Depending on the frame size of the NIC (Network Interface Card)</li> <li>Physical addressing</li> <li>In the header of each frame, sender and receiver's MAC addresses are encapsulated</li> <li>Error detection</li> <li>Provides error control mechanism</li> <li>Detects and retransmits damaged or lost frames</li> <li>Adds CRC (Cyclic Redundancy Check)</li> <li>Flow Control</li> <li>Coordinates the amount of data that can be sent before receiving an acknowledgement</li> <li>Data rate must be constant on both sides else the data may get corrupted</li> <li>Access Control</li> <li>Required in a multi-device communication channel</li> <li>Determines which device has control over the link at a given time</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/introduction#framing","title":"Framing","text":"<ul> <li>In a point to point connection between two devices</li> <li>Where data is transmitted as a stream of bits</li> <li>The bits must be framed into perceptible blocks of information</li> <li>Every frame has a header and a trailer</li> <li>That contains information like source &amp; destination address, error detection code</li> <li>Different networking devices and protocols may use different framing methods</li> <li>Which might lead to incompatibility issues</li> <li>Synchronization can be challenging</li> <li>Particularly in high speed networks where frames are transmitted rapidly</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/introduction#types","title":"Types","text":"<ul> <li>Fixed size</li> <li>Frame is of fixed size</li> <li>No need to provide boundaries to the frame, the length itself acts as a delimiter</li> <li>May suffer from internal fragmentation</li> <li>Variable size</li> <li>Need to define the beginning &amp; end of the frame to distinguish</li> <li>A length field can be added for this, but sometimes it might get corrupted</li> <li>Or, an end delimiter can be added to indicate the end of a frame<ul> <li>Byte stuffing or Character stuffing: ED = '$'</li> <li>Bit stuffing: ED = 01111</li> </ul> </li> </ul>"},{"location":"computer_networks/L2_data_link_layer/introduction#logical-link-control-llc","title":"Logical Link Control (LLC)","text":"<ul> <li>Sublayer that provides the logic for the data link</li> <li>Controls packet transfer, syncronization, multiplexing, flow control, error checking</li> <li>Identifies the address of network layer protocol from header</li> <li>Unacknowledged connection-less service that uses LLC PDU (Protocol Data Unit)</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/introduction#llc-pdu-protocol-data-unit","title":"LLC PDU (Protocol Data Unit)","text":"<ul> <li>It has four parts</li> <li>Destination Service Access Point (DSAP)</li> <li>Logical address (8-bit) of the network layer entity meant to receive the message</li> <li>Indicates whether this is an individual or group address</li> <li>Source Service Access Point (SSAP)</li> <li>Logical address (8-bit) of the network layer entity meant to create the message</li> <li>Indicates whether this is a command or response PDU</li> <li>Information Field: Data or information</li> <li>Control Field: 8 or 16 bit field used for flow and error control</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/introduction#media-access-control-mac","title":"Media Access Control (MAC)","text":"<ul> <li>Links LLC and physical layer</li> <li>Provides globally unique identification number for a hardware</li> <li>When a single communication channel is shared by multiple devices</li> <li>MAC sublayer determines which device has control over the channel at a given time</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/introduction#mac-address","title":"MAC Address","text":"<ul> <li>Provides globally unique identification number for a hardware</li> <li>Present in NICs (Network Interface Cards) like wifi card, bluetooth card, ethernet card</li> <li>They have unchangeable MAC address embedded by the vendor</li> <li>MAC address is 6 bytes (48 bits) long</li> <li>Left 3 bytes are termed OUI (Organizationally Unique Identifier)<ul> <li>Remains same for NICs manufactured by the same company</li> </ul> </li> <li>Right 3 bytes are termed NICS (Network Interface Controller Specific)<ul> <li>Responsible for communication by cables or wireless</li> </ul> </li> <li>Types of MAC address</li> <li>Unicast: Sent only to a specific NIC (LSB of the first octet is set to zero)</li> <li>Multicast: Sent to a group of devices (LSB of the first octet is set to one)</li> <li>Broadcast: Sent to every device in a LAN segment (Have ones in all bits)</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/introduction#mac-address-vs-ip-address","title":"MAC Address vs IP Address","text":"<ul> <li>When a device sends data, the data is wrapped in an IP header</li> <li>It includes source &amp; destination IP address</li> <li>IP address is used for end-to-end delivery<ul> <li>Ensures that the data reaches the destination</li> </ul> </li> <li>This IP header along with the data is encapsulated in a MAC header</li> <li>It includes source &amp; destination MAC address for the current hop</li> <li>MAC address is used for hop-to-hop delivery<ul> <li>Facilitates the physical transfer of data between network nodes</li> </ul> </li> <li>As the data travels through routers</li> <li>MAC header is stripped off and a new one is generated for the next hop</li> <li>IP header generated by the original device remains intact till the destination</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/switching","title":"Switching","text":"<ul> <li>Technique by which nodes control or switch data</li> <li>To transmit it between specific points on a network</li> <li>There are three common switching techniques</li> <li>Circuit switching</li> <li>Packet switching</li> <li>Message switching</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/switching#circuit-switching","title":"Circuit Switching","text":"<ul> <li>Network resources (bandwidth) are divided into pieces</li> <li>Before the data transmission begins</li> <li>A dedicated path (circuit) is established between sender &amp; receiver</li> <li>The circuit remains dedicated for the session and provides a guaranteed data rate</li> <li>The bandwidth is reserved even when no data is being transmitted</li> <li>Which might be inefficient</li> <li>The connection is not required to be established for each packet</li> <li>Hence data can be transmitted without any delays</li> <li>That's why it's used in real time communication like voice &amp; video</li> <li>The number of circuits that can be established is finite</li> <li>So it has limited scalability</li> <li>And also expensive because it requires dedicated resources</li> <li>Examples: Telephone system network</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/switching#multiplexing-methods","title":"Multiplexing Methods","text":"<ul> <li>Frequency Division Multiplexing</li> <li>Bandwidth is divided into a series of non-overlapping frequency sub-bands</li> <li>Each sub-band carry different signal</li> <li>Used in radio spectrum &amp; optical fibre</li> <li>Time Division Multiplexing (Digital Circuit)</li> <li>Independing signals are transmitted over a common signal path by synchonized switches</li> <li>Used for long distance communication links and bears heavy data traffic</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/switching#packet-switching","title":"Packet Switching","text":"<ul> <li>Transferring data to a network in the form of packets</li> <li>Data is broken into small pieces of variable length called packet</li> <li>To transfer the data efficiently and minimize the transmission latency</li> <li>These packets may travel through different routes</li> <li>They are reassembled at the destination</li> <li>Uses the store and forward technique</li> <li>Packets may get discarded at any hop for some reason</li> <li>So while forwarding the packet, each hop first stores the packet and then forwards</li> <li>Advantages</li> <li>Efficient use of bandwidth since it's shared</li> <li>Less expensive than circuit switching since resources are shared</li> <li>Resources are allocated only during data transmission</li> <li>Flexible: Can handle a wide range of data rates and packet sizes</li> <li>Scalable: Can handle large amounts of traffic in a network</li> <li>Disadvantages</li> <li>Higher latency than circuit switching since packets are routed through multiple nodes</li> <li>May result in packet loss due to congestion or errors in transmission</li> <li>There can be transmission delay &amp; packet loss, so not ideal for real time communication</li> <li>Types of delays</li> <li>Transmission: Time taken by station to transmit data to the link</li> <li>Propogation: Time spent to propogate data through the link</li> <li>Queueing: Time for which a packet waits at the destination's queue</li> <li>Processing: Processing time at the destination</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/switching#connection-oriented-packet-switching-virtual-circuit","title":"Connection-oriented Packet Switching (Virtual Circuit)","text":"<ul> <li>Before starting the transmission</li> <li>It establishes a logical path or virtual connection using a signaling protocol</li> <li>Virtual circuit ID is provided by switches/routers<ul> <li>To uniquely identify this virtual connection</li> </ul> </li> <li>There are three phases: connection setup, data transfer, tear down</li> <li>Address information is transferred only during the setup phase</li> <li>Once the route is decided, entry is added<ul> <li>To the switching table of each intermediate node</li> </ul> </li> <li>Resources like buffers, CPU, bandwidth are reserved</li> <li>For the time in which the virtual circuit will be used</li> <li>If many clients are trying to reserve a router's resources simultaneously<ul> <li>It can become problematic</li> </ul> </li> <li>The first sent packet reserves resources at each server along the path</li> <li>Subsequent packets follow the same path as the first packet during the connection</li> <li>Only the first packet requires a global header</li> <li>Since all packets follow a specific path<ul> <li>They are received in order at the destination</li> <li>Packets are also appended with sequence numbers</li> </ul> </li> <li>Used by ATM (Asynchronous Transfer Mode) network, specifically for telephone calls</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/switching#connection-less-packet-switching-datagram","title":"Connection-less Packet Switching (Datagram)","text":"<ul> <li>Packet belonging to one flow may take different routes</li> <li>Because routing decisions are made dynamically</li> <li>So the packets arriving at the destination might be out of order</li> <li>All packets are associated with a header<ul> <li>Which contains all necessary addressing information</li> <li>Like source &amp; destination address, port numbers</li> </ul> </li> <li>There is no connection setup, teardown phase, resource reservation like virtual circuits</li> <li>Cost efficient and easy to implement than virtual circuit</li> <li>Packet delivery is not guaranteed</li> <li>Packet is discarded if resources like buffer, CUP, bandwidth are not available</li> <li>So reliable delivery must be provided by end systems using additional protocols</li> <li>Generally used by IP network, which is used for data services like the internet</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/switching#message-switching","title":"Message Switching","text":"<ul> <li>Developed as an alternative to circuit switching before packet switching was introduced</li> <li>Many major networks used are packet switched or circuit switched</li> <li>But their delivery processes can be message switched (like email systems)</li> <li>End users communicate by sending &amp; receiving messages</li> <li>That include the entire data to be shared</li> <li>Each message has a header with information about message routing, source, destination</li> <li>Store and forward</li> <li>Intermediate nodes transfer the entire message to the next node</li> <li>Since messages are stored indefinitely, switches require large storage capacity</li> <li>Message is delivered only if sufficient resources are available<ul> <li>The next hop and the link connecting it both should be available</li> </ul> </li> <li>It is slow</li> <li>Each node waits for the entire message to be received</li> <li>After processing the next node depending on availability &amp; traffic<ul> <li>It must store &amp; transmit the message</li> </ul> </li> <li>Cannot be used for real time communication</li> <li>Efficient traffic management by assigning priorities to the messages</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control","title":"Multiple Access Control","text":"<ul> <li>If there is no dedicated link between the sender and the receiver</li> <li>Then multiple stations can access the channel simultaneously</li> <li>Multiple access protocols are required to decrease collision and avoid crosstalk</li> <li>Types</li> <li>Random access protocols</li> <li>Controlled access protocols</li> <li>Channelization protocols</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#random-access-protocols","title":"Random Access Protocols","text":"<ul> <li>All stations have the same priority</li> <li>Any station can send data depending on the medium's state (idle or busy)</li> <li>There is no fixed time for sending data</li> <li>There is no fixed sequence of stations sending data</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#aloha","title":"Aloha","text":"<ul> <li>Used in low traffic networks</li> <li>Pure Aloha</li> <li>Station waits for an acknowledgement after sending data</li> <li>If acknowledgement is not received within the alotted time<ul> <li>Then the station waits for a random amount of time (backoff time)</li> <li>And then re-sends the data</li> </ul> </li> <li>The probability of collision decreases<ul> <li>Since different stations wait for different amount of time</li> </ul> </li> <li>Slotted Aloha</li> <li>Time is divided into slots</li> <li>Sending data is allowed only at the beginning of these slots</li> <li>If a station misses the allowed time<ul> <li>It must wait for the next slot</li> <li>This reduces the probability of collision</li> </ul> </li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#csma-carrier-sense-multiple-access","title":"CSMA (Carrier Sense Multiple Access)","text":"<ul> <li>The station senses the medium (for idle or busy) before transmitting data</li> <li>If it is busy, then it waits till the channel becomes idle</li> <li>Better efficiency than aloha, used in high traffic networks</li> <li>There is a chance of collision due to propogation delay</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#csmacd-collision-detection","title":"CSMA/CD (Collision Detection)","text":"<ul> <li>Once the station sends an entire frame, it does not keep a copy of the frame</li> <li>And does not monitor the channel for collision detection</li> <li>So before sending the last bit of the frame, the collision must be detected</li> <li>If a collision signal is received by the node, transmission is stopped</li> <li>Resending the frame immediately after may lead to consequent collisions</li> <li>So back-off algorithm is used<ul> <li>Where it waits for random time intervals before resending the frame</li> </ul> </li> <li>The size of a frame must be large enough to detect the collision by the sender</li> <li>Frame transmission delay must be at least two times the maximum propogation delay</li> <li>T(t) &gt;= 2 * T(p)</li> <li>T(t) = S / B (S = Frame Size, B = Bandwidth or Transmission Speed)</li> <li>T(p) = L / P (L = Distance between farthest nodes, P =  Propogation Speed)</li> <li>From above equations, we can get the mimimum frame size (S) and the maximum cable length (L)</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#csmaca-collision-avoidance","title":"CSMA/CA (Collision Avoidance)","text":"<ul> <li>Interframe space</li> <li>If the medium is idle, the station waits for a period of time (interframe space)</li> <li>After that it checks for the medium status again</li> <li>This avoids collision due to propogation delay</li> <li>The interframe space depends on the priority of the station</li> <li>Contention window</li> <li>Divides time into slots and chooses a random number of slots as wait time</li> <li>The number of slots double every time medium is found busy</li> <li>Acknowledgement</li> <li>The sender re-transmits the data if acknowledgement is not received before time-out</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#controlled-access-protocols","title":"Controlled Access Protocols","text":"<ul> <li>The stations seek information from one another to find which station has the right to send</li> <li>Allows only one node to send at a time to avoid collision of messages on a shared medium</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#reservation","title":"Reservation","text":"<ul> <li>Station needs to make a reservation before sending data</li> <li>The timeline has two kind of periods</li> <li>Reservation interval of fixed time length</li> <li>Data transmission period of variable frames</li> <li>If there are N stations, reservation interval is divided into N slots</li> <li>Each station has one slot, no other station can transmit during this slot</li> <li>i'th station announces that it has a frame to send by inserting 1 bit into the i'th slot</li> <li>After all N slots have been checked, each station knows which stations wish to transmit</li> <li>The stations which have reserved their slots transfer their frames in that order</li> <li>After data transmission period, next reservation interval begins</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#polling","title":"Polling","text":"<ul> <li>A controller sends a message to each node in turn</li> <li>One station acts as a primary station (or controller) and others as secondary stations</li> <li>All data exchanges happen through the controller</li> <li>The message sent by the controller<ul> <li>Contains the address of the node being selected for granting access</li> </ul> </li> <li>All nodes receive the message</li> <li>But only the addressed one responds and sends data if any</li> <li>If there is no data, usually a 'poll reject' (NAK) message is sent back</li> <li>Problems</li> <li>High overhead of the polling messages</li> <li>High dependence on the controller</li> <li>Since every station has an equal chance in every round, link sharing is biased</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#token-passing","title":"Token Passing","text":"<ul> <li>The stations are connected logically to each other in form of ring or bus</li> <li>Access to stations is governed by tokens</li> <li>A token is a special bit pattern or a small message</li> <li>The token circulates from one station to the next in a predefined order</li> <li>When a station gets the token<ul> <li>It sends the frame queued for transmission and passes the token</li> </ul> </li> <li>Problems to tackle</li> <li>Duplication or loss of token</li> <li>Insertion or removal of a station</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#channelization-protocols","title":"Channelization Protocols","text":"<ul> <li>The available bandwidth of the link is shared in time, frequency and code</li> <li>To multiple stations to access a channel simultaneously</li> <li>This is done using circuit switching</li> <li>This means dividing bandwidth into pieces by frequency or time</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/multiple_access_control#ways-to-share-bandwidth","title":"Ways to share bandwidth","text":"<ul> <li>Frequency Division Multiple Access</li> <li>Bandwidth is divided into equal bands and each station is alloted its own band</li> <li>Guard bands are added to avoid overlap, to avoid crosstalk and noise</li> <li>Time Division Multiple Access</li> <li>To avoid collision, time is divided into slots and alloted to stations</li> <li>There is an overhead of synchronization<ul> <li>Which is solved by adding synchronization bits to each slot</li> </ul> </li> <li>Propogation delay is resolved by adding guard bands</li> <li>Code Division Multiple Access</li> <li>One channel carries all transmissions simultaneously, no division of bandwidth or time</li> <li>Data from different stations are transmitted in different code languages</li> <li>By recognizing the code language, the identity of the station is mapped</li> <li>Orthogonal Frequency Division Multiple Access</li> <li>Bandwidth is divided into small subcarriers to increase the overall performance</li> <li>Widely used in 5G technology</li> <li>Spatial Division Multiple Access</li> <li>Uses multiple antennas at the transmitter and receiver</li> <li>To separate the signals of multiple users located in different spatial directions</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol","title":"Sliding Window Protocol","text":""},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#arq-automatic-repeat-request-or-automatic-repeat-query","title":"ARQ (Automatic Repeat Request or Automatic Repeat Query)","text":"<ul> <li>ARQ is an error-control strategy used in a two-way communication system</li> <li>It is a group of error-control protocols to achieve reliable data transmission</li> <li>Over an unreliable source or service</li> <li>These protocols</li> <li>Reside in the transport layer and data link layer</li> <li>Responsible for the automatic retransmission of packets<ul> <li>That are found to be corrupted or lost during the transmission process</li> </ul> </li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#working-principle-of-arq","title":"Working Principle of ARQ","text":"<ul> <li>The sender receives an acknowledgment from the receiver before timeout</li> <li>Implying that the frame or packet is received correctly</li> <li>Timeout is a specific period within which the acknowledgment has to be sent</li> <li>By the receiver to the sender</li> <li>If a timeout occurs</li> <li>It is implied that the frame or packet has been corrupt or lost during the transmission</li> <li>And the sender retransmits the packet</li> <li>This process is repeated until the correct packet is transmitted</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#stop-and-wait-arq","title":"Stop and Wait ARQ","text":"<ul> <li>Error and flow control used in connection-oriented communication</li> <li>Used in data link layer and transport layer</li> <li>Implements sliding window protocol with window size 1</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#metrics","title":"Metrics","text":"<ul> <li>Propogation Delay: Time taken by a packet from one router to another router</li> <li>Round Trip Time (RTT)</li> <li>Time taken by a packet to reach the receiver</li> <li>And the acknowledgement to reach the sender</li> <li>Time Out: 2 * RTT</li> <li>Time to Live (TTL): 2 * Time Out (Maximum TTL is 255 seconds)</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#simple-stop-and-wait","title":"Simple Stop and Wait","text":"<ul> <li>Sender</li> <li>Sends one packet at a time</li> <li>Sends the next packet only after receiving acknowledgement for the previous one</li> <li>Receiver</li> <li>Sends acknowledgement (ack) after receiving and consuming a packet</li> <li>Problems</li> <li>If a packet is lost<ul> <li>Sender keeps waiting for ack and receiver keeps waiting for packet</li> </ul> </li> <li>If an ack is lost, sender keeps waiting for ack</li> <li>If a packet or an ack is delayed (after timeout)<ul> <li>It might be considered wrongly for some other recent packet</li> </ul> </li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#stop-and-wait-with-arq-automatic-repeat-request","title":"Stop and Wait with ARQ (Automatic Repeat Request)","text":"<ul> <li>Solves the problems of the simple stop &amp; wait</li> <li>Sequence number is added to each packet<ul> <li>Which solves the delayed packet or ack problem</li> </ul> </li> <li>If a packet is lost, the packet is retransmitted after time out</li> <li>If an ack is lost<ul> <li>Receiver sends ack instead of negative ack by considering sequence number</li> </ul> </li> <li>If an error is detected<ul> <li>Receiver sends a negative acknowledgement (nak) to request retransmission</li> </ul> </li> <li>Working</li> <li>Sender sends a packet with sequence number 0</li> <li>Receiver sends an ack with sequence number 1<ul> <li>That is the seq number of next expected packet</li> </ul> </li> <li>0 or 1 is a one bit seq number<ul> <li>It implies that both sender &amp; receiver have a buffer for one packet only</li> </ul> </li> <li>So, the sender will send seq number 0, then 1, then 0, and so on</li> <li>May cause performance issues</li> <li>Due to sequenced sending of packets and waiting for ack</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#sliding-window-protocol_1","title":"Sliding Window Protocol","text":"<ul> <li>Handles the performance &amp; efficiency issue in stop &amp; wait ARQ</li> <li>By sending multiple packets at a time</li> <li>Types</li> <li>Go back N ARQ</li> <li>Selective repeat ARQ</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#metrics_1","title":"Metrics","text":"<ul> <li>Transmission Delay</li> <li>Time to transmit the packet from the host to the outgoing link</li> <li>T(t) = D / B (D = data size to transmit, B = bandwidth of the link)</li> <li>Propagation Delay</li> <li>Time taken by the first bit from host to reach the destination</li> <li>T(p) = d / s (d = distance, s = wave propagation speed of the medium)</li> <li>Total Time</li> <li>Transmission (data + ack) + Propagation (data) + Propagation (ack)</li> <li>TT = T(t) + 2 * T(p)</li> <li>Efficiency: Useful time / Total time, i.e. T(t) / TT</li> <li>Effective Bandwidth or Throughput</li> <li>Number of bits sent per second</li> <li>Throughput = D / TT = Efficiency * Bandwidth</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#pipelining","title":"Pipelining","text":"<ul> <li>Window size = Number of packets in one cycle</li> <li>One packet is transmitted in T(t) time</li> <li>W = TT / T(t) = 1 + 2 * (T(p) / T(t))</li> <li>W = 1 + 2a, where a = T(p)/T(t)</li> <li>After receiving ack for packet 0</li> <li>Sequence number are reused so that header size can be kept minimum</li> <li>Window slides and next packet is assigned seq number 0</li> <li>Can be represented with a diagram</li> <li>Draw a vertical line on LHS for sender (S) and another one on RHS for receiver (R)</li> <li>The vertical axis represents time starting from the top as the initial time</li> <li>For packet 0, draw a line from S at T(0) which touches R at T(p)</li> <li>Draw similar lines for all the packets in a window and for acks</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#go-back-n-arq","title":"Go Back N ARQ","text":"<ul> <li>Window sizes</li> <li>Sender window (WS) = N</li> <li>Receiver window (WR) = 1</li> <li>Example with sender window size as 4</li> <li>Sender sends packets 0, 1, 2, 3</li> <li>Receiver sends ack for 0, 1 and is expecting packet 2</li> <li>After receiving ack for 0, 1, the sender window slides to transmit packets 4, 5</li> <li>Let's say the packet 2 is lost in the network<ul> <li>So, the receiver will discard all the packets after packet 2</li> <li>On the sender side, the time-out timer will expire for packet 2</li> </ul> </li> <li>Hence, the sender window will go back to the packet 2 and resend all packets till 5<ul> <li>So, it goes back N times (packets 2, 3, 4, 5) from the last transmitted packet</li> </ul> </li> <li>Acknowledgements</li> <li>Cumulative ack<ul> <li>One ack is used for many packets</li> <li>It reduces the traffic but is less reliable</li> <li>Because if this one ack is lost, all the sent packets are treated as lost</li> </ul> </li> <li>Independent ack<ul> <li>Each packet gets an ack independently</li> <li>Reliability is high but traffic is also high</li> </ul> </li> <li>Minimum sequence numbers required = N + 1</li> <li>Let's say receiver gets all the packets (0, 1, 2, 3) for window size 4</li> <li>While it's waiting for packet 0 again, let's say cumulative ack is lost in the network</li> <li>After timeout on the sender side, all the 4 packets will be transmitted again</li> <li>And the receiver is also waiting for new set of packets starting from 0</li> <li>Which will result in duplicates (old 0 is retransmitted and new 0 is expected)</li> <li>To avoid this, one extra sequence number is required</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/sliding_window_protocol#selective-repeat-arq","title":"Selective Repeat ARQ","text":"<ul> <li>Go back N protocol works well if errors are less</li> <li>But if the line is poor, it wastes a lot of bandwidth on retransmitted frames</li> <li>Allows receiver to accept &amp; buffer the frames following a damaged or lost one</li> <li>Retransmits only those packets that are actually lost</li> <li>Receiver must be able to accept packets out of order</li> <li>Retransmission requests</li> <li>Implicit<ul> <li>Receiver acks every good packet</li> <li>Packets that are not acked before time-out are assumed lost or erred</li> </ul> </li> <li>Explicit<ul> <li>NAK (selective reject) requests retransmission of just one packet</li> <li>This can expedite retransmission but is not strictly needed</li> </ul> </li> <li>Window sizes</li> <li>Sender window = Receiver window</li> <li>Window size should be less than or equal to half the sequence number</li> <li>This is to avoid packets being recognized incorrectly<ul> <li>Receiver may recognize new packets as retransmissions</li> </ul> </li> <li>Efficiency is same as Go back N</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/error_detection","title":"Error Detection","text":"<ul> <li>Error is a condition when receiver's information does not match sender's information</li> <li>During transmission</li> <li>Digital signals suffer from noise that can introduce errors in the binary bits</li> <li>That means 0 bit may change to 1 bit or vice versa</li> <li>To prevent such errors, error detection codes are added as extra data to digital messages</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/error_detection#types-of-errors","title":"Types of Errors","text":"<ul> <li>Single Bit Error</li> <li>One bit of a transmitted data is altered during transmission</li> <li>10-1-1... -&gt; 10-0-1...</li> <li>Multi Bit Error</li> <li>Relatively rare than single bit error</li> <li>But can occur in high noise or high interference digital environments</li> <li>1-0-111... -&gt; 1-1-11-0-...</li> <li>Burst Error</li> <li>When several consecutive bits are flipped mistakenly in digital transmission</li> <li>1-011-1... -&gt; 1-100-1...</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/error_detection#error-detection-methods","title":"Error Detection Methods","text":""},{"location":"computer_networks/L2_data_link_layer/error_detection#single-parity-check","title":"Single Parity Check","text":"<ul> <li>An extra bit is added to a data transmission</li> <li>1 is added if it contains odd number of 1's</li> <li>0 is added if it contains even number of 1's</li> <li>100011 -&gt; 100011-1</li> <li>Cannot detect even number of bit errors</li> <li>That is, if two 1's or two 0's are flipped</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/error_detection#two-dimensional-parity-check","title":"Two-dimensional Parity Check","text":"<ul> <li>Parity check bits are calculated for each row and each column</li> <li>1100-0 (parity bit for row)</li> <li>1101-1 (parity bit for row)</li> <li>....</li> <li>0001 (parity bits for columns)</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/error_detection#checksum","title":"Checksum","text":"<ul> <li>Data is divided into equally sized segments</li> <li>Sum of each segment is calculated using a 1's complement</li> <li>The calculated sum is sent to the receiver along with the data</li> <li>Won't work if one or more bits of a segment are damaged</li> <li>And the corresponding bit(s) of opposite value in second segment are also damaged</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/error_detection#cyclic-redundancy-check","title":"Cyclic Redundancy Check","text":"<ul> <li>Based on binary division unlike checksum which is based on addition</li> <li>Sequence of redundant bits are appended to the end of the data unit</li> <li>So that the resulting data unit becomes exactly divisible</li> <li>By a second predetermined binary number</li> <li>It is accepted at the destination</li> <li>If there is no remainder on dividing by the same number</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/virtual_lan","title":"Virtual LAN (VLAN)","text":"<ul> <li>Dividing devices in a network logically on layer 2 (data link layer)</li> <li>Broadcast domain</li> <li>Broadcast domain is a network segment<ul> <li>In which all the devices in that domain receive a packet broadcasted by a device</li> </ul> </li> <li>But it is limited to switches only as routers don't forward a broadcast packet</li> <li>Generally, layer 3 devices divide the broadcast domain<ul> <li>But it can also be divided by switches using VLAN</li> </ul> </li> <li>Through VLAN, different small sized sub-networks are created</li> <li>Which are comparatively easy to handle</li> <li>Devices that understand VLAN formats &amp; membership are called VLAN aware</li> <li>Three ways to connect devices in a VLAN</li> <li>Trunk link: All connected devices must be VLAN aware</li> <li>Access link: Connects VLAN unaware devices to VLAN aware bridge</li> <li>Hybrid link: Both VLAN aware &amp; unware devices are attached</li> <li>Reduces the need to send traffic to unnecessary destinations and saves bandwidth</li> <li>For example, the traffic is intended for 2 devices<ul> <li>But 10 devices are present in the broadcast domain</li> </ul> </li> <li>Useful to form virtual groups in an organization based on departments like sales, finance</li> <li>Allows to control broadcast domains, set up firewalls &amp; restrict access</li> <li>Eliminates the need for expensive routers to create specific broadcast domains</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/virtual_lan#inter-vlan-routing","title":"Inter VLAN Routing","text":"<ul> <li>Required for communication between different VLANs</li> <li>Switch Virtual Interface (SVI)</li> <li>Logical interface on a multilayer switch that processes packets on all switch ports</li> <li>Provides only management services like creating VLAN or telnet/SSH services on layer 2</li> <li>Provides both management and routing services on layer 3</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/virtual_lan#private-vlan","title":"Private VLAN","text":"<ul> <li>Used when some hosts should not be able to communicate with other hosts in the same VLAN</li> <li>There is a primary or promiscuous VLAN to which all the ports are connected</li> <li>Secondary VLANs provide isolation between the ports</li> <li>Isolated VLANs<ul> <li>Cannot communicate with other hosts directly</li> <li>Can communicate only with associated promiscuous port</li> </ul> </li> <li>Community VLANs: Can communicate with each other and associated promiscous port</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/virtual_lan#switch-ports","title":"Switch Ports","text":"<ul> <li>Access ports</li> <li>Carry the traffic of only the one native VLAN (known as VLAN 1)</li> <li>Trunk ports</li> <li>Carry the traffic of more than one VLAN</li> <li>Useful if required to exchange traffic between more than one switch</li> <li>VLAN identification method is used to identify traffic for a VLAN</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/mobile_communication","title":"Mobile Communication","text":"<ul> <li>SIM (Subscriber Identity Module) card</li> <li>Stores subscriber's identification and account information</li> <li>Stores security credentials that allow a device to connect to the network</li> <li>A SIM card plugged into a mobile device forms GSM system</li> <li>GSM (Global System for Mobile Communication)</li> <li>GSM system can be dissected into radio, network &amp; operation subsystems</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/mobile_communication#radio-subsystem","title":"Radio Subsystem","text":"<ul> <li>Mobile communication occurs in the form of radio waves that travel through air</li> <li>Mobile station (MS)</li> <li>Stores user specific data in SIM card<ul> <li>Serial number, card type, PIN, PIN unblocking key, authentication key</li> <li>List of subscribed services</li> </ul> </li> <li>Stores dynamic data required for wireless communication<ul> <li>Location information, cipher key for encryption &amp; decryption</li> </ul> </li> <li>Base station system (BSS)</li> <li>Maintains radio connection to the mobile station</li> <li>Performs coding &amp; decoding of the voice communication</li> <li>This happens through radio equipment present on cell tower<ul> <li>Like antennas, amplifiers, signal processors</li> </ul> </li> <li>Designates radio frequencies for communication<ul> <li>And performs handover from one cell tower to another</li> </ul> </li> </ul>"},{"location":"computer_networks/L2_data_link_layer/mobile_communication#network-subsystem","title":"Network Subsystem","text":"<ul> <li>Handles the handover from one BSS to another</li> <li>Which enables national &amp; international roaming</li> <li>It is aware of the subscriber location via its databases</li> <li>Home location register &amp; visitor location register</li> <li>The movement of a mobile station is traced</li> <li>And updated in the registers if it leaves the current location area</li> </ul>"},{"location":"computer_networks/L2_data_link_layer/mobile_communication#operation-subsystem","title":"Operation Subsystem","text":"<ul> <li>Responsible for smooth operations of a network</li> <li>Traffic monitoring, subscriber management, security, accounting, billing</li> <li>This informatino is held in a consolidated database of existing mobile devices</li> <li>This database is called equipment identity register</li> <li>This database is updated to blacklist any stolen device<ul> <li>And block communication on the associated SIM</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer","title":"L3 Network Layer","text":"<ul> <li>Introduction</li> <li>IP (Internet Protocol)</li> <li>IP v6</li> <li>IP Datagram Fragmentation</li> <li>ICMP (Internet Control Message Protocol)</li> <li>ARP (Address Resolution Protocol)</li> <li>Routing</li> <li>Routing Protocols</li> <li>NAT (Network Address Translation)</li> <li>ISDN (Integrated Services Digital Network)</li> <li>AAA (Authentication, Authorization, Accounting)</li> <li>Access Control</li> <li>WiFi</li> </ul>"},{"location":"computer_networks/L3_network_layer/introduction","title":"Introduction","text":"<ul> <li>Basic info</li> <li>Packet: Packet, Datagram</li> <li>Protocols: IP, ICMP, ARP</li> <li>Devices: Router, Brouter</li> <li>Features</li> <li>Data Route Layer</li> <li>Transmission of data from one host to another located in different networks</li> <li>Packet Routing: Selects shortest path to transmit packets from the available routes</li> <li>Adds the IP addresses of the sender &amp; the receiver in the header</li> </ul>"},{"location":"computer_networks/L3_network_layer/introduction#functions","title":"Functions","text":"<ul> <li>Device Addressing</li> <li>Adds source &amp; destination addresses to the header</li> <li>Identifies devices and tracks device location</li> <li>Routing: Determine optimal route based on factors like network condition &amp; priority</li> <li>Internetworking: Logical communication between hosts</li> <li>Data plane (Forwarding): Within router, move packets from router's input to output</li> <li>Control plane (Routing): Determine route of packets from source to destination</li> </ul>"},{"location":"computer_networks/L3_network_layer/introduction#synchronous-optical-network-sonet","title":"Synchronous Optical Network (SONET)","text":"<ul> <li>Communication protocol used to transmit a large amount of data over large distances</li> <li>Transfers multiple digital streams at the same time over optical fibre</li> <li>Converts electrical signal to optical signal so that it can travel longer distances</li> <li>Synchronous network</li> <li>A single clock called PRC (Primary Reference Clock) is used</li> <li>To handle the timing of transmission of signals &amp; equipments across the entire network</li> <li>Components</li> <li>Multiplexer: Converts electrical signals to optical signals</li> <li>Demultiplexer: Converts optical signals to electrical signals</li> <li>Regenerator: Repeater that takes an optical signal and increases its strength</li> <li>Add/drop multiplexer<ul> <li>Allows to add or remove signals coming from different sources into a given path</li> </ul> </li> <li>Functional layers</li> <li>Path layer: Movement of signal from optical source to optical destination</li> <li>Line layer: Movement of signal across physical line (between multiplexers)</li> <li>Section layer: Movement of signal across physical section (neigbouring devices)</li> <li>Photonic layer: Physical specifications for the optical fibre channel</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_internet_protocol","title":"IP (Internet Protocol)","text":"<ul> <li>Responsible for delivering packets from the source host to the destination host</li> <li>IP addresses are included in the packet headers</li> <li>Connection-less protocol used for packet switched networks</li> <li>Operates on a best effort delivery model<ul> <li>Neither delivery is guaranteed</li> <li>Nor proper sequencing nor avoidance of duplicate delivery</li> </ul> </li> <li>Host-to-host communication: Determines the path of transmission</li> <li>Data Encapsulation and Formatting</li> <li>Accepts data from transport layer protocol</li> <li>Ensures that data is sent and received securely</li> <li>Encapsulates data into message known as IP datagram</li> <li>Routing</li> <li>When IP datagram is sent over the same local network (LAN, MAN, WAN)<ul> <li>It is known as direct delivery</li> </ul> </li> <li>When source and destination are on distant network<ul> <li>Then the IP datagram is sent indirectly using routers</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_internet_protocol#fragmentation","title":"Fragmentation","text":"<ul> <li>Maximum Transmission Unit (MTU)</li> <li>Limit imposed on the size of IP datagram by data link layer protocol</li> <li>If datagram &gt; MTU, datagram is split into smaller units</li> <li>So that they can travel over the local network</li> <li>Fragmentation can be done by the sender or intermediate router</li> <li>At the receiver side</li> <li>All the fragments are reassembled to form an original message</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_internet_protocol#ip-addressing","title":"IP Addressing","text":"<ul> <li>Logical or software based address to reach a specific host</li> <li>IP addresses are used by internet &amp; higher layers</li> <li>To identify devices and provide internetwork routing</li> <li>32 bits (4 bytes) unique address having address space of 2^32</li> <li>Can be written in two notations: dotted decimal &amp; hexadecimal</li> <li>Dotted decimal notation</li> <li>Each segment (byte) can have any value from 0 to 255 (2^8 - 1)</li> <li>No zeroes precede the value in any segment (054 is wrong, 54 is correct)</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_internet_protocol#classful-addressing","title":"Classful Addressing","text":"<ul> <li>The 4 bytes of the address are divided into two parts</li> <li>Network ID (Identify the network)</li> <li>Host ID (Identify the host within a network)</li> <li>The class of IP address determines the bytes used for network ID &amp; host ID</li> <li>And the number of total networks and hosts possible</li> <li>More number of bytes assigned for host ID means that more number of hosts are possible</li> <li>Each ISP or network administrator assigns an IP address to each connected device</li> <li>The first address of any network is the network number<ul> <li>So in host ID, all bits cannot be set 0</li> </ul> </li> <li>The last address is reserved for broadcast IP<ul> <li>So in host ID, all bits cannot be set 1</li> </ul> </li> <li>Problems</li> <li>Millions of class A and many of class B addresses are wasted</li> <li>Number of addresses available in class C is small (254 hosts)<ul> <li>And cannot cater to the needs of an organisation</li> </ul> </li> <li>Class D &amp; E are reserved and cannot be used</li> <li>Due to these problems</li> <li>Classful addressing was replaced by classless inter-domain routing (CIDR) in 1993</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_internet_protocol#classes","title":"Classes","text":"<ul> <li>Class A</li> <li>Network ID: 1 byte, Host ID: 3 bytes</li> <li>Starting bits: 0</li> <li>Format: 0, Network ID (7 bits), Host ID (24 bits)</li> <li>Range: 0.0.0.0 - 127.255.255.255</li> <li>Class B</li> <li>Network ID: 2 bytes, Host ID: 2 bytes</li> <li>Starting bits: 01</li> <li>Format: 01, Network ID (14 bits), Host ID (16 bits)</li> <li>Range: 128.0.0.0 - 191.255.255.255</li> <li>Class C</li> <li>Network ID: 3 bytes, Host ID: 1 byte</li> <li>Starting bits: 110</li> <li>Format: 110, Network ID (21 bits), Host ID (8 bits)</li> <li>Range: 192.0.0.0 - 223.255.255.255</li> <li>Class D</li> <li>Multicast addresses</li> <li>Starting bits: 1110</li> <li>Range: 224.0.0.0 - 239.255.255.255</li> <li>Class E</li> <li>Reserved for military &amp; experimental purposes</li> <li>Starting bits: 1111</li> <li>Range: 240.0.0.0 - 255.255.255.255</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_internet_protocol#classless-addressing","title":"Classless Addressing","text":"<ul> <li>Invented to keep internet running out of IP addresses and reduce its wastage</li> <li>Also known as Classless Inter-Domain Routing (CIDR)</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_internet_protocol#subnetting","title":"Subnetting","text":"<ul> <li>Partitioning a single physical network into smaller logical sub-networks</li> <li>Divides a large block of addresses into several contiguous sub-blocks</li> <li>And assigns them to smaller networks</li> <li>A subnet or subnetwork is a network inside a network</li> <li>Reduces network traffic &amp; complexity</li> <li>Traffic can travel shorter distance without passing through unnecessary routers</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_internet_protocol#subnet-mask","title":"Subnet Mask","text":"<ul> <li>32-bit number that masks an IP address by dividing it into network and host address</li> <li>Used to identify the subnet to which an IP address belongs</li> <li>Subnet mask: Network bits are set to 1 and host bits are set to 0</li> <li>Network address: Bitwise AND is performed on the IP address and the mask</li> <li>Broadcast address: Bitwise OR is performed on the network address and the inverted mask</li> <li>Number of hosts per subnet: 2 ^ (32 - given bits for mask) - 2</li> <li>The address includes the number of bits for mask (assigned to the network address)</li> <li>Usually represented by /n</li> <li>Classes</li> <li>Class A: /8, 255.0.0.0</li> <li>Class B: /16, 255.255.0.0</li> <li>Class C: /24, 255.255.255.0</li> <li>Two addresses are reserved</li> <li>First address is the network address</li> <li>Last address is the broadcast address</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_internet_protocol#example","title":"Example","text":"<ul> <li>216.3.128.12/25</li> <li>32 bits = 25 bits (network) + 7 bits (host)</li> <li>Put 25 bits as 1 and 7 bits as 0 to get the subnet mask</li> <li>216.3.128.12 with subnet mask of 255.255.255.128</li> <li>Network address: 216.3.128.0</li> <li>Broadcast address: 216.3.128.127</li> <li>Host IP range: 216.3.128.0 to 216.3.128.126</li> <li>IP class: C</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_internet_protocol#supernetting","title":"Supernetting","text":"<ul> <li>Combining multiple networks to form a bigger network</li> <li>Process of aggregating routes for multiple smaller networks</li> <li>Saves storage space in routing table</li> <li>Simplifies routing decisions</li> <li>Reduces route advertisements to neighboring gateways</li> <li>Conditions</li> <li>All the networks should be contiguous</li> <li>The block size of every network should be equal and must be in form of 2^n</li> <li>First network ID should be exactly divisible by whole size of supernet</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_v6","title":"Internet Protocol version 6 (IPv6)","text":"<ul> <li>Developed to deal with the problem of IPv4 exhaustion</li> <li>Address depletion as the need for electronic devices rose quickly<ul> <li>When internet of things (IOT) came into picture</li> </ul> </li> <li>128-bits address having address space of 2^128 which is way bigger than IPv4</li> <li>Uses hexadecimal format separated by colon</li> <li>Components in address<ul> <li>8 groups, each group represents 2 bytes</li> <li>Each hexdigit is of 4 bits</li> </ul> </li> <li>Better header format</li> <li>Options are separated from the base header<ul> <li>And inserted when needed between the base header &amp; upper layer data</li> </ul> </li> <li>Simplifies and speeds up the routing process<ul> <li>Because most of the options don't need to be checked by routers</li> </ul> </li> <li>Allows new options for additional functionalities</li> <li>And extension of protocol for new technologies</li> <li>Provides better security, priortization, real-time communication, mobile device support</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_v6#addressing-methods","title":"Addressing Methods","text":"<ul> <li>Unicast Address</li> <li>Identifies a single network interface</li> <li>Multicast Address</li> <li>Used by multiple hosts which need not be geographically together</li> <li>Broadcast address was removed due to performance reasons<ul> <li>Though it can be achieved using multicasts</li> </ul> </li> <li>Anycast Addresss</li> <li>Assigned to a group of interfaces</li> <li>Any packet sent is delivered to only one member interface<ul> <li>Mostly the nearest host</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_v6#unicast-addresses","title":"Unicast Addresses","text":"<ul> <li>Provider based: Used for global communication, contains provider id &amp; subscriber id</li> <li>Geography based: Based on location, contains details like lat &amp; long</li> <li>Local</li> <li>Link local: Used for addressing a single link</li> <li>Site local: Equivalent to a private IP address in IPv4</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_datagram_fragmentation","title":"IP Datagram Fragmentation","text":"<ul> <li>Different networks may have different maximum transmission unit (MTU)</li> <li>For example, it can be due to differences in LAN technology</li> <li>MTU determine the maximum size of a data packet that can be transmitted over that network</li> <li>When one network wants to transmit datagrams to a network with a smaller MTU</li> <li>The routers on the path may fragment and reassemble datagrams</li> <li>Each of the fragments contain a portion of the original packet</li> <li>Along with additional info that identifies a fragment's position in the original packet</li> <li>And how it fits into the sequence of fragments</li> <li>Done by the network layer at the destination side, usually at the routers</li> <li>Source side does not require fragmentation due to segmentation by transport layer</li> <li>Segmentation is done in such a way that<ul> <li>Resulting data can easily fit in a frame without the need of fragmentation</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_datagram_fragmentation#delays","title":"Delays","text":"<ul> <li>Fragmentation can cause delays and other network issues</li> <li>Increased processing and memory overhead from the network devices involved in transmission</li> <li>Increased likelihood of packet loss or corruption</li> <li>Since each fragment is transmitted separately</li> <li>If any fragments are lost or corrupted</li> <li>The entire packet must be retransmitted which can introduce delays &amp; network congestion</li> <li>Reassembly delays especially if there are delays in receiving all the fragments</li> <li>Or if they arrive out of order</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_datagram_fragmentation#avoiding-delays","title":"Avoiding Delays","text":"<ul> <li>To avoid these issues, it is generally recommended to avoid fragmentation whenever possible</li> <li>By ensuring that packets are appropriately sized for the network links they will traverse</li> <li>This can be done through path MTU discovery</li> <li>It allows devices to determine the maximum packet size</li> <li>That can be transmitted without fragementation on a given network</li> <li>Additionaly, QoS mechanisms can be implemented</li> <li>To prioritize traffic and reduce delays by congestion</li> </ul>"},{"location":"computer_networks/L3_network_layer/ip_datagram_fragmentation#working","title":"Working","text":"<ul> <li>When a packet is received at the router, destination is examined and MTU is determined</li> <li>If the size of the packet is bigger than MTU</li> <li>'Do not fragment' (DF) bit is set to 0 in header</li> <li>Packet is fragmented into parts and sent one by one</li> <li>Maximum size of each fragment is (MTU - header size)</li> <li>Each fragment is converted to a packet</li> <li>Total length field is changed to the size of the fragment</li> <li>'More fragment' (MF) bit is set for all the fragment packets except the last one</li> <li>Fragment offset field is set based on the number of fragments, which is used to identify the sequence of frames</li> <li>Header checksum is re-calculated</li> <li>Reassembly of fragment takes place only at the destination</li> <li>And not at routers since packets take an independent path</li> </ul>"},{"location":"computer_networks/L3_network_layer/icmp_internet_control_message_protocol","title":"ICMP (Internet Control Message Protocol)","text":"<ul> <li>Mostly utilized on network equipment like routers for error handling</li> <li>Provides hosts with information about network problems</li> <li>Encapsulated within IP datagrams with specific headers &amp; data</li> <li>Helps in network diagnosis by using traceroute and ping utility</li> <li>IP depends on ICMP for sending error and control messages</li> <li>Because it does not have an inbuilt mechanism for it</li> <li>Connection-less protocol</li> <li>Doesn't need to establish a connection<ul> <li>With the destination device before sending a message</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/icmp_internet_control_message_protocol#types-of-messages","title":"Types of Messages","text":"<ul> <li>Source Quench Message</li> <li>Request to decrease traffic rate for messages sent to the host destination</li> <li>When the congested router is far away from the source<ul> <li>ICMP will send this message hop by hop</li> <li>So that every router reduces the speed of transmission</li> </ul> </li> <li>Parameter Problem Message</li> <li>When a packet comes to a router<ul> <li>The calculated header checksum should be equal to the received header checksum</li> <li>If there is a mismatch, the packet is dropped by the router</li> </ul> </li> <li>ICMP informs the source about this by sending a parameter problem message</li> <li>Redirection Message</li> <li>If a host tries to send data through router R1</li> <li>And if R1 sends data to R2 and there is a direct way from the host to R2</li> <li>Then R1 will send a redirect message to the source to inform about the best route</li> <li>Other messages</li> <li>Time exceeded</li> <li>Destination unreachable</li> </ul>"},{"location":"computer_networks/L3_network_layer/icmp_internet_control_message_protocol#traceroute","title":"Traceroute","text":"<ul> <li>Traces a packet from computer to host</li> <li>And shows the number of hops &amp; time required to reach there</li> <li>Works by sending packets with low survival time i.e. time to live (TTL)</li> <li>It specifies how many hops can the packet survive</li> <li>When the packet expires<ul> <li>The node where it expired returns the packet and identifies itself</li> </ul> </li> <li>By increasing the TTL gradually, it is able to identify intermediate hosts</li> <li>If any of the hops returns with 'request timed out', it denotes netowork congestion</li> </ul>"},{"location":"computer_networks/L3_network_layer/icmp_internet_control_message_protocol#ping","title":"Ping","text":"<ul> <li>Helps to check if a particular IP address is accessible or not</li> <li>Works by sending a packet to the specified address and waits for a reply</li> <li>Measures round trip time and reports errors</li> <li>Also used to check if the computers on a local network are active</li> </ul>"},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol","title":"ARP (Address Resolution Protocol)","text":"<ul> <li>Finds the hardware address of a host from a known address</li> <li>Network layer to data link layer mapping process</li> <li>Most applications use logical address (IP address) to send &amp; receive messages</li> <li>But having IP address is necessary but not sufficient</li> <li>The actual communication happens over the physical address (MAC address)</li> <li>ARP Cache</li> <li>After resolving the MAC address<ul> <li>ARP sends it to the source where it is stored in a table for future reference</li> </ul> </li> <li>The cached MAC address may timeout after sometime</li> </ul>"},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol#working","title":"Working","text":"<ul> <li>It broadcasts a discovery packet to all the devices of the source network</li> <li>Requesting the MAC address of intended destination</li> <li>The packet will be discarded by everyone except the intented receiver host</li> <li>The devices peel the header of the data link layer called frame</li> <li>And transfer the packet to the network layer</li> <li>Where network ID of the packet is validated with the destination IP's network ID</li> <li>If it's equal</li> <li>It responds to the source with the MAC address of the destination using unicast packet</li> <li>Sender updates ARP cache and starts sending unicast messages to the destination</li> <li>Else the packet reaches the gateway of the network</li> <li>And broadcasts packet to the connected devices and validates their network ID</li> </ul>"},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol#arp-spoofing-or-poisoning","title":"ARP Spoofing or Poisoning","text":"<ul> <li>Attacker sends a falsified ARP request over LAN</li> <li>Which connects its MAC address to the legitimate server</li> <li>After that, the attacker will start receiving the data intended for that IP address</li> <li>It can intercept data frames, modify traffic, stop data in transit</li> <li>Can act as the opening for other major attacks</li> <li>Like man in the middle, denial of service, session hijacking</li> </ul>"},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol#types","title":"Types","text":""},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol#reverse-arp","title":"Reverse ARP","text":"<ul> <li>Used in LAN by client machines</li> <li>For requesting IP address from the gateway router's ARP table</li> <li>Whenever a new machines comes</li> <li>The machine sends a RARP broadcast packet containing its own MAC address</li> <li>A special host configured inside LAN replies to these broadcast packages</li> <li>If an entry is found in the mapping table<ul> <li>It sends the response packet with the IP address</li> </ul> </li> <li>Has been replaced by BOOTP (Bootstrap Protocol) and DHCP</li> </ul>"},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol#proxy-arp","title":"Proxy ARP","text":"<ul> <li>Resolves IP address to MAC address for devices separated into network segments</li> <li>Connected through a router in the same IP or sub-network</li> <li>When devices are not in the same data link layer network but are in the same IP network</li> <li>They try to transmit data to each other as if they were on the local network</li> <li>But the router that separates the devices cannot broadcast messages<ul> <li>Because routers do not pass hardware-layer broadcasts</li> </ul> </li> <li>The proxy router that resides between local networks responds with its MAC address</li> <li>As if it were the router to which the broadcast is addressed</li> <li>The sending device after receiving the MAC address of the proxy router<ul> <li>Sends datagram to the proxy router which in turn sends it to the destination device</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol#inverse-arp","title":"Inverse ARP","text":"<ul> <li>Uses MAC address to find the IP address (inverse of ARP)</li> <li>Enabled by default in ATM (Asynchronous Transfer Mode) networks and frame relays</li> </ul>"},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol#gratuitous-arp","title":"Gratuitous ARP","text":"<ul> <li>Used in advanced network scenarios and detecting duplicate IP addresses</li> <li>Performed by computer while booting up</li> <li>When NIC (Network Interface Card) is powered for the first time</li> <li>It automatically broadcast its MAC address to entire network</li> <li>After that, MAC address of the computer is known to every switch</li> <li>And allows DHCP servers to know where to send the IP address if requested</li> </ul>"},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol#packet-flow","title":"Packet Flow","text":"<ul> <li>First of all, it is checked if the destination is present in the same network or not</li> <li>How the source device will know that</li> <li>AND operation is performed between<ul> <li>Source IP address and source subnet mask</li> <li>Destination IP address and source subnet mask</li> </ul> </li> <li>If the resultant of both are same then the destination is present in the same network</li> </ul>"},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol#same-network","title":"Same Network","text":"<ul> <li>It is checked if the ARP has been resolved or not</li> <li>To resolve ARP, ARP request is broadcasted to all the other hosts in the network</li> <li>This generates two packets, one for ICMP &amp; other for ARP</li> <li>The broadcast is performed with the help of a switch<ul> <li>Routers don't forward broadcast packets</li> </ul> </li> <li>The request is received by the target host</li> <li>And it unicasts an ARP reply specifying its MAC address</li> <li>The reply is received by the switch and forwarded to the source host</li> <li>The switch is able to do so because it has an entry<ul> <li>For the source host in its MAC table</li> <li>This was added when the source host broadcasted the ARP request</li> </ul> </li> <li>After resolution, the ICMP ack packet is unicasted from the destination to the source host</li> </ul>"},{"location":"computer_networks/L3_network_layer/arp_address_resolution_protocol#different-network","title":"Different Network","text":"<ul> <li>The packet is delivered to the default gateway first</li> <li>Which in turn delivers to the destination host</li> <li>MAC address never crosses its broadcast domain</li> <li>At the source network</li> <li>It is checked if the ARP has not been resolved or not</li> <li>To resolve ARP, ARP request is broadcasted to all the other hosts in the network</li> <li>This generates two packets, one for ICMP &amp; other for ARP</li> <li>The router accepts the request and unicasts the ARP reply back to the source</li> <li>After resolution, ICMP packet is unicasted to the default gateway</li> <li>At the destination network</li> <li>Now the ARP has to be resolved again<ul> <li>Because the router has to deliver the packet to the destination host</li> <li>The ARP request is broadcasted in the destination network and the same process follows</li> </ul> </li> <li>ICMP echo-request packet is unicasted to the destination host<ul> <li>The destination host generates an ICMP echo reply in response</li> <li>Which is delivered to the router and then unicasted to the source host</li> </ul> </li> <li>The MAC addresses of the source &amp; destination are used only till their respective router</li> <li>After that, the router's MAC address is used</li> </ul>"},{"location":"computer_networks/L3_network_layer/routing","title":"Routing","text":""},{"location":"computer_networks/L3_network_layer/routing#parameters","title":"Parameters","text":"<ul> <li>Performance Criteria</li> <li>Number of hops</li> <li>Cost (send packet with high bandwidth path)</li> <li>Delay (size of queue)</li> <li>Throughput time</li> <li>Decision Time</li> <li>When to decide to route a packet</li> <li>Per packet (datagram) or per session (virtual circuit)</li> <li>Decision Place</li> <li>Who will decide about routing</li> <li>Each node (distributed) or central node (centralized) or originate node (source)</li> <li>Network information</li> <li>Source: local, adjacent node, nodes along the route, all nodes</li> <li>Update time: continuous, periodic, major load change, topology change</li> </ul>"},{"location":"computer_networks/L3_network_layer/routing#strategies","title":"Strategies","text":""},{"location":"computer_networks/L3_network_layer/routing#fixed-routing","title":"Fixed Routing","text":"<ul> <li>A route is selected for each source &amp; destination pair of nodes in the network</li> <li>The route is fixed and changes only if the topology changes</li> <li>Central routing matrix is created based on the least cost path</li> <li>It shows each source-destination and identity of the next node on the route</li> <li>Stored in the network control center, but if that fails everything will collapse</li> <li>Famous path algorithms: dijkstra, bellman ford</li> <li>Doesn't react to failure or network congestion</li> </ul>"},{"location":"computer_networks/L3_network_layer/routing#flooding","title":"Flooding","text":"<ul> <li>Every incoming packet is sent out on every outgoing node</li> <li>All possible routes between the source &amp; destination are tried</li> <li>Generates a vast amount of duplicate packets</li> <li>Requires no network info like topology, load condition, cost of different paths</li> <li>If an approximation is known, a hop counter is sent which is decremented at each hop</li> <li>The packet is discarded when the counter becomes zero</li> <li>Highly robust, always chooses the shortest path</li> <li>But wastes a lot of network resources and leads to congestion</li> <li>Used to send emergency messages or in military applications</li> </ul>"},{"location":"computer_networks/L3_network_layer/routing#redundant-link-problems","title":"Redundant Link Problems","text":"<ul> <li>Redundant links are used to prevent nasty network failures</li> <li>By providing backups but it can cause some problems</li> <li>Broadcast storm</li> <li>A switch forwards out a broadcast frame generated by another device to all its hosts</li> <li>If no loop avoidance schemes are applied, the switches will flood broadcasts endlessly</li> <li>This can shut down the entire network in seconds by consuming all the bandwidth</li> <li>Multiple copies</li> <li>A device receives multiple copies of the same frame<ul> <li>From different network segements at the same time</li> </ul> </li> <li>If a protocol cannot handle duplicate transmission, it can be a problem</li> <li>MAC table thrashing</li> <li>Switches use MAC address table to forward frames</li> <li>When a switch receives a frame<ul> <li>It makes an entry of the device mac address with the switch port on which it's received</li> </ul> </li> <li>But if the switch receives the frame of the same source from multiple links<ul> <li>It can be confusing for the switch to make an entry</li> <li>This can lead to unstability in MAC table</li> </ul> </li> <li>Spanning Tree Protocol (STP) is used to prevent these loops<ul> <li>It will block down a port path for frame delivery at a time</li> <li>If one path goes down, then the blocked path becomes active</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/routing#administrative-distance-ad","title":"Administrative Distance (AD)","text":"<ul> <li>Used to rate the trustworthiness of routing information received from a neighbor router</li> <li>The route with the least AD is selected as the best route and placed in the routing table</li> <li>It is an integer value from 0 to 255</li> <li>0 shows that the route is most trusted</li> <li>255 means that no traffic will be passed through that route</li> <li>Default AD</li> <li>Connected interface: 0, Static route: 1</li> <li>External BGP: 20</li> <li>EIGRP: 90, OSPF: 110, RIP: 120</li> <li>External EIGRP: 170, Internal BGP: 200</li> <li>Unknown (not used): 255</li> </ul>"},{"location":"computer_networks/L3_network_layer/routing#autonomous-system-as","title":"Autonomous System (AS)","text":"<ul> <li>Group of routers &amp; networks working under a single administrative domain</li> <li>16-bit value that defines the routing domain of the routers (1 to 65535)</li> <li>Public AS number</li> <li>Service provider provides a public AS<ul> <li>If the customer is connected to multiple ISPs (mutli home network)</li> </ul> </li> <li>Ranges from 1 to 64511</li> <li>Private AS number</li> <li>Service provider provides a private AS<ul> <li>If the customer wants multi-connection to a single ISP</li> <li>For example, single home or dual home network</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/routing#longest-prefix-matching-in-routers","title":"Longest Prefix Matching in Routers","text":"<ul> <li>IP prefix</li> <li>All computers on one network have the same IP prefix</li> <li>For example, in 192.24.0.0/18, first 18 bits of the address is prefix</li> <li>Forwarding</li> <li>Moving incoming packets to the appropriate interface</li> <li>Routers use a forwarding table<ul> <li>To decide which incoming packets should be forwarded to which hop</li> </ul> </li> <li>They search the destination address's IP prefix in the forwarding table</li> <li>Prefixes might overlap since classless addressing is used everywhere</li> <li>In that case, routers use the longest prefix matching rule</li> <li>The table entry with the longest prefix matching<ul> <li>With the incoming packet's destination IP is considered</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/routing_protocols","title":"Routing Protocols","text":""},{"location":"computer_networks/L3_network_layer/routing_protocols#packet-types","title":"Packet Types","text":"<ul> <li>There are two types of packets used in the network layer</li> <li>Data packets</li> <li>Used to transfer user data</li> <li>Supported by routed protocols like IP</li> <li>Route update packets</li> <li>Used to update info about networks connected to all the routers<ul> <li>To neighbouring routers</li> </ul> </li> <li>Supported by routing protocols<ul> <li>Like RIP (Routing Information Protocol), OSPF (Open Shortest Path First)</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/routing_protocols#routing-protocols_1","title":"Routing Protocols","text":"<ul> <li>Help routers determine the best path for data to reach its destination</li> <li>Based on factors like network congestion, network latency, network distance</li> <li>Can detect failures and redirect traffic to alternative paths</li> <li>Allow networks to grow &amp; change dyanmically</li> <li>Without any manual reconfiguration of individual routers</li> <li>A routing table is created which contains information about the routes</li> </ul>"},{"location":"computer_networks/L3_network_layer/routing_protocols#types","title":"Types","text":"<ul> <li>Static or Non-adaptive</li> <li>Routes are manually configured</li> <li>And they are not dynamically updated based on network changes</li> <li>Best suited for small networks where topology does not change</li> <li>Dynamic or Adaptive</li> <li>Routes are automatically updated based on network changes<ul> <li>Topology, load, delay, distance, number of hops, estimated transit time</li> </ul> </li> <li>When a router finds a change in topology, it advertises to all other routers</li> <li>Best suited for large &amp; complex networks where topology changes frequently</li> <li>Default</li> <li>Router is configured to send all packets toward a single router (next hop)</li> <li>It is forwared to the default router<ul> <li>Irrespective of which network the packet belongs</li> </ul> </li> <li>Heirarchical</li> <li>Network is divided into multiple levels or domains<ul> <li>With each level having its own routing protocol</li> </ul> </li> <li>Best suited for large &amp; complex networks<ul> <li>That needs to be divided into manageable sections</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/routing_protocols#dynamic-routing-protocols","title":"Dynamic Routing Protocols","text":""},{"location":"computer_networks/L3_network_layer/routing_protocols#distance-vector-routing-protocol","title":"Distance Vector Routing Protocol","text":"<ul> <li>Selects the best path on the basis of hop counts to reach the destination network</li> <li>Each router computes distance of its immediate neighbours</li> <li>Router shares knowledge about whole network to its neighbours</li> <li>Updates (routing info) is not broadcasted</li> <li>But shared to neighbouring nodes periodically</li> <li>A router shares its knowledge about the whole network (full routing tables)</li> <li>This is called routing on rumours</li> <li>Works on bellman ford algorithm</li> <li>Each router maintains a distance vector table<ul> <li>Containing its distance from all possible destination nodes</li> </ul> </li> <li>Characteristics</li> <li>Based on: Local knowledge</li> <li>Bandwidth required: Less (local sharing, small packets, no flooding)</li> <li>Information sharing: Regular intervals</li> <li>Algorithm to make routing table: Bellman-ford</li> <li>Traffic: Less</li> <li>Convergence: Slow</li> <li>Problems: Count to infinity, Slow convergence, Persistent loops</li> </ul>"},{"location":"computer_networks/L3_network_layer/routing_protocols#routing-loops","title":"Routing Loops","text":"<ul> <li>Routing loops is the main issue since bellman ford algorithm cannot prevent loops</li> <li>Usually occur when an interface goes down or two routers send updates at the same time</li> <li>Routing loops cause count to infinity problem</li> <li>Wrong information keeps propogating within each other toward infinity</li> <li>Let's say AB = 1 &amp; BC = 1, so AC = 2<ul> <li>If B &amp; C are disconnected, B will remove C from its table</li> <li>Meanwhile, if A advertises that AC = 2, then B updates BC = 3 since AB = 1</li> <li>A then receives update from B that BC = 3 and it updates AC = 4 since AB = 1</li> </ul> </li> <li>Spreading the bad information is called route poisoning</li> <li>Solutions: Poison reverse, Split horizon</li> <li>Examples: RIP (Routing Information Protocol)</li> </ul>"},{"location":"computer_networks/L3_network_layer/routing_protocols#link-state-routing-protocol","title":"Link State Routing Protocol","text":"<ul> <li>Knows more about internetwork than distance vectors</li> <li>Each router has node map and calculates best path</li> <li>Router shares knowledge of its neighbours with all the routers</li> <li>Maintains neighbor table, topology table, routing table</li> <li>Knowledge about the neighborhood</li> <li>Instead of sending routing table, a router sends info about its neighborhood only</li> <li>A router broadcasts its identities and cost of directly attached links</li> <li>Hello messages or keep alive messages are used for neighbor discovery &amp; recovery</li> <li>Flooding</li> <li>In flooding, each router sends info<ul> <li>To every other router on the internetwork except its neighbors</li> </ul> </li> <li>Every router that receives the packet sends the copies to all the neighbors</li> <li>Information Sharing</li> <li>Router sends information only when a change occurs in the information</li> <li>Only the updates requested by the neighbor router are exchanged</li> <li>Initially each node knows the cost of its neighbors</li> <li>And finally each node knows the entire graph</li> <li>Dijkstra's algorithm is used to calculate optimal routes</li> <li>Characteristics</li> <li>Based on: Global knowledge</li> <li>Bandwidth required: More (large packets, flooding)</li> <li>Information sharing: Whenever there is a change</li> <li>Algorithm to make routing table: Dijkstra</li> <li>Traffic: More</li> <li>Convergence: Fast</li> <li>Problems: Heavy traffic due to packet flooding</li> <li>Examples: OSPF (Open Shortest Path First)</li> </ul>"},{"location":"computer_networks/L3_network_layer/routing_protocols#advanced-distance-vector-routing-protocol","title":"Advanced Distance Vector Routing Protocol","text":"<ul> <li>Hybrid of distance vector &amp; link state routing protocols</li> <li>Examples: EIGRP (Enhanced Interior Gateway Routing Protocol)</li> </ul>"},{"location":"computer_networks/L3_network_layer/routing_protocols#redistribution","title":"Redistribution","text":"<ul> <li>Using a single routing protocol in an organization is preferred</li> <li>But under some conditions, we have to use multiple protocols</li> <li>Like company mergers, multi-vendor devices</li> <li>Advertising a route learned through a routing protocol</li> <li>Into another routing protocol is called redistribution</li> <li>We have to define metric of the routing protocol in the advertising routing protocol</li> <li>For example, to advertise EIGRP into RIP, we have to define hop count (metric of RIP)</li> </ul>"},{"location":"computer_networks/L3_network_layer/nat_network_address_translation","title":"Network Address Translation (NAT)","text":"<ul> <li>Allows multiple devices to access the internet through a single public address</li> <li>Also masks the port number of the host with another port</li> <li>Provides privacy to the local users<ul> <li>And rejects malicious packet not requested by anyone</li> </ul> </li> <li>A network device (router or firewall) assigns a public address</li> <li>To a computer (or group of computers) inside a private network</li> <li>The main use of NAT is to limit the number of public IP addresses</li> <li>That an organization or company must use</li> <li>For both economy and security purposes</li> </ul>"},{"location":"computer_networks/L3_network_layer/nat_network_address_translation#working","title":"Working","text":"<ul> <li>Generally, the border router is configured for NAT</li> <li>Border router is the one that has one interface in the local (inside) network</li> <li>And one interface in the global (outside) network</li> <li>When a packet traverse outside the local network</li> <li>NAT converts the local (private) IP address to global (public) IP address</li> <li>When a packet enters the local network</li> <li>Global IP address is converted to local IP address</li> <li>If NAT runs out of addresses in the configured pool, the packets are dropped</li> <li>And ICMP sents unreachable packet to the destination</li> </ul>"},{"location":"computer_networks/L3_network_layer/nat_network_address_translation#masking-port-numbers","title":"Masking Port Numbers","text":"<ul> <li>Let's say two hosts A and B are connected</li> <li>Both of them request for the same destination</li> <li>On the same port number (say 1000) on the host side at the same time</li> <li>On receiving a reply from the destination<ul> <li>It will be unclear to NAT which reply belongs to which host</li> </ul> </li> <li>To avoid such a problem</li> <li>NAT masks the source port number and makes an entry in the NAT table</li> </ul>"},{"location":"computer_networks/L3_network_layer/nat_network_address_translation#types","title":"Types","text":"<ul> <li>Static NAT</li> <li>A single unregistered (private) IP address<ul> <li>Is mapped with a registered (public) IP address</li> </ul> </li> <li>Generally used for web hosting</li> <li>Not used in organization as there are many devices that need internet access</li> <li>Dynamic NAT</li> <li>An unregistered IP address is translated to a registered IP address<ul> <li>From a pool of public addresses</li> </ul> </li> <li>If no IP address of the pool is free, then the packet is dropped</li> <li>Used when the number of users who want internet access is fixed</li> <li>Not used in organization<ul> <li>As each user that wants to access internet needs to be assigned a global address</li> </ul> </li> <li>Port Address Translation (PAT)</li> <li>Also known as NAT overload</li> <li>Many local IP addresses can be translated to a single registered IP address</li> <li>Port numbers are used to distinguish the traffic</li> <li>Most frequently used, cost effective</li> </ul>"},{"location":"computer_networks/L3_network_layer/isdn_integrated_services_digital_network","title":"Integrated Services Digital Network (ISDN)","text":"<ul> <li>Communication standards for simultaneous digital transmission</li> <li>Including voice, video, data, and other network services</li> <li>Over traditional circuits of the public switched telephone network</li> <li>It can integrate speech and data on the same lines, which was not available before</li> <li>It is a circuit switched telephone network system</li> <li>But also provides access to packet switched networks for data<ul> <li>In increments of 64 Kbit/s</li> </ul> </li> <li>This allows digital transmission of voice and data</li> <li>This results in better voice or data quality than an analog phone</li> <li>Costlier than other telephone system and requires specialized digital devices</li> </ul>"},{"location":"computer_networks/L3_network_layer/isdn_integrated_services_digital_network#interfaces","title":"Interfaces","text":"<ul> <li>Basic Rate Interface (BRI)</li> <li>There are two data bearing channels (B channels) and one signaling channel (D channel)<ul> <li>B (Bearer) channels</li> <li>Operate at a max of 64 Kbps</li> <li>Carries user data like voice, video or computer data</li> <li>D (Data) channel</li> <li>Operates at a max of 16 Kbps</li> <li>Used for any combination of data, control, signaling</li> </ul> </li> <li>Total speed = 64 * 2 + 16 = 144 Kbps<ul> <li>192 Kbps including 48 Kbps operating overhead of BRI service</li> </ul> </li> <li>The two channels are independent of each other. For example:<ul> <li>One channel is used as TCP/IP connection to a location</li> <li>Other channel is used to send fax to a remote location</li> </ul> </li> <li>Primary Rate Interface (PRI)</li> <li>Consists of one D channel and either 23 or 30 B channels depending on the country</li> <li>Both types of channel operate at 64 Kbps</li> <li>Total speed = 1.546 Mbps (23 B channels + 1 D channel)<ul> <li>1.544 Kbps includeing 9 Kbps overhead</li> </ul> </li> <li>Broadband-ISDN</li> <li>Narrowband ISDN designed to operate over the current communications infrastructure</li> <li>Heavily dependent on copper cable, but mainly relies on the evolution of fiber optics</li> <li>Capable of supporting rates greater than the primary rate</li> </ul>"},{"location":"computer_networks/L3_network_layer/isdn_integrated_services_digital_network#services","title":"Services","text":"<ul> <li>Bearer Services</li> <li>Transfer of information (voice, data, video) between users<ul> <li>Without the network manipulating the content</li> </ul> </li> <li>No need for the network to process the information</li> <li>Belongs to the first three layers of the OSI model</li> <li>Provided using circuit switched, packet switched, frame switched, or cell switched networks</li> <li>Tele Services</li> <li>Network may change or process the contents of the data</li> <li>Corresponds to layers four to seven of the OSI model</li> <li>Relies on the facilities of the bearer services</li> <li>Designed to accomodate complex user needs</li> <li>Includes telephony, teletex, telefax, videotex, telex, teleconferencing</li> <li>Supplementary Service</li> <li>Provides additional functionality to the bearer services and the tele services</li> <li>Examples: Reverse charging, call waiting, message handling</li> </ul>"},{"location":"computer_networks/L3_network_layer/aaa_authentication_authorization_accounting","title":"AAA (Authentication, Authorization, Accounting)","text":"<ul> <li>AAA is a standard framework used to control</li> <li>Who is permitted to use network resources (authentication)</li> <li>What are they authorized to do (authorization)</li> <li>Capture the actions performed while accessing the network (accounting)</li> <li>An administrator can access a router or a device through a console</li> <li>But it is incovenient if he is sitting far from the place of that device</li> <li>So he has to take remote access to that device</li> <li>As remote access will be available by using an IP address</li> <li>It is possible that an unauthorized user can take access using that IP address</li> <li>So for security measures, we have to put authentication</li> <li>Also, the packets exchanged between the device should be encrypted<ul> <li>So that any other person cannot capture sensitive info</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/aaa_authentication_authorization_accounting#authentication","title":"Authentication","text":"<ul> <li>Identifying if a user that wants to access the network resources is valid or not</li> <li>Common methods are to put authentication on console port, AUX port, or VTY lines</li> </ul>"},{"location":"computer_networks/L3_network_layer/aaa_authentication_authorization_accounting#authorization","title":"Authorization","text":"<ul> <li>Enforces policies on network resources</li> <li>After user has gained access to the network resources through authentication</li> <li>Determines what resources is the user allowed to access</li> <li>And the operations that can be performed</li> <li>For example, junior engineer and senior engineer will have different permissions</li> </ul>"},{"location":"computer_networks/L3_network_layer/aaa_authentication_authorization_accounting#accounting","title":"Accounting","text":"<ul> <li>Monitoring and capturing events performed by a user while accessing network resources</li> <li>Monitors how long the user has access to the network</li> <li>Administrator can create an accounting method list</li> <li>To specify what should be accounted for</li> <li>To whom the accounting records should be sent</li> </ul>"},{"location":"computer_networks/L3_network_layer/aaa_authentication_authorization_accounting#implementation","title":"Implementation","text":"<ul> <li>AAA can be implemented by using the local database of router or by using external ACS server</li> <li>Local database of the device (router)</li> <li>First users are created for authentication</li> <li>Then privilege levels are provided to users for authorization</li> <li>Sending authentication requests to an external server like ACS server</li> <li>Configuration on both router and ACS is required<ul> <li>If ACS server fails to authenticate, local database can be used as a backup</li> </ul> </li> <li>Configuration includes creating user<ul> <li>Separate customized method list for authentication, autorization, accounting</li> </ul> </li> <li>Client or Network Access Server (NAS) sends authentication requests to ACS server<ul> <li>Server takes the decision to allow the user to access the network resource or not</li> <li>According to the credentials provided by the user</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/aaa_authentication_authorization_accounting#challenge-response-authentication-mechanism-cram","title":"Challenge Response Authentication Mechanism (CRAM)","text":"<ul> <li>Used to authenticate actions</li> <li>One side presents a challenge</li> <li>And the other side must present a correct answer to get authenticated</li> <li>Types of challenges</li> <li>Static<ul> <li>User can select his challenge and authenticate himself</li> <li>For example, security questions</li> <li>That you select while account setup and asked in forget password</li> </ul> </li> <li>Dynamic<ul> <li>Challenges are selected randomly presuming that the user will know the valid answer</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/aaa_authentication_authorization_accounting#implementation_1","title":"Implementation","text":"<ul> <li>CAPTCHA</li> <li>Completely automated public turing test to tell computers and humans apart</li> <li>Used to prevent spam and auto-registratoin of new accounts</li> <li>Machine learning is used to train different types of models</li> <li>Examples<ul> <li>User needs to enter a text or number from the distorted image</li> <li>Images are presented and user needs to select the right pieces based on a prompt</li> </ul> </li> <li>SSH (Secure Shell)</li> <li>Cyptographic network protocol</li> <li>For operating network services securely over an unsecured network</li> <li>Password</li> <li>Password is sent to the server for validation by matching with the correct password</li> <li>Salted CRAM</li> <li>Challenge is salted with a hash to make sure the password is used one time only</li> <li>Hash is sent to server for matching with the hash of the correct password</li> <li>So the password is not revealed to man in the middle attack and replay attacks</li> <li>Biometrics</li> </ul>"},{"location":"computer_networks/L3_network_layer/access_control","title":"Access Control Lists (ACL)","text":"<ul> <li>Set of rules defined to control network traffic and reduce network attacks</li> <li>Once a rule matches, no further comparison takes place</li> <li>If no rule matches, then the packet is discarded</li> <li>Direction</li> <li>Inbound access list is applied on inbound packets</li> <li>Outbound access list is applied on outbound packets</li> <li>Only one list per interface per protocol per direction can be assigned</li> </ul>"},{"location":"computer_networks/L3_network_layer/access_control#types","title":"Types","text":"<ul> <li>Standard access list</li> <li>Uses only the source IP address</li> <li>Permits or denies the entire protocol suite</li> <li>Doesn't distinguish between the IP traffic like TCP, UDP, HTTPS, etc.</li> <li>Extended access list</li> <li>Uses source IP &amp; port and destination IP &amp; port</li> <li>Can also mention which type of IP traffic should be allowed or denied</li> <li>Reflexive access list</li> <li>Acts as a stateful firewall<ul> <li>As it allows only the traffic that is initiated within the network &amp; its replies</li> <li>And denies other packets coming from outside the network</li> </ul> </li> <li>When a session is initiated<ul> <li>It creates a temporary entry for the traffic which allows the replies from outside</li> </ul> </li> <li>Should be nested inside the extended access list</li> <li>Time-based access list</li> <li>Allows access based on particular time of the day or particular days of a week</li> <li>Can deny access to internet on working hours and allow access in lunch time</li> <li>Can work with absolute or periodic time range</li> <li>Best works with NTP (Network Time Protocol) synchronisation<ul> <li>But can work with router clock</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/access_control#control-based-access-control-cbac","title":"Control Based Access Control (CBAC)","text":"<ul> <li>Secures and protects the network from unauthorized access and malicious activity</li> <li>Enables granular control of network policies</li> <li>While maintaining flexibility &amp; functionality</li> <li>Unlike traditional access control that rely on static rules &amp; fixed conditions</li> <li>It analyses in real time by considering a wide range of contextual factors</li> <li>ACLs provide traffic filtering till transport layer<ul> <li>While CBAC provides till application layer</li> </ul> </li> <li>With the help of CBAC configuration, a router can act as a firewall</li> <li>In addition to access lists</li> <li>Maintains a state table in which the sessions are maintained in memory<ul> <li>The outbound traffic &amp; its replies can pass the router using this state entry</li> </ul> </li> <li>Maintains TCP/UDP info to perform deeper inspection in packet payload</li> <li>Examines the rate at which the connection has been established<ul> <li>To detect attacks like DoS attack, TCP syn attack and drop malicious packets</li> </ul> </li> <li>Disadvantages</li> <li>Filters traffic passing through<ul> <li>But not the traffic originating or terminating on the configured device</li> </ul> </li> <li>Inspects only TCP &amp; UDP traffic and not ICMP or any other traffic</li> <li>Only protects against traffic through firewall<ul> <li>And not against attacks originating within the protected network</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/wifi","title":"WiFi (Wireless Fidelity)","text":"<ul> <li>Wireless networking technique that functions similar to a local area network</li> <li>Routers and radio frequency waves are used to transmit data</li> <li>Can be less expensive and easier to install than wires &amp; cables</li> <li>It might be challenging to provide reliable coverage<ul> <li>In some areas where signal can become weak</li> </ul> </li> <li>Enables a large number of users to connect to internet</li> <li>At public places or organizations</li> <li>Allows mobile devices to connect to internet</li> </ul>"},{"location":"computer_networks/L3_network_layer/wifi#security-protocols","title":"Security Protocols","text":""},{"location":"computer_networks/L3_network_layer/wifi#wep-wired-equivalent-privacy","title":"WEP (Wired Equivalent Privacy)","text":"<ul> <li>64-bit or 128-bit encryption key</li> <li>That must be manually entered on wireless access points &amp; devices</li> <li>Once configured can never be changed</li> <li>Uses cyclic redundancy check (CRC)</li> <li>Security flaws</li> <li>Does not provide a sufficiently strong data integrity guarantee for the packets</li> <li>Message authentication codes are used to solve this issue<ul> <li>But requires too much computation to be used on old network cards</li> </ul> </li> </ul>"},{"location":"computer_networks/L3_network_layer/wifi#wpa-wifi-protected-access","title":"WPA (Wifi Protected Access)","text":"<ul> <li>Intermediate measure in anticipation of the availability of the more secure &amp; complex WPA2</li> <li>Employs per-packet key dynamically generating a new 128-bit key for each packet</li> <li>Prevents the types of attacks that compromise WEP</li> <li>Includes a message integrity check called TKIP (Temporal Key Integrity Protocol)</li> <li>To prevent attackers from altering or resending data packets</li> <li>Much stronger than CRC used in WEP</li> <li>Security flaws</li> <li>Limitations of the message integrity code hash function<ul> <li>That is used to retrieve the keystream from short packets</li> </ul> </li> <li>Can be used for re-injection and spoofing</li> </ul>"},{"location":"computer_networks/L3_network_layer/wifi#wpa2-wifi-protected-access-2","title":"WPA2 (Wifi Protected Access 2)","text":"<ul> <li>Includes mandatory support for</li> <li>CCMP (Counter Mode CBC-MAC Protocol)<ul> <li>Blocks chaining message authentication code protocol</li> <li>More robust and dependable than TKIP</li> </ul> </li> <li>AES (Advanced Encryption Standard) based encryption mode</li> <li>Mandatory for all new devices to bear the Wifi trademark</li> <li>Security flaws</li> <li>Risk of unwanted access to the company wireless network</li> <li>Occurs when an attack vector on specific WPS access points is compromised</li> </ul>"},{"location":"computer_networks/L3_network_layer/wifi#wpa3-wifi-protected-access-3","title":"WPA3 (Wifi Protected Access 3)","text":"<ul> <li>192-bit cryptographic strength</li> <li>384-bit Hash Message Authentication Mode (HMAC)</li> <li>256-bit Broadcat/Multicast Integrity Protocol (BIP-GMAC-256)</li> <li>256-bit Galois/Counter Model Protocol encryption (GCMP-256)</li> <li>SAE exchange</li> <li>Wifi Device Provisioning Protocol (DPP)</li> </ul>"},{"location":"computer_networks/L3_network_layer/wifi#wps-wifi-protected-setup","title":"WPS (Wifi Protected Setup)","text":"<ul> <li>A wireless network security standard that tries to make connections</li> <li>Between a router and wireless devices in a faster &amp; easier way</li> <li>Works only for wireless networks that use password protection using WPA or WPA2</li> <li>In a standard setup, you can't connect a wireless device to a wireless network</li> <li>Until you know the network name called Service Set Identifier (SSID)</li> <li>And its password called WPA-PSK (Pre-Shared Key)</li> <li>WPS can simplify this connection process</li> <li>Push button<ul> <li>Press the WPS button located on the router and client devices</li> <li>The device connects automatically without password once the buttons are enabled</li> </ul> </li> <li>PIN: Client device must enter the PIN found on the sticker for the access point</li> <li>Network Field Communication: Client device must be brought close to the access point</li> <li>Relatively new technology, so not all devices support it</li> </ul>"},{"location":"computer_networks/L4_transport_layer","title":"L4 Transport Layer","text":"<ul> <li>Introduction</li> <li>TCP (Transmission Control Protocol)</li> <li>UDP (User Datagram Protocol)</li> <li>Congestion Control</li> </ul>"},{"location":"computer_networks/L4_transport_layer/introduction","title":"Introduction","text":"<ul> <li>Basic info</li> <li>Packet: Segment</li> <li>Protocols: TCP, UDP</li> <li>Platforms: OS, Gateways, Firewalls</li> <li>End to end communication layer</li> <li>Reliable message delivery from process to process</li> <li>Ensures messages are in order and without duplication</li> <li>End-to-end (not across single link) delivery, flow control and error control</li> <li>Acknowledges successful data transmission</li> <li>And re-transmits the data if an error is found</li> <li>Provides services to application layer by making system calls</li> <li>And takes services from network layer</li> <li>Service-point addressing</li> <li>Allows computers to run several programs simultaneously</li> <li>Logical communication between processes</li> </ul>"},{"location":"computer_networks/L4_transport_layer/introduction#process-to-process-delivery","title":"Process to process delivery","text":"<ul> <li>Requires port number to correctly deliver the segments of data</li> <li>To the correct process amongst the multiple processes running on a particular host</li> <li>Port number is 16-bit address used to identify any client-server program uniquely</li> <li>This is similar to data link layer requiring MAC address</li> <li>And network layer requiring IP address</li> </ul>"},{"location":"computer_networks/L4_transport_layer/introduction#workflow","title":"Workflow","text":"<ul> <li>At the sender side</li> <li>Receives the formatted data from the upper layers and performs segmentation</li> <li>Implements flow &amp; error control</li> <li>Adds source and destination port numbers (or service point address) in the headers<ul> <li>This is called service point addressing</li> <li>The destination port number is configured either by default or manually</li> </ul> </li> <li>Forwards the segmented data to the network layer</li> <li>At the receiver side</li> <li>Receives data from the network layer</li> <li>Reads the port number from the header and forwards the data</li> <li>Performs sequencing and reassembling of the segmented data</li> <li>Forwards the message to appropriate port in the application layer</li> </ul>"},{"location":"computer_networks/L4_transport_layer/introduction#services","title":"Services","text":"<ul> <li>Connection-oriented service</li> <li>Three phase process: establish connection, transfer data, disconnect</li> <li>Reliable and secure</li> <li>Receiving device sends an acknowledgement to the source</li> <li>Before delivering the packets<ul> <li>Connection is made with transport layer at the destination</li> </ul> </li> <li>All the packets travel in the single route</li> <li>Connection-less service</li> <li>One phase process: data transfer</li> <li>Receiving device does not acknowledge receipt of a packet</li> <li>Faster communication</li> <li>Each segment is treated as an individual packet</li> <li>Packets travel in different routes to reach the destination</li> </ul>"},{"location":"computer_networks/L4_transport_layer/introduction#multiplexingdemultiplexing","title":"Multiplexing/Demultiplexing","text":"<ul> <li>Multiplexing (many to one) at sender</li> <li>Data is acquired from several processes (or sockets) from the sender<ul> <li>And merged into one packet along with headers</li> <li>And sent as a single packet</li> </ul> </li> <li>Allows simultaneous use of different processes running on a host over a network<ul> <li>The processes are differentiated by their port number</li> </ul> </li> <li>Demultiplexing (one to many) at receiver</li> <li>Header info is used to deliver segments to correct sockets or processes<ul> <li>That are running on the receiver's machine</li> </ul> </li> <li>Host receives IP datagrams<ul> <li>Source IP, destination IP, segment(source port, destination port)</li> </ul> </li> </ul>"},{"location":"computer_networks/L4_transport_layer/introduction#error-and-flow-control","title":"Error and Flow Control","text":"<ul> <li>Checks errors in messages coming from the applcation layer by</li> <li>Using error detection codes</li> <li>Computing checksums</li> <li>Checking if the received data is corrupted</li> <li>Using ACK &amp; NACK services to inform the sender</li> </ul>"},{"location":"computer_networks/L4_transport_layer/introduction#protocols","title":"Protocols","text":"<ul> <li>Stop-and-wait</li> <li>Sliding Window</li> <li>Go-back-N</li> <li>Receiver sends cumulative ack</li> <li>Sender can have up to N unacked packets in pipeline</li> <li>Sender has timer for oldest unacked packet</li> <li>When timer expires, it retransmits all packets starting from the unacked one</li> <li>Selective repeat</li> <li>Receiver sends individual ack</li> <li>Sender has timer for each unacked packet</li> <li>When timer expires, retransmit the unacked packet only</li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol","title":"TCP (Transmission Control Protocol)","text":"<ul> <li>Connection oriented protocol for communication between different devices in a network</li> <li>Sender &amp; receiver are connected till the completion of the process</li> <li>Order of the data is maintained (order remains same before &amp; after the transmission)</li> <li>Establishes and maintains full duplex connection between hosts</li> <li>And generates a virtual circuit between sender &amp; receiver</li> <li>Works with IP that establishes the technique for sending data packets between devices</li> <li>Reliable communication using Positive Acknowledgement with Re-transmission (PAR)</li> <li>Detects errors and retransmits the damaged frames</li> <li>Segments are checked for error detection<ul> <li>Corrupted segment, lost segment management, out of order segment, duplicate segment</li> </ul> </li> <li>Before the transmission is completed<ul> <li>Ensures that all segments are received and acknowledged</li> </ul> </li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#working","title":"Working","text":"<ul> <li>Sender</li> <li>To ensure that each message reaches its target location intact<ul> <li>Data/message is divided into small segments</li> </ul> </li> <li>It keeps track of the segments by assigning sequence number</li> <li>As opposed to sending everything in one go<ul> <li>This makes it simpler to maintain efficiency</li> </ul> </li> <li>Segments may travel through multiple routes and arrive in different order</li> <li>It makes it easier to route segments if one route is jammed</li> <li>Receiver</li> <li>All segments are collected and reordered based on sequence numbers</li> <li>Received segmments are assigned acknowledgement numbers</li> <li>TCP then waits for the transmission to finish<ul> <li>And acknowledges once all packets have been received</li> </ul> </li> <li>Flow control</li> <li>Limits the rate at which a sender transfers data</li> <li>The receiver continually hints on how much data can be received<ul> <li>Using a sliding window</li> </ul> </li> <li>After the user request is received by the server</li> <li>It sends back an HTML page using HTTP</li> <li>HTTP requests TCP layer to set the required connection and send the HTML file</li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#connection-using-3-way-handshake","title":"Connection using 3 way handshake","text":"<ul> <li>Step 1: SYN</li> <li>When a client wants to establish a connection<ul> <li>It sends a segment with SYN (Synchronized Sequence Number)</li> </ul> </li> <li>This informs the server that the client is likely to start communication<ul> <li>And with what sequence number (32-bit number) it starts with</li> </ul> </li> <li>Step 2: SYN + ACK</li> <li>Server responds to the client request with SYN-ACK signal bits set</li> <li>Acknowledgement (ACK) signifies that the response of the segment is received</li> <li>SYN signifies with what sequence number it is likely to start the segments with</li> <li>Step 3: ACK</li> <li>Client acknowledges the response of the server</li> <li>And they both establish a reliable connection<ul> <li>With which they will start the actual data transfer</li> </ul> </li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#tcp-timers","title":"TCP Timers","text":"<ul> <li>TCP uses several timers during communications</li> <li>To ensure that excessive delays are not encountered</li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#retransmission-timer","title":"Retransmission timer","text":"<ul> <li>Retransmission timeout (RTO) is used to retransmit lost segments</li> <li>Starts when TCP sends a segment and stops when the ack is received</li> <li>This is determined using RTT (Round trip time)</li> <li>Measured RTT: Time taken by segment to reach destination &amp; be acknowledged</li> <li>Smoothed RTT: Weighted average of measured RTT</li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#persistent-timer","title":"Persistent timer","text":"<ul> <li>Used to deal with a zero-window-size deadlock situation</li> <li>When TCP receives an ack with window size of zero, it starts a persistence timer</li> <li>When it goes off, TCP sends a special segment called probe</li> <li>Probe contains only 1 byte of data</li> <li>It has a sequence number but it's never acked<ul> <li>Also ignored in calculating sequence nuumber for rest of the data</li> </ul> </li> <li>Probe causes the receiver to resend ack which was lost</li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#keep-alive-timer","title":"Keep alive timer","text":"<ul> <li>Used to prevent a long idle connection between two TCPs</li> <li>Each time the server hears from client, it resets the timer (usually 2 hours)</li> <li>If the server does not hear from the client after timeout, it sends a probe segment</li> <li>If there is no response after 10 probes (75s apart)</li> <li>It assumes that the client is down and terminates the connection</li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#time-wait-timer-or-quiet-timer","title":"Time wait timer or quiet timer","text":"<ul> <li>Used during tcp connection termination</li> <li>Starts after sending the last ack and closing the connnection</li> <li>After connection is closed</li> <li>It is possible for datagrams that are still their way through the network<ul> <li>To attempt to access the closed port</li> </ul> </li> <li>This timer prevents just closed port from reopening again quickly<ul> <li>And receiving these last datagrams</li> </ul> </li> <li>Usually set to twice the maximum segment lifetime</li> <li>Same value as time-to-live field in IP header</li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#connection-termination","title":"Connection Termination","text":"<ul> <li>Supports two types of connection releases</li> <li>Like most connection-oriented transport protocols</li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#graceful-connection-release","title":"Graceful connection release","text":"<ul> <li>Connection is open until both parties have closed their sides of connection</li> <li>Carried out by using the TCP header's FIN (finish) flag</li> <li>Step 1 (FIN from client)</li> <li>Suppose that the client wants to close the connection<ul> <li>Server can also choose to do so</li> </ul> </li> <li>Client sends a segment to server with FIN bit set to 1</li> <li>Client enters into FIN_WAIT_1 state and waits for ack from the server</li> <li>Step 2 (ACK from server)</li> <li>When the server receives FIN bit segment, it immediately sends ack to the client</li> <li>When the client receives the ack, it enters into FIN_WAIT_2 state<ul> <li>And waits for another segment from server with FIN bit set to 1</li> </ul> </li> <li>Step 3 (FIN from server)</li> <li>After some time of sending ack, server sends FIN bit segment to client</li> <li>The time is taken due to some closing process in the server</li> <li>Step 4 (ACK from client)</li> <li>When the client receives FIN bit segment<ul> <li>It sends ack to server and enters into TIME_WAIT state</li> </ul> </li> <li>TIME_WAIT state lets client resend the final ack in case its lost<ul> <li>Typically 30s, 1min, 2min</li> </ul> </li> <li>After the wait, the connection formally closes<ul> <li>And all resources on the client side (port numbers, buffer data) are released</li> </ul> </li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#abrupt-connection-release","title":"Abrupt connection release","text":"<ul> <li>Either an TCP entity is forced to closed the connection</li> <li>Or one user closes both directions of data transfer</li> <li>Carried out when an RST (reset) segment is sent</li> <li>When an non-SYN segement is received for a non-exiting TCP connection</li> <li>When a segment with an invalid header is received in an open connection<ul> <li>Prevents attacks by closing the corresponding connection</li> </ul> </li> <li>When some implementations need to close an existing TCP connection due to<ul> <li>Lack of resources or remote host is unreachable &amp; has stopped responding</li> </ul> </li> <li>RST segement should contain 00 if it does not belong to any existing connection</li> <li>Else it should contain current value of the sequence number</li> <li>And the ack number should be set to the next expected sequence number</li> </ul>"},{"location":"computer_networks/L4_transport_layer/tcp_transmission_control_protocol#wrap-around-concept","title":"Wrap Around Concept","text":"<ul> <li>At high rate of traffic, all the sequence numbers can get used up</li> <li>Sequence number should be unique for each packet</li> <li>Sequence number is of 32 bits (0 to 2^32 - 1 = 4 Giga numbers)</li> <li>Wrap around concept</li> <li>Using the sequence number again and again once all of them get used up</li> <li>In order to maintain the continuity of data transfer</li> <li>Wrap around time</li> <li>Time taken to wrap around<ul> <li>If we start from sequence number n, after how much time is it used again</li> </ul> </li> <li>Depends on the sequence numbers and bandwidth (rate of bits being consumed)</li> <li>It should be at least greater than the life time of a packet<ul> <li>For that time the sequence number will be in use</li> </ul> </li> <li>Wrap around time = Count of sequence numbers / Bandwidth<ul> <li>For 1 GBps = 2^32 numbers / 10^9 = 4.3 seconds</li> </ul> </li> </ul>"},{"location":"computer_networks/L4_transport_layer/udp_user_datagram_protocol","title":"UDP (User Datagram Protocol)","text":"<ul> <li>Unreliable and connectionless protocol unlike TCP</li> <li>No need to establish connection before data transfer</li> <li>No congestion control, no flow control</li> <li>TCP is the dominant transport layer protocol</li> <li>That provides delivery &amp; reliability but costs additional overhead &amp; latency</li> <li>For real-time services like computer gaming, voice or video communication, live conferences</li> <li>High performance is required</li> <li>UDP permits packets to be dropped instead of processing delayed packets</li> <li>There is no error checking which also saves bandwidth</li> <li>Smaller packets than TCP</li> <li>Also used by DNS, DHCP, VoIP (Voice over Internet Protocol)</li> <li>Takes datagram from network layer</li> <li>Attaches its header and sends it to user, so it works fast</li> </ul>"},{"location":"computer_networks/L4_transport_layer/congestion_control","title":"Congestion Control","text":"<ul> <li>Congestion is a situation when too many sources attempt to send data</li> <li>And the router buffer starts overflowing</li> <li>Due to which packets are lost</li> <li>Retransmission of packets from the sources increases the congestion further</li> </ul>"},{"location":"computer_networks/L4_transport_layer/congestion_control#policy","title":"Policy","text":""},{"location":"computer_networks/L4_transport_layer/congestion_control#slow-start-phase","title":"Slow Start Phase","text":"<ul> <li>After every RTT, the congestion window size increments exponentially</li> <li>If congestion window is 1 segment &amp; first segment is acked, window becomes 2 segments</li> <li>If next transmission of 2 segments is also acked, it doubles to 4, then 8, and so on</li> </ul>"},{"location":"computer_networks/L4_transport_layer/congestion_control#congestion-avoidance-phase","title":"Congestion Avoidance Phase","text":"<ul> <li>After the threshold value, the congestion window increases additive</li> <li>If congestion window is 20 segments</li> <li>And all segments are acked within RTT, it increases to 21 segments</li> <li>If the next transmission is also acked, it increases to 22, and so on</li> </ul>"},{"location":"computer_networks/L4_transport_layer/congestion_control#congestion-detection-phase","title":"Congestion Detection Phase","text":"<ul> <li>If congestion occurs, the congestion window size is decreased multiplicative</li> <li>The only way a sender can guess that congestion has happened is the need to retransmit</li> <li>Retransmission can occur when</li> <li>RTO timer times out<ul> <li>Congestion possibility is high</li> <li>Threshold is reduced to half of the current window size</li> <li>Congestion window is set to 1</li> <li>Slow start phase is started again</li> </ul> </li> <li>Three duplicate ACKs are received<ul> <li>Congestion possibility is less</li> <li>Threshold is reduced to half of the current window size</li> <li>Congestion window is set equal to threshold</li> <li>Congestion avoidance phase is started again</li> </ul> </li> </ul>"},{"location":"computer_networks/L4_transport_layer/congestion_control#algorithms","title":"Algorithms","text":"<ul> <li>These two algorithms are used for traffic shaping</li> <li>That is, control the amount &amp; rate of traffic sent to network</li> </ul>"},{"location":"computer_networks/L4_transport_layer/congestion_control#leaky-bucket-algorithm","title":"Leaky Bucket Algorithm","text":"<ul> <li>Controls the rate at which traffic is sent to the network</li> <li>And shape the burst traffic to a steady traffic stream</li> <li>Each network contains a leaky bucket</li> <li>When host wants to send packet, the packet is thrown into the bucket</li> <li>The bucket leaks (transmits packets) at a constant rate</li> <li>Bursty traffic is converted to uniform traffic</li> </ul>"},{"location":"computer_networks/L4_transport_layer/congestion_control#token-bucket-algorithm","title":"Token Bucket Algorithm","text":"<ul> <li>When large bursts arrive, the leaky bucket algorithm can lose packets</li> <li>This can happen if rate of traffic &gt; rate of transmission of leaky bucket</li> <li>Since leaky bucket converts traffic to uniform traffic (fixed rate)</li> <li>Bucket contains tokens which define a packet of predetermined size</li> <li>Tokens in the bucket are deleted for the ability to share a packet</li> <li>No token means no flow sends its packets</li> <li>Tokens are generated at a fixed rate</li> <li>If there is no traffic, accumulated tokens could result in wasted resources</li> </ul>"},{"location":"computer_networks/L4_transport_layer/congestion_control#open-loop-techniques","title":"Open Loop Techniques","text":"<ul> <li>Applied to prevent congestion before it happens</li> <li>Retransmission Policy</li> <li>Packets are retransmitted if a sent packet is lost or corrupted</li> <li>To prevent congestion, retransmission timers must be designed efficiently</li> <li>Window Policy</li> <li>Several packets in go-back-n window are resent<ul> <li>Although some of these packets may have been received successfully</li> </ul> </li> <li>This duplication may increase the congestion</li> <li>Selective repeat window should be adopted<ul> <li>As it sends only the specific lost packets</li> </ul> </li> <li>Discarding Policy</li> <li>Routers can discard less sensitive or corrupted packages to prevent congestion</li> <li>Acknowledgement Policy</li> <li>The receiver can send cumulative ack for n packets rather than single acks</li> <li>It should send an ack only if it has to send a packet or timer expires</li> <li>Admission Policy</li> <li>Switches in a flow should first check the resource requirement<ul> <li>Of the network flow before transmitting it further</li> </ul> </li> <li>If there is a chance of congestion<ul> <li>It should deny establishing a virtual network connection</li> </ul> </li> </ul>"},{"location":"computer_networks/L4_transport_layer/congestion_control#closed-loop-techniques","title":"Closed Loop Techniques","text":"<ul> <li>Used to alleviate congestion after it happens</li> <li>Backpressure</li> <li>Node to node congestion control that propogates in the opposite direction of data flow</li> <li>The congested node stops receiving packets from upstream node</li> <li>This may cause upstream node to become congested and reject data from above nodes</li> <li>Can be applied only to virtual circuit<ul> <li>Where each node has info of its above upstream node</li> </ul> </li> <li>Choke Packet</li> <li>Packet sent by a node to the source to inform about congestion</li> <li>Applicable to both virtual network and datagram subnets</li> <li>Each router monitors its resources and utilization at each of its output lines</li> <li>Whenever the resource utilization exceeds the threshold value set by administrator<ul> <li>The router directly sends a choke packet to the source</li> <li>Giving the source feedback to reduce the traffic</li> </ul> </li> <li>The intermediate nodes through which the packet has travelled<ul> <li>Are not warned about congestion</li> </ul> </li> <li>Implicit Signaling</li> <li>There is no communication between the congested nodes and the source</li> <li>The source guesses the congestion (e.g. not receiving acks for several packets)</li> <li>Explicit Signaling</li> <li>Node experiencing congestion explicitely sends a packet<ul> <li>To source or destination to inform about the congestion</li> </ul> </li> <li>Difference from the choke packet<ul> <li>The signal is included in the packets that carry data</li> <li>Rather than creating a different packet (choke packet)</li> </ul> </li> <li>Forward signaling: in the direction of congestion (destination is warned)</li> <li>Backward signaling: in the opposite direction of congestion (source is warned)</li> </ul>"},{"location":"computer_networks/L5_session_layer","title":"L5 Session Layer","text":"<ul> <li>Introduction</li> </ul>"},{"location":"computer_networks/L5_session_layer/introduction","title":"Introduction","text":"<ul> <li>Basic info</li> <li>Packet: Data</li> <li>Protocols: NetBIOS, PPTP, SSL, API</li> <li>Platforms: OS, Gateways, Firewalls</li> <li>Features</li> <li>Establishment of connection</li> <li>Maintenance &amp; termination of sessions</li> <li>Ensuring security and managing authentication</li> <li>Allows a process to add checkpoints or synchronization points in the data</li> <li>Which help to identify errors and avoid data loss</li> <li>Allows systems to start communication in half-duplex or full-duplex mode</li> </ul>"},{"location":"computer_networks/L6_presentation_layer","title":"L6 Presentation Layer","text":"<ul> <li>Introduction</li> </ul>"},{"location":"computer_networks/L6_presentation_layer/introduction","title":"Introduction","text":"<ul> <li>Basic info</li> <li>Packet: Data</li> <li>Protocols: SSL, SSH, IMAP</li> <li>Platforms: OS, Gateways, Firewalls</li> <li>Features</li> <li>Data from application layer is extracted and manipulated to transmit over a network</li> <li>Concerned with syntax &amp; semantics</li> <li>Translation, Compression, Encryption/Descryption</li> </ul>"},{"location":"computer_networks/L7_application_layer","title":"L7 Application Layer","text":"<ul> <li>Introduction</li> <li>HTTP (HyperText Transfer Protocol)</li> <li>ATM (Asynchronous Transfer Mode)</li> <li>SMTP (Simple Mail Transfer Protocol)</li> <li>FTP (File Transfer Protocol)</li> <li>SSH (Secure Shell)</li> <li>DNS (Domain Name System)</li> <li>DHCP (Dynamic Host Configuration Protocol)</li> </ul>"},{"location":"computer_networks/L7_application_layer/introduction","title":"Introduction","text":"<ul> <li>Basic info</li> <li>Packet: Data</li> <li>Protocols: HTTP, DHCP, FTP, SSH, SMTP, DNS</li> <li>Platforms: Network applications, Browser, Messenger, Gateways, Firewalls</li> <li>Features</li> <li>Data produced by applications which needs to be transferred over the network</li> <li>Provides services to the user like file transfer, mail services, etc.</li> <li>Window for users and applications to access network services</li> <li>Network transparency, resource allocation</li> <li>Also called Desktop Layer</li> <li>Addressing</li> <li>Socket: Process sends/receive message to/from its socket</li> <li>Functions</li> <li>DNS (Domain Name System): Host Name to IP mapping</li> <li>File transfer, access and management</li> <li>Mail services</li> <li>Directory services: distributed database sources</li> </ul>"},{"location":"computer_networks/L7_application_layer/introduction#ntp-network-time-protocol","title":"NTP (Network Time Protocol)","text":"<ul> <li>Helps computer clock times to be synchronized in a network</li> <li>Uses UTC to synchronize CPU clock time</li> <li>Provides consistent timekeeping for file servers</li> <li>Hierarchical system of time resources</li> <li>At the topmost level, there are highly accurate time resources<ul> <li>Atomic or GPS clocks</li> </ul> </li> <li>These servers (stratum 0) are linked to the servers below<ul> <li>Stratum 1, 2, 3 &amp; so on</li> </ul> </li> </ul>"},{"location":"computer_networks/L7_application_layer/introduction#quality-of-service-qos","title":"Quality of Service (QoS)","text":"<ul> <li>Traffic control mechanisms</li> <li>That differentiate performance based on application or network operator requirements</li> <li>Or provide predictable or guaranteed performance<ul> <li>To applications, sessions, traffic aggregates</li> </ul> </li> <li>Basic phenomenon is in terms of packet delay and losses of various kinds</li> <li>Used for time critical applications in which bounded delay is an important factor</li> <li>Video &amp; audio conferencing or streaming requires bounded delay and loss rate</li> </ul>"},{"location":"computer_networks/L7_application_layer/introduction#types","title":"Types","text":"<ul> <li>Stateless solutions</li> <li>Routers maintain no fine-grained state about traffic</li> <li>Scalabe and robust<ul> <li>But no guarantee about the kind of delay or performance in a particular application</li> </ul> </li> <li>Stateful solutions</li> <li>Routers maintain per-flow state</li> <li>Much less scalable &amp; robust<ul> <li>But guaranteed services and high resource utilization</li> </ul> </li> </ul>"},{"location":"computer_networks/L7_application_layer/introduction#web-caching","title":"Web Caching","text":"<ul> <li>Substantially reduces response time and traffic for repeated requests</li> <li>Done by proxy server (intermediate entity between the original server &amp; client)</li> <li>If a request is cached<ul> <li>Proxy server forwards the cached result directly to the client</li> </ul> </li> <li>Otherwise it queries on behalf of the host<ul> <li>Caches it and forwards the result back to the host</li> </ul> </li> <li>Usually installed by ISP, universities, corporate offices</li> <li>What if the content was modified on the original server</li> <li>Conditional GET is used<ul> <li>Which queries the original server to get the last modified since</li> </ul> </li> <li>The original server returns the data<ul> <li>Only if the validator for last modified since passes</li> </ul> </li> <li>If the content was modified, it updates the cache and forwards to the client</li> </ul>"},{"location":"computer_networks/L7_application_layer/http_hypertext_transfer_protocol","title":"HTTP (HyperText Transfer Protocol)","text":"<ul> <li>Communication protocol used to deliver data between a client and a server</li> <li>Data such as text, images, and other multimedia files are shared on WWW</li> <li>Uses hypertext pages that can be interlinked with each other to form web pages<ul> <li>HTML is used to generate these pages</li> <li>HTTP protocol transfers the hypertext pages from web server to web browser</li> </ul> </li> <li>Methods HTTP/1.1: GET, POST, HEAD, PUT, DELETE</li> <li>Status Code:</li> <li>200: OK</li> <li>301: Moved Permanently</li> <li>400: Bad Request</li> <li>404: Not Found</li> <li>505: HTTP version not supported</li> </ul>"},{"location":"computer_networks/L7_application_layer/http_hypertext_transfer_protocol#details","title":"Details","text":"<ul> <li>Connectionless protocol</li> <li>After the connection is closed<ul> <li>The client and the server don't remember anything about each other</li> </ul> </li> <li>Stateless protocol</li> <li>Server maintains no information about past client requests</li> <li>Each transaction on the protocol is carried out independently of the others<ul> <li>Without reference to the history</li> </ul> </li> <li>After the transaction is finished<ul> <li>The connection between the browser and the server ends</li> </ul> </li> <li>Client-server model that uses TCP</li> <li>Client initiates TCP connection (creates socket) to server, port 80</li> <li>Server accepts connection, notifying client</li> <li>HTTP messages are exchanged between browser (client) and web server</li> </ul>"},{"location":"computer_networks/L7_application_layer/http_hypertext_transfer_protocol#https-http-secure","title":"HTTPS (HTTP Secure)","text":"<ul> <li>Combination of HTTP with SSL/TLS convention to supply encrypted communication</li> <li>And secure distinguishing proof of an arranged web server</li> <li>Encrypts all message substance including HTTP headers and the request/reponse data</li> <li>Requires a trusted third party to sign server side digital certificate</li> </ul>"},{"location":"computer_networks/L7_application_layer/http_hypertext_transfer_protocol#types","title":"Types","text":""},{"location":"computer_networks/L7_application_layer/http_hypertext_transfer_protocol#non-persistent","title":"Non-persistent","text":"<ul> <li>Each object requires a new TCP connection for transmission</li> <li>With parallel connection for multiple objects</li> <li>Requires extra overhead to transfer data</li> <li>Without parallel connection</li> <li>Requires 2 RTTs (Round Trip Time) per object</li> <li>Response time per object = 1 RTT for connection + 1 RTT for file transmission</li> <li>Connection is opened &amp; closed each time</li> <li>Which is more secure &amp; does not waste resources</li> <li>But results in an extra overhead and slow speed</li> </ul>"},{"location":"computer_networks/L7_application_layer/http_hypertext_transfer_protocol#persistent","title":"Persistent","text":"<ul> <li>Multiple objects over one TCP connection</li> <li>After a connection is established that takes 1 RTT</li> <li>Multiple objects can be sent over the same network that takes 1 RTT</li> <li>Response time per object = 1 RTT (File transmission time)</li> <li>Types</li> <li>Non-pipelined: Another request can be sent only if previous request is acked</li> <li>Pipelined: Another request can be sent even if previous request is not acked</li> <li>Connection remains open</li> <li>Which is less secure &amp; wastes network resources</li> <li>But removes the extra overhead of connection establishment and is fast</li> </ul>"},{"location":"computer_networks/L7_application_layer/http_hypertext_transfer_protocol#cookies","title":"Cookies","text":"<ul> <li>Since HTTP is stateless protocol</li> <li>Cookies help to keep state &amp; give customized experience to user</li> <li>Uses: authorization, shopping carts, recommendations, user session state</li> <li>Servers can take swift action using cookies even one week later</li> </ul>"},{"location":"computer_networks/L7_application_layer/http_hypertext_transfer_protocol#conditional-requests","title":"Conditional Requests","text":"<ul> <li>Similar to the standard HTTP requests</li> <li>But are only fulfilled by the server if the specified validators pass</li> <li>Useful to validate content of a cache, verify integrity of a document</li> </ul>"},{"location":"computer_networks/L7_application_layer/atm_asynchonous_transfer_mode","title":"Aysnchronous Transfer Mode (ATM)","text":"<ul> <li>Telecommunications standard for digital transmission of multiple types of traffic</li> <li>Can handle both<ul> <li>Traditional high throughput data</li> <li>And real-time low latency content</li> </ul> </li> <li>Can handle both constant and variable rate traffic</li> <li>Transmits all information over connection-oriented network<ul> <li>Including data, video, voice</li> </ul> </li> <li>Was developed to meet the needs of Broadband ISDN</li> <li>And is a core protocol used in SONET</li> </ul>"},{"location":"computer_networks/L7_application_layer/atm_asynchonous_transfer_mode#details","title":"Details","text":"<ul> <li>Uses small fixed-size packets called cells which are transmitted asynchonously</li> <li>In contrast, IP packets are of variable size</li> <li>Independent of transmission medium</li> <li>Uses virtual circuit switching (path is reserved before transmission)</li> <li>Working</li> <li>Uses Virtual path connections (VPC)<ul> <li>That consist of virtual channel connections (VCC) bundled together</li> </ul> </li> <li>VCC is a basic unit carrying a single stream of cells from user to user</li> <li>Making an ATM call</li> <li>First sends a message to set up a connection</li> <li>Subsequently, all cells follow the same path to the destination</li> <li>Addressing</li> <li>20-byte global NSAP (Network Service Access Point) address for signaling</li> <li>32-bit locally assigned labels in cells</li> </ul>"},{"location":"computer_networks/L7_application_layer/atm_asynchonous_transfer_mode#layers","title":"Layers","text":"<ul> <li>ATM Adaption Layer (AAL)</li> <li>Isolates higher layer protocols from details of ATM processes</li> <li>Prepares for conversion of user data into cells</li> <li>Physical Layer</li> <li>Controls transmission and receipt of bits in physical medium</li> <li>Converts cells to bitstream and tracks ATM cell boundaries</li> <li>ATM Layer</li> <li>Handles transmission, switching, congestion control<ul> <li>Cell header processing, sequential delivery</li> </ul> </li> <li>Cell multiplexing: Simultaneous sharing of virtual circuits over physical link</li> <li>Call relay<ul> <li>Passing cells through an ATM network</li> <li>Making use of VPI &amp; VCI info in cell header</li> </ul> </li> </ul>"},{"location":"computer_networks/L7_application_layer/smtp_simple_mail_transfer_protocol","title":"SMTP (Simple Mail Transfer Protocol)","text":"<ul> <li>SMTP is a push protocol used to send emails</li> <li>POP/IMAP are used to retrieve emails</li> <li>POP (Post Office Protocol)</li> <li>IMAP (Internet Message Access Protocol)</li> <li>Types</li> <li>End-to-end: Used to communicate between different organizations</li> <li>Store-and-forward: Used within an organization</li> </ul>"},{"location":"computer_networks/L7_application_layer/smtp_simple_mail_transfer_protocol#working","title":"Working","text":"<ul> <li>Sender opens a TCP connection to the SMTP server</li> <li>SMTP server is always on listening mode, it listens &amp; establishes the TCP connection</li> <li>Sender sends the mail over the connection</li> <li>SMTP server keeps the mail to itself until it is successfully delivered</li> </ul>"},{"location":"computer_networks/L7_application_layer/smtp_simple_mail_transfer_protocol#components","title":"Components","text":"<ul> <li>Sender's user agent prepares a message and sends it to the Mail Transfer Agent (MTA)</li> <li>MTA maintains a small queue</li> <li>To schedule repeat delivery of mail in case receiver is not available</li> <li>MTA transfers the mail across the network to the receiver's MTA</li> <li>The user agent on the server side checks the mailboxes at regular intervals</li> <li>If any information is received, it informs the user about the mail</li> </ul>"},{"location":"computer_networks/L7_application_layer/smtp_simple_mail_transfer_protocol#mime-multipurpose-internet-mail-extension","title":"MIME (Multipurpose Internet Mail Extension)","text":"<ul> <li>Supplementary protocol that allows non-ASCII data to be sent through SMTP</li> <li>Allows users to exchange data like audio, video, images, application programs</li> <li>Enables to use HTML and CSS in emails to customize and beautify them</li> <li>Allows using different languages like Hindi, French, Japanese, etc</li> <li>Working</li> <li>SMTP has a simple structure and sends message only in NVT 7-bit ASCII format</li> <li>MIME transforms non-ASCII data to NVT 7-bit ASCII data at the sender side</li> <li>And delivers to the client SMTP where the inversion happens</li> <li>MIME header is added to the email to define transformation and content info</li> </ul>"},{"location":"computer_networks/L7_application_layer/ftp_file_transfer_protocol","title":"File Transfer Protocol","text":"<ul> <li>Moves files between local and remote file systems</li> <li>Shields users from system differences like OS, directory structure, character sets</li> <li>Can transfer these categories of data</li> <li>ASCII &amp; EBCDIC</li> <li>Image<ul> <li>File has no formal internal structure</li> <li>Transferred one byte at a time without any processing</li> </ul> </li> <li>Local: File containing data in logical bytes</li> </ul>"},{"location":"computer_networks/L7_application_layer/ftp_file_transfer_protocol#working","title":"Working","text":"<ul> <li>Two TCP connections are used in parallel</li> <li>It sends control info in separate connection, so it's called out-of-band</li> <li>Protocols like HTTP &amp; SMTP that send it in same connection are called in-band</li> </ul>"},{"location":"computer_networks/L7_application_layer/ftp_file_transfer_protocol#control-connection","title":"Control connection","text":"<ul> <li>Initiated by client to send info like user identification, password</li> <li>Commands to change the remote directory</li> <li>Commands to retrieve &amp; store files</li> <li>Initiated on port number 21</li> <li>Persistent &amp; stateful connection</li> <li>Remains active throughout the session to maintain a state about user</li> </ul>"},{"location":"computer_networks/L7_application_layer/ftp_file_transfer_protocol#data-connection","title":"Data connection","text":"<ul> <li>Initiated by server after control info has been sent by client</li> <li>To send the actual file</li> <li>Initiated on port number 20</li> <li>Non persistent &amp; stateless connection</li> </ul>"},{"location":"computer_networks/L7_application_layer/ssh_secure_shell","title":"SSH (Secure Shell)","text":"<ul> <li>Cryptographic network protocol used to transfer encrypted data over a network</li> <li>Allows you to connect to a server without having to enter password for each system</li> <li>The port number of SSH is 22</li> <li>Features: Encryption, authentication, tunneling</li> <li>Comes in key pairs</li> <li>Public key: For encryption function, everyone can see it, no need to protect</li> <li>Private key: For decryption function, stays in computer, must be protected</li> <li>Types of key pairs</li> <li>User key: If public &amp; private key remain with the user</li> <li>Host key: If public &amp; private key are on a remote system</li> <li>Session key: Used when a large amount of data is to be transmitted</li> </ul>"},{"location":"computer_networks/L7_application_layer/ssh_secure_shell#working","title":"Working","text":"<ul> <li>Public keys from the local system are passed to the server</li> <li>The server identifies if the public key is registered</li> <li>If so, the server creates a new secret key</li> <li>And encrypts it with the public key</li> <li>The encrypted code is sent to the local system</li> <li>The data is unlocked by the private key of the system</li> <li>And is sent to the server</li> <li>The server after receiving this data verifies the local system</li> <li>SSH creates a route</li> <li>And all the encrypted data are transferred through it with no security issue</li> </ul>"},{"location":"computer_networks/L7_application_layer/dns_domain_system_name","title":"Domain Name System (DNS)","text":"<ul> <li>Distributed database implemented in a heirarchy of name servers</li> <li>Every host is identified by its IP address</li> <li>But managing numbers is very difficult since there are millions of websites</li> <li>Also IP addreesses are not static, they can change</li> <li>So domain names are used instead and are converted to their IP address by DNS</li> <li>Uses UDP because</li> <li>UDP is much faster than TCP which uses 3 way handshake end-to-end connection</li> <li>DNS servers don't have to keep connections</li> <li>DNS requests are generally very small and fit well within UDP segments</li> <li>Reliability can be increased at application layer by using timeout &amp; resend</li> </ul>"},{"location":"computer_networks/L7_application_layer/dns_domain_system_name#dns-lookup","title":"DNS Lookup","text":"<ul> <li>Client sends a request to a DNS resolver to resolve a domain name</li> <li>If not found, it can</li> <li>Send request to other or high level servers (recursive lookup)</li> <li>Or it can refer the resolver to other servers (iterative lookup)</li> <li>This process keeps repeating at each level till the DNS is resolved</li> <li>Once found, the results are cached based on the frequency or other factors</li> <li>Servers in order of lookup</li> <li>Local name server</li> <li>Root name server</li> <li>Top level domain (TLD)<ul> <li>Manages entries for domains like com, org, edu, uk, fr, ca, in</li> </ul> </li> <li>Authoritative name server: Maintained by organization or service provider</li> </ul>"},{"location":"computer_networks/L7_application_layer/dhcp_dynamic_host_configuration_protocol","title":"Dynamic Host Configuration Protocol (DHCP)","text":"<ul> <li>Helps enterprises to smoothly manage the allocation of IP addresses to the client devices</li> <li>Maintains information on TCP/IP configuration</li> <li>IP addresses are assigned using DORA messages</li> <li>Discover, Offer, Request, Acknowledgements</li> <li>But if hosts have no IP address initially how they form IP packets to assign the address</li> <li>It uses two reserved IP addresses for this purpose</li> <li>0.0.0.0<ul> <li>Reserved to use as sender's address for hosts</li> <li>That doesn't have IP address assigned yet</li> </ul> </li> <li>255.255.255.255<ul> <li>Local broadcast address</li> <li>Routers don't forward packet containing this address as destination addresss</li> <li>DNS broadcasts packages to the client host</li> <li>Switch takes care of the broadcasting</li> </ul> </li> </ul>"},{"location":"computer_networks/L7_application_layer/dhcp_dynamic_host_configuration_protocol#working-dora-process","title":"Working (DORA Process)","text":"<ul> <li>Discover message</li> <li>Client generates a DHCP discover message</li> <li>And broadcasts to all devices to find the DHCP server</li> <li>Offer message</li> <li>Server responds to the client by specifying IP address<ul> <li>And other TCP configuration information</li> </ul> </li> <li>This offer message is broadcasted by the DHCP server and includes the server id</li> <li>If there are multiple DHCP servers in the network<ul> <li>The client will accept the first DHCP offer message</li> </ul> </li> <li>Request message</li> <li>After receiving the offer message<ul> <li>Client responds by broadcasting a DHCP request message</li> </ul> </li> <li>It produces a gratuitous ARP<ul> <li>To find if there is any other host in the network with the same IP address</li> </ul> </li> <li>If there is no reply from another host<ul> <li>The message is broadcasted to the server showing acceptance of the IP address</li> </ul> </li> <li>A client id is also added to this message</li> <li>Acknowledgement message</li> <li>In response to the request message received<ul> <li>Server will make an entry with the specified client ID</li> <li>And bind the IP address offered with lease time</li> </ul> </li> </ul>"},{"location":"computer_networks/L7_application_layer/dhcp_dynamic_host_configuration_protocol#other-messages","title":"Other Messages","text":"<ul> <li>Negative acknowledgement message</li> <li>If the request for IP address is invalid according to the configured scopes<ul> <li>It sends NAK message to the client</li> <li>For example, when there is no IP address left in the pool</li> </ul> </li> <li>Decline message</li> <li>If the offered configuration parameters are invalid<ul> <li>The client sends a decline message to the server</li> <li>For example, when there is a reply to the gratuitous ARP by any host to the client</li> </ul> </li> <li>Release message</li> <li>Client sends a release packet to the server<ul> <li>To release the IP address and cancel any remaining lease time</li> </ul> </li> <li>Inform message</li> <li>If the client has obtained the IP address manually<ul> <li>Then it uses inform meessage</li> <li>To obtain other local configuration parameters like domain name</li> </ul> </li> <li>In response to this, the server unicasts an ack message to the client with the info</li> </ul>"},{"location":"computer_networks/L7_application_layer/dhcp_dynamic_host_configuration_protocol#relay-agent","title":"Relay Agent","text":"<ul> <li>DHCP relay agent is any TCP/IP host</li> <li>Which is used to forward requests and replies between the DHCP server and client</li> <li>Listens for DHCP broadcast messages from client devices<ul> <li>And forwards them to DHCP server encapsulating them in a unicast packet</li> </ul> </li> <li>The discover and request messages are unicast to DHCP server by the relay agent</li> <li>It is required when the server is present on a different network</li> <li>Commonly used in large enterprise networks that have different network segments</li> <li>Adds a gateway address of the packet (giaddr) field to packets</li> <li>Used to indicate IP address of the relay agent interface<ul> <li>On which the message was received</li> </ul> </li> <li>To add additional info like interface or port number<ul> <li>Relay agent information option 82 can be used</li> </ul> </li> <li>Can be implemented in dedicated hardware devices</li> <li>Or in software on routers or other devices</li> </ul>"},{"location":"database_system","title":"Database Management System","text":"<ul> <li>Introduction</li> <li>Entity Relationship Model</li> <li>Relational Model</li> <li>Functional Dependency</li> <li>Normalization</li> <li>Transactions and Schedules</li> <li>Concurrency Control</li> <li>Concurrency Control Protocols</li> <li>Recoverability and Processing</li> <li>Indexing</li> <li>File Organization</li> </ul>"},{"location":"database_system/introduction","title":"Introduction","text":"<ul> <li>Data: Collection of units of information</li> <li>Database: Organized collection of data that can be easily managed</li> <li>Database Management System</li> <li>Software system designed to enable users to store, organize &amp; manage a database</li> <li>Manages security and access control</li> <li>Scalability: Handles large amounts of data</li> </ul>"},{"location":"database_system/introduction#drawbacks-of-file-system","title":"Drawbacks of File System","text":"<ul> <li>Redundancy: If some data needs to be updated, it takes a lot of effort</li> <li>Inconsistency</li> <li>For the same information, there can be different data at different places</li> <li>Data access</li> <li>To access a particular info, user should already know the file<ul> <li>The file that the info is stored in and its location</li> </ul> </li> <li>Unauthorised access: Anyone can access and update the data in unauthorized way</li> <li>No backup &amp; recovery</li> </ul>"},{"location":"database_system/introduction#key-features","title":"Key features","text":"<ul> <li>Data modeling: Data models define the structure &amp; relationships of the data</li> <li>Data storage &amp; retrieval: Create, modify, query data</li> <li>Concurrency control</li> <li>Allow multiple users to access data without conflicting with each other</li> <li>Data integrity &amp; security</li> <li>Constraints on the values of data and access control to restrict users</li> <li>Backup &amp; recorvery</li> <li>Multiple data views: Same data can be represented in different ways</li> <li>Analytics &amp; reporting</li> </ul>"},{"location":"database_system/introduction#types","title":"Types","text":"<ul> <li>Relational DBMS: SQL</li> <li>The data is organized in the form of tables, and tables in rows &amp; columns</li> <li>The data is related to each other through primary &amp; foreign keys</li> <li>Non-Relational DBMS: NoSQL</li> <li>The data is organized in the form of key-value pairs, documents, graphs, or columns</li> <li>Designed to handle large scale, high performance scenarios</li> </ul>"},{"location":"database_system/introduction#components","title":"Components","text":""},{"location":"database_system/introduction#database-object","title":"Database Object","text":"<ul> <li>Any defined object in database used to store, reference, hold or manipulate data</li> <li>Table: Basic unit of storage composed of rows &amp; columns</li> <li>View: Logically represented subset of data from one or more tables</li> <li>Index: Improves performance of fetching data</li> <li>Sequence: Generates primary key values</li> <li>Synonym: Alternative name for an object</li> </ul>"},{"location":"database_system/introduction#database-languages","title":"Database Languages","text":"<ul> <li>Data Definition Language (DDL)</li> <li>Deals with schemas and descriptions about how the data should reside in the database</li> <li>Create, Alter, Drop, Truncate (remove all records from table), Rename</li> <li>Data Manipulation Language (DML)</li> <li>Used to store, modify, retrieve, delete and update data</li> <li>Select, Insert, Update, Delete</li> <li>Data Control Lanuage (DCL)</li> <li>Access specifier to grant and revoke permissions to users</li> <li>Grant, Revoke</li> <li>Transaction Control Language (TCL)</li> <li>Manager for all transactional data and transaction</li> <li>Rollback, Commit, Savepoint (Save data temporarily)</li> </ul>"},{"location":"database_system/introduction#three-layer-architecture","title":"Three Layer Architecture","text":"<ul> <li>Physical or Internal Layer</li> <li>Keeps info about the location of database objects in data store</li> <li>Describes how the data is being stored in secondary storage</li> <li>Conceptual or Logical Layer</li> <li>Data is represented in the form of tables and relations</li> <li>Describes what kind of data is to be stored (schema)</li> <li>External or View Layer</li> <li>View of data in terms of conceptual level tables</li> <li>Users can view data in form of rows &amp; columns</li> <li>Different views can be generated for different users</li> </ul>"},{"location":"database_system/introduction#data-independence","title":"Data Independence","text":"<ul> <li>Change of data at one level should not affect another level</li> <li>Physical data independence</li> <li>Change in physical location of tables &amp; indexes<ul> <li>Should not affect conceptual or external level</li> </ul> </li> <li>The changes can be<ul> <li>Using new storage devices</li> <li>Modifying data structures used for storage or altering indexes</li> <li>Using alternative file organization techniques</li> </ul> </li> <li>Conceptual data independence</li> <li>Adding or deleting attributes in a table should not affect the user's view of table</li> <li>Other changes can be altering table structures or relationships</li> <li>Difficult to achieve compared to physical data independence</li> </ul>"},{"location":"database_system/introduction#multimedia-database","title":"Multimedia Database","text":"<ul> <li>Stores documents, graphics, images, animations, video, audio, etc</li> <li>Types of media: Static media, dynamic media, dimensional media</li> </ul>"},{"location":"database_system/introduction#contents","title":"Contents","text":"<ul> <li>Media data: Actual data representing an object</li> <li>Format data</li> <li>Information about the format of media data<ul> <li>Like sampling rate, resolution, encoding scheme</li> </ul> </li> <li>After it goes through acquisition, processing &amp; encoding phase</li> <li>Keyword data</li> <li>Keyword description related to the generation of data like date, time, place</li> <li>Feature data</li> <li>Content dependent data</li> <li>Like distribution of colors, kinds of texture, different shapes present in data</li> </ul>"},{"location":"database_system/introduction#types-based-on-data-management","title":"Types based on data management","text":"<ul> <li>Repository applications</li> <li>Data &amp; metadata stored for retrieval purpose<ul> <li>Like format, date, keyword data, feature data</li> </ul> </li> <li>Examples<ul> <li>Repository of satellite images, engineering drawings, radiology scanned pictures</li> </ul> </li> <li>Presentation applications</li> <li>Delivery of multimedia data subject to temporal constraint<ul> <li>Optimal viewing or listening requires delivering data at certain rate</li> <li>Data is processed as it is delivered</li> </ul> </li> <li>Offers quality of service above certain threshold</li> <li>Example: Annotating video &amp; audio data, real time editing analysis</li> <li>Colloborative applications</li> <li>Executing complex task by merging drawings, changing notifications</li> <li>Example: Intelligent healthcare network</li> </ul>"},{"location":"database_system/introduction#challenges","title":"Challenges","text":"<ul> <li>Modelling &amp; design</li> <li>There can be performance &amp; tuning issues<ul> <li>In external, conceptual &amp; physical design layers</li> </ul> </li> <li>Designing can be complex due to various formats like jpeg, gif, png, mpeg</li> <li>These formats are not easy to convert from one form to another</li> <li>Storage</li> <li>Challenge of representation, compression, archiving, buffering<ul> <li>And mapping device hierarchies</li> </ul> </li> <li>BLOB (Binary Large Object) facility allows untyped bitmaps to be stored and retrieved</li> <li>Performance</li> <li>Physical limitations in video playback or audio-video synchronization</li> <li>Parallel processing may alleviate some problems<ul> <li>But such techniques are not fully developed</li> </ul> </li> <li>Multimedia database consumes a lot of processing time and bandwidth</li> <li>Queries &amp; retrieval</li> <li>Accessing data for multimedia through query have many issues</li> <li>Query formulation, query execution and optimization needs to be worked upon</li> </ul>"},{"location":"database_system/entity_relationship_model","title":"Entity Relationship Model","text":"<ul> <li>Representation of entities and their relationships</li> </ul>"},{"location":"database_system/entity_relationship_model#representations","title":"Representations","text":"<ul> <li>Entity</li> <li>Strong: Rectange</li> <li>Weak: Double Rectangle</li> <li>Entity Set: Vertical Oval</li> <li>Attribute</li> <li>Single-valued: Oval</li> <li>Key: Oval with Underline</li> <li>Multi-valued: Double Oval</li> <li>Derived: Dashed Oval</li> <li>Relationship: Diamond</li> <li>Identifying Relationship: Double Diamond</li> <li>Participation<ul> <li>Total: Double Line</li> <li>Partial: Line</li> </ul> </li> </ul>"},{"location":"database_system/entity_relationship_model#entity","title":"Entity","text":"<ul> <li>Also known as Entity Type</li> <li>Strong Entity</li> <li>Entity that has a key attribute and does not depend on other entities</li> <li>Records are identified uniquely using primary key</li> <li>Weak Entity</li> <li>Dependent entity with no key attribute</li> <li>Example: Salary entity won't exist without employee entity</li> <li>Participation: Total</li> <li>Entity Set: Set of individual entities (instances of entity type)</li> </ul>"},{"location":"database_system/entity_relationship_model#attributes","title":"Attributes","text":"<ul> <li>Properties that define the entity type</li> <li>Key Attribute: Uniquely identifies each entity in the entity set</li> <li>Composite Attribute</li> <li>Attribute composed of many other attributes</li> <li>Example: Address consists of street, city, state, country</li> <li>Multi-valued Attribute</li> <li>Example: There can be multiple Email for a user</li> <li>Derived Attribute</li> <li>Example: Age attribute can be derived from date of birth</li> </ul>"},{"location":"database_system/entity_relationship_model#relationship","title":"Relationship","text":"<ul> <li>Association between entity types</li> <li>Identifying Relationship</li> <li>Relationship between weak entity &amp; its identifying strong entity</li> <li>Relationship Set: Set of relationships of the same type</li> </ul>"},{"location":"database_system/entity_relationship_model#degree","title":"Degree","text":"<ul> <li>Number of different entity sets participating in a relationship set</li> <li>Unary</li> <li>One entity is related to another entity of the same type</li> <li>Example: A person is married to another person</li> <li>Binary</li> <li>One entity is related to another entity of a different type</li> <li>Example: A student is enrolled in a course</li> <li>N-ary</li> <li>More than 2 entities are related</li> <li>Example: A doctor prescribes a medicine to a patient</li> </ul>"},{"location":"database_system/entity_relationship_model#cardinality","title":"Cardinality","text":"<ul> <li>Number of times an entity participates in a relationship</li> <li>One to One</li> <li>An employee can have only one salary</li> <li>Minimum tables required<ul> <li>Total Participation: 1</li> <li>Employee (emp_id, salary)</li> <li>Partial Participation: 2</li> <li>There can be disconnected entities in second table</li> <li>If so, it can lead to empty cells for salary column in above approach</li> <li>Employee (emp_id, salary_id), Salary (emp_id)</li> </ul> </li> <li>One to Many</li> <li>A company can have many employees</li> <li>Minimum tables required: 2</li> <li>Company (com_id), Employee (emp_id, com_id)</li> <li>Many to Many</li> <li>A student can enroll in many courses &amp; a course can be enrolled by many students</li> <li>Minimum tables required: 3</li> <li>Student (stu_id), Course (course_id), StudentCourses (stu_id, course_id)</li> </ul>"},{"location":"database_system/entity_relationship_model#participation","title":"Participation","text":"<ul> <li>Total</li> <li>Each entity in entity set participates in the relationship</li> <li>Each student must enroll in a course</li> <li>Partial</li> <li>Entity in entity set may or may not participate in the relationship</li> <li>A person may or may not have a car</li> </ul>"},{"location":"database_system/entity_relationship_model#enhanced-er-model","title":"Enhanced ER Model","text":"<ul> <li>Specialization (Subclass)</li> <li>Divide an entity into sub-entities based on characteristics (Top-down approach)</li> <li>'is a' relationship</li> <li>Example: Laptop is a computer (laptop is a special/sub class of computer)</li> <li>Contraints:<ul> <li>Total or Partial</li> <li>Total subclass if every super-class entity is to be associated</li> <li>with some sub-class entity</li> <li>Overlapped or Disjoint</li> <li>Overlapping subclass if an entity from a super-set can be related (can occur)</li> <li>in multiple sub-class sets</li> </ul> </li> <li>Generalization (Superclass)</li> <li>Extracting common properties and creating a generalized entity (Bottom-up approach)</li> <li>Example: Laptop is a computer (computer is a general/super class of laptop)</li> <li>Inheritance</li> <li>Feature that allows subclasses to inherit attributes &amp; relationships from superclasses</li> <li>Multiple Inheritance</li> <li>An entity can be a subclass of multiple entity types</li> <li>Teaching Assistant can be a subclass of Employee &amp; Student both</li> <li>Attributes of the subclass are union of attributes of all superclasses</li> <li>Aggregation</li> <li>Abstraction that represents a group of entities as a single entity</li> <li>Example: An employee working on a project may require machinery<ul> <li>Aggregate entities Employee &amp; Project</li> <li>Are connected with the relationship 'working on'</li> <li>Entities Employee-Project-Aggregate and Machinery</li> <li>Are connected with the relationship 'requires'</li> </ul> </li> </ul>"},{"location":"database_system/entity_relationship_model#recursive-relationship","title":"Recursive Relationship","text":"<ul> <li>Employee &amp; Boss (Boss is also employee)</li> <li>User &amp; Friend (Friend is also user)</li> <li>Boss and Friend are called role names</li> </ul>"},{"location":"database_system/entity_relationship_model#employee-boss","title":"Employee - Boss","text":"<ul> <li>Employee</li> <li>Min cardinality = 0 (CEO can't have boss)</li> <li>Max cardinality = 1 (employee can have only one boss)</li> <li>Boss</li> <li>Min cardinality = 0 (individual contributors don't manage any employee)</li> <li>Max cardinality = n (can manage many employees)</li> <li>Participation: Partial</li> <li>Relationship: Many to one</li> <li>Employee (emp_id, boss_id)</li> <li>Foreign keys: boss_id in Employee</li> </ul>"},{"location":"database_system/entity_relationship_model#user-friend","title":"User - Friend","text":"<ul> <li>User</li> <li>Min cardinality = 0</li> <li>Max cardinality = n</li> <li>Friend</li> <li>Min cardinality = 0</li> <li>Max cardinality = n</li> <li>Participation: Partial</li> <li>Relationship: Many to many</li> <li>User (user_id), Friendship (user_id, friend_user_id)</li> <li>Store both (user_id, friend_user_id) &amp; (friend_user_id, user_id)<ul> <li>To make it simple &amp; scalable</li> </ul> </li> </ul>"},{"location":"database_system/entity_relationship_model#impedance-mismatch","title":"Impedance Mismatch","text":"<ul> <li>When two systems or components that are supposed to work together</li> <li>Have different data models, structures or interfaces</li> <li>It can make communciation difficult or inefficient</li> <li>In databases, it refers to discrepancy between</li> <li>OOP model in application code &amp; relational model in database</li> <li>OOP models represent data as objects with properties &amp; methods</li> <li>Relational model represents data as tables with columns &amp; rows</li> <li>Challenges in mapping objects to tables &amp; vice versa</li> <li>Object heirarchy may need to be flattened into single table</li> <li>Multiple related tables may need to be joined together to represent a single object</li> <li>Data type mismatch between the programming language and the data models</li> <li>The query results can be sets or multisets of tuples</li> <li>Where each tuple is formed of attribute values</li> <li>The result's data structures needs to be binded<ul> <li>To the programming language's data structures</li> </ul> </li> <li>The tuples are required to be looped over to extract individual values</li> <li>These can lead to performance issues, data inconsistency, development time &amp; cost</li> <li>To overcome the impedance mismatch problem, Object Relational Mapping (ORM) is used</li> <li>It automates the mapping process between objects &amp; tables</li> </ul>"},{"location":"database_system/relational_model","title":"Relational Model","text":"<ul> <li>Representing data in form of tables (or relations) connected by key fields</li> <li>After designing the conceptual model of the database using ER diagram</li> <li>It needs to be converted into a relational model</li> <li>So that it can be implemented using the language of RDBMS</li> <li>Relational Schema</li> <li>Structure of a relation</li> <li>The number of attributes in a relation is called its degree</li> <li>Example: Student (id, name, email) has a degree of 3</li> <li>Relational Instance</li> <li>Set of values present in a relationship</li> <li>The number of these instances is called cardinality</li> <li>Example: Student (id: 1, name: 'Test', email: 'test@email.com')</li> <li>Relational Algebra</li> <li>Set of operations that can be performed on relations</li> </ul>"},{"location":"database_system/relational_model#codds-rules","title":"Codd's Rules","text":"<ul> <li>Checks whether DBMS has the quality to become RDBMS</li> <li>It's rare to fulfill all the rules, generally 8-9 rules are followed</li> <li>These 13 rules are popularly known as Codd's 12 rules (index 0 - 12)</li> <li>Rule 0: Foundation</li> <li>Must be able to manage databases entirely through its relational capabilities</li> <li>Rule 1: Information</li> <li>Data stored must be a value of some cell of a table</li> <li>Rule 2: Guaranteed Access</li> <li>Every data element must be accessible<ul> <li>By the table name, primary key, and attribute name</li> </ul> </li> <li>Rule 3: Systematic Treatment of NULL values</li> <li>NULL value must only correspond to missing, unknown, or not applicable values</li> <li>Rule 4: Active Online Catalog</li> <li>Structure of the database must be stored in an online catalog<ul> <li>That can be queried by authorized users</li> </ul> </li> <li>Rule 5: Comprehensive Data Sub-language</li> <li>Database should be accessible by a language<ul> <li>Supported for definition, manipulation, &amp; transaction management</li> </ul> </li> <li>Rule 6: View Updating Rule</li> <li>Different views should be updatable by the system</li> <li>Rule 7: High level insert, update &amp; delete</li> <li>Should support operations like insert, delete, update, etc at each level of relations</li> <li>Rule 8: Physical Data Independence</li> <li>Any modification in physical location of table should not affect application level</li> <li>Rule 9: Logical Data Independence</li> <li>Any modification in conceptual schema of table should not affect application level</li> <li>Example: Merging two tables into one<ul> <li>Should not affect the application accessing it (difficult to achieve)</li> </ul> </li> <li>Rule 10: Integrity Independence</li> <li>Integrity constraints modified at database level should not affect application level</li> <li>Rule 11: Distribution Independence</li> <li>Distribution of data over various locations should not be visible to end-users</li> <li>Rule 12: Non-subversion</li> <li>Low level access to data should not be able to bypass the integrity rule to change data</li> </ul>"},{"location":"database_system/relational_model#relation-keys","title":"Relation Keys","text":"<ul> <li>Keys are used to identify a row in a table uniquely</li> <li>It also helps in setting relationship between various columns &amp; tables</li> <li>Super Key: A set of any number of attributes that can identify a row uniquely</li> <li>Candidate Key: Minimal set of attributes that can identify a row uniquely</li> <li>Primary Key: One key chosen out of candidate keys to identify a row uniquely</li> <li>Composite Key: If a combination of attributes are used as the primary key</li> <li>Alternate Key: Candidate keys except the primary key</li> <li>Foreign Key</li> <li>A reference key that can identify a row uniquely in the related table</li> <li>It should be a primary key in the referenced table</li> </ul>"},{"location":"database_system/relational_model#constraints","title":"Constraints","text":"<ul> <li>While designing a relational model</li> <li>Conditions are defined that must hold true for the data, these are called constraints</li> <li>These constraints are checked before performing any operation in database</li> <li>Domain Constraints</li> <li>Attribute level constraints, attribute values must match the specified domain</li> <li>Example: age should be &gt; 0 for Student relation</li> <li>Key Integrity (or Entity Integrity)</li> <li>Every relation should have at least one key to uniquely identify a row</li> <li>Primary key cannot have NULL values</li> <li>Referential Integrity</li> <li>When one attribute of a relation can only take values<ul> <li>From another attribute of the same or another relation</li> </ul> </li> <li>Foreign keys must match primary keys in the referenced table or be NULL</li> <li>Example: branch_code in Branch relation referenced in Student relation<ul> <li>Referencing relation: Student (id, name, branch_code)</li> <li>Referenced relation: Branch (branch_code, branch_name)</li> </ul> </li> </ul>"},{"location":"database_system/relational_model#anomalies","title":"Anomalies","text":"<ul> <li>Insertion</li> <li>Referencing attribute cannot have a value that is not present in the referenced attribute</li> <li>Deletion</li> <li>Referenced attribute cannot be deleted if its present in a referencing attribute</li> <li>Updation</li> <li>Referenced attribute cannot be updated if its present in a referencing attribute</li> <li>Example: if branch_code is updated from 'CS' to 'CSE' in Branch<ul> <li>Then it should be updated in Student table as well</li> </ul> </li> <li>Solutions for Deletion/Updation</li> <li>Cascade<ul> <li>Delete Cascade: Deletes the referencing rows if the referenced row is deleted</li> <li>Update Cascade: Updates the referencing rows if the referenced row is updated</li> </ul> </li> <li>Set NULL in referencing rows</li> <li>Normalization can be used to minimize these anamolies</li> </ul>"},{"location":"database_system/relational_model#data-warehouse-modeling","title":"Data Warehouse Modeling","text":""},{"location":"database_system/relational_model#star-schema","title":"Star Schema","text":"<ul> <li>Data is organized into a central fact table</li> <li>That contains metrics or measures that are of interest</li> <li>In a sales data warehouse<ul> <li>Fact table might contain sales revenue, units sold, profit margins</li> </ul> </li> <li>Each record in the fact table represents a specific event or transaction<ul> <li>Like a sale or order</li> </ul> </li> <li>Fact table is surrounded by dimension tables</li> <li>That describe the attributes of the measures</li> <li>These attributes are used to slice and dice the data in fact table</li> <li>This allows users to analyze the data from different perspectives</li> <li>In a sales data warehouse<ul> <li>Dimension tables might include product, customer, time &amp; location</li> </ul> </li> <li>Each dimension table is joined to fact table through a foreign key relationship</li> <li>A user might want sales revenue by product category or region or time period</li> <li>It improves the data retrieval and is used by many OLAP systems</li> </ul>"},{"location":"database_system/relational_model#snowflake-schema","title":"Snowflake Schema","text":"<ul> <li>Variant of star schema</li> <li>Where dimensions are present in a normalized form in multiple related tables</li> <li>The dimensions are detailed and highly structured having several levels of relationship</li> <li>The child tables might have multiple parent tables</li> <li>These tables are maintained in normalized form to reduce redundancy</li> <li>It makes them easy to maintain</li> <li>Though more joins are required that impact the performance</li> </ul>"},{"location":"database_system/relational_model#relational-algebra","title":"Relational Algebra","text":"<ul> <li>Union: <code>A U B</code></li> <li>Intersection: <code>A \u2229 B</code></li> <li>Difference: <code>A - B</code></li> <li>Cartesian Product: <code>A X B</code></li> <li>Selection: <code>\u03c3 condition (relation_name)</code></li> <li>Displays all attributes, works on rows</li> <li>Projection: <code>\u03c0 (col1, col2) relation_name</code></li> <li>Works on columns, picks speciic columns</li> <li>Divide: <code>A \u00f7 B</code></li> <li>Rename: <code>\u03c1 (old_relation, new_relation)</code></li> </ul>"},{"location":"database_system/relational_model#joins","title":"Joins","text":"<ul> <li>Outer Joins</li> <li>Left: <code>A \u27d5 B</code></li> <li>Right: <code>A \u27d6 B</code></li> <li>Full: <code>A \u27d7 B</code></li> <li>Inner Joins</li> <li>Conditional: <code>A \u22c8 \u03b8 B</code>, theta denotes conditions</li> <li>Equi: <code>A \u22c8 [A.column1 = B.column2] (B)</code><ul> <li>Special case of conditional join where only equality condition holds</li> </ul> </li> <li>Natural: <code>A \u22c8 B</code><ul> <li>Special case of equijoin in which equality condition hold on all attributes</li> <li>Which have same name in relations</li> <li>If there is a common attribute with the same name &amp; type</li> <li>Then that row will be joined</li> <li>Returns the similar attributes only once</li> <li>As their value will be the same in the resulting relation</li> </ul> </li> </ul>"},{"location":"database_system/relational_model#nested-vs-join-queries","title":"Nested vs Join Queries","text":"<ul> <li>Nested queries</li> <li>Only relevant info from each table can be extracted</li> <li>Can lead to bugs or poor performance, optimization depends on the developer</li> <li>Every constant subquery is evaluated as many times encountered<ul> <li>Large subqueries may take time to execute</li> </ul> </li> <li>Join queries</li> <li>Whole tables are fetched and a large table is created from which filtering happens</li> <li>Joins are universally understood, so no optimization issues can arise</li> <li>Foreign &amp; primary keys are usually indexed<ul> <li>So performs better than large subqueries</li> </ul> </li> </ul>"},{"location":"database_system/functional_dependency","title":"Functional Dependency","text":"<ul> <li>A functional dependency A -&gt; B in a relation holds if</li> <li>Two tuples having the same value of attribute A also have the same value for attribute B</li> <li>Examples</li> <li><code>student_id -&gt; student_name</code>, <code>state -&gt; country</code> hold</li> <li><code>student_name -&gt; state</code> doesn't hold</li> <li>Advantages</li> <li>Reduces data redundancy</li> <li>Enhances data integrity and guarantees that data is consistent</li> <li>Simplifies adding, editing, &amp; removing data</li> <li>Disadvantages</li> <li>Overly restrictive functional dependencies can slow query performance</li> <li>They don't take the semantic meaning of data into account<ul> <li>May not reflect the true relationships between data elements</li> </ul> </li> <li>Functional dependency set of a relation is the set of all FDs in that relation</li> </ul>"},{"location":"database_system/functional_dependency#trivial-fd","title":"Trivial FD","text":"<ul> <li>A FD X -&gt; Y is trivial if Y is a subset or X</li> <li>That is, if the set of dependent attributes are included in the source attributes</li> <li>Example: {student_id, student_name} -&gt; {student_id}</li> <li>Else it is called non-trivial FD</li> </ul>"},{"location":"database_system/functional_dependency#armstrong-axioms","title":"Armstrong Axioms","text":"<ul> <li>Axioms</li> <li>Reflexivity: If Y is a subset of X, then X -&gt; Y</li> <li>Augmentation: If X -&gt; Y, then XZ -&gt; YZ</li> <li>Transitivity: If X -&gt; Y and Y -&gt; Z, then X -&gt; Z</li> <li>Secondary Rules: Derived from the above axioms</li> <li>Union: If X -&gt; Y and X -&gt; Z, then X -&gt; YZ</li> <li>Composition: If X -&gt; Y and A -&gt; B, then XA -&gt; YB</li> <li>Decomposition: If X -&gt; YZ, then X -&gt; Y and X -&gt; Z</li> <li>Pseudo Transitivity: If X -&gt; Y and YA -&gt; Z, then XA -&gt; Z</li> <li>Self Determination: X -&gt; X</li> <li>Extensivity<ul> <li>If XA -&gt; X and X -&gt; Y, then XA -&gt; Y</li> <li>If XY -&gt; XYZ and XYZ -&gt; YZ, then XY -&gt; YZ</li> </ul> </li> </ul>"},{"location":"database_system/functional_dependency#equivalence-of-fd","title":"Equivalence of FD","text":"<ul> <li>Let F and G be two FD sets for a relation</li> <li>If F can be derived from G, then F is a subset of G</li> <li>If G can be derived from F, then G is a subset of F</li> <li>If both of the above are true, then F = G</li> </ul>"},{"location":"database_system/functional_dependency#attribute-closure","title":"Attribute Closure","text":"<ul> <li>Attribute closure of an attribute set</li> <li>Is the set of attributes that can be functionally determined from it</li> <li>If the set of attributes is A, then its attribute closure is represented as A+</li> <li>Example: For a Student table</li> <li>(student_id)+ = {student_id, name, phone, state, country}<ul> <li>If student_id is known, then the mentioned attributes can be determined from it</li> </ul> </li> <li>(student_state)+ = {student_state, student_country}</li> <li>Advantages</li> <li>Identifies all attributes that can be derived from a given set of attributes<ul> <li>And ensures data consistency</li> </ul> </li> <li>Identifies relationships between attributes and tables<ul> <li>Helpful to optimize query performance</li> </ul> </li> <li>Disadvantages</li> <li>As the number of attributes &amp; tables increase, it can become complex to manage</li> <li>They don't take the semantic meaning of data into account</li> </ul>"},{"location":"database_system/functional_dependency#finding-keys","title":"Finding Keys","text":"<ul> <li>An attribute set will be a super key if</li> <li>The attribute closure of the set contains all attributes of relation</li> <li>This attribute set will also be a candidate key if</li> <li>No subset of the set can functionally determine all attributes of the relation</li> <li>Prime Attributes: Attributes that are parts of any candidate key of a relation</li> <li>Other attributes are called non-prime attributes</li> </ul>"},{"location":"database_system/functional_dependency#canonical-cover","title":"Canonical Cover","text":"<ul> <li>Managing a large set of functional dependencies can result in</li> <li>Unnecessary computational overhead</li> <li>This is where the canonical cover becomes useful</li> <li>A canonical cover of a set of FDs</li> <li>Is a simplified version of FDs that retains the same closure as the original set</li> <li>Ensuring no redundancy</li> <li>Extranious Attribute of FD</li> <li>If it can be removed from LHS without changing the closure of the set of FDs</li> <li>Advantages</li> <li>Essential for optimizing database management systems</li> <li>Simplifies and minimizes the dependencies while preserving their properties<ul> <li>Reducing computational overhead, and improving efficiency</li> </ul> </li> <li>By reducing, eliminating, and minimizing dependencies, canonical cover creates<ul> <li>A minimal, unique, and accurate representation of the original set</li> </ul> </li> <li>It helps to reduce data redundancy, improves query performance<ul> <li>And makes database maintenance easier.</li> </ul> </li> <li>Application</li> <li>Whenever a user updates the database<ul> <li>The system must check if any of the FDs are getting violated</li> </ul> </li> <li>If there are violations in the new database state, then the system must roll back</li> <li>Working with a huge set of FD can cause unnecessarily added computational time</li> <li>Useful to provide simplified set of FD to determine keys</li> </ul>"},{"location":"database_system/functional_dependency#finding-canonical-cover","title":"Finding Canonical Cover","text":"<ul> <li>Reduction</li> <li>Remove redundant dependencies</li> <li>Combine dependencies that have common attributes on LHS</li> <li>Elimination: Eliminate extraneous attributes from LHS</li> <li>Minimization: Remove dependencies that are implied by other dependencies</li> <li>Example: A -&gt; BC, B -&gt; C, AB -&gt; C</li> <li>Reduction: A -&gt; B (A -&gt; BC &amp;&amp; B -&gt; C), A -&gt; C (AB -&gt; C &amp;&amp; B -&gt; C)</li> <li>Elimination: A -&gt; C (A -&gt; B &amp;&amp; B -&gt; C)</li> <li>Minimization: Remove AB -&gt; C since A -&gt; C</li> </ul>"},{"location":"database_system/functional_dependency#f-canonically-covers-g","title":"F Canonically Covers G","text":"<ul> <li>Consider two sets of FD</li> <li>F = { A -&gt; B, AB -&gt; C, D -&gt; AC, D -&gt; E }</li> <li>G = { A -&gt; BC, D -&gt; AB }</li> <li>Create singleton RHS</li> <li>F = { A -&gt; B, AB -&gt; C, D -&gt; A, D -&gt; C, D -&gt; E }</li> <li>G = { A -&gt; B, A -&gt; C, D -&gt; A, D -&gt; B}</li> <li>Remove extraneous attributes</li> <li>F = { A -&gt; B, A -&gt; C, D -&gt; A, D -&gt; C, D -&gt; E }<ul> <li>Remove B from AB -&gt; C since A -&gt; B &amp;&amp; AB -&gt; C</li> </ul> </li> <li>G = { A -&gt; B, A -&gt; C, D -&gt; A, D -&gt; B}<ul> <li>No changes since all LHS have single attributes</li> </ul> </li> <li>Remove redundant FDs</li> <li>F = { A -&gt; B, A -&gt; C, D -&gt; A, D -&gt; E }<ul> <li>D -&gt; C can be derived from D -&gt; A &amp;&amp; A -&gt; C</li> </ul> </li> <li>G = { A -&gt; B, A -&gt; C, D -&gt; A }<ul> <li>D -&gt; B can be derived from D -&gt; A &amp;&amp; A -&gt; B</li> </ul> </li> <li>All FDs of G are covered in F, so F covers G</li> </ul>"},{"location":"database_system/normalization","title":"Normalization","text":"<ul> <li>Process of organizing attributes to reduce data redundancy</li> <li>Data redundancy</li> <li>Advantages<ul> <li>Data is readily accessible</li> <li>Enhances query performance since less joins are required</li> </ul> </li> <li>Disadvantages<ul> <li>Increased storage size</li> <li>Inconsistency problems or anamolies during insert, update, delete operations</li> </ul> </li> <li>Data consistency: Keeps data consistent at all places</li> <li>Data integrity: Ensures data accuracy and protects against data loss &amp; leaks</li> <li>Simplifies data management by breaking down complex tables</li> </ul>"},{"location":"database_system/normalization#normal-forms","title":"Normal Forms","text":"<ul> <li>The default requirement for a normal form is to satify all the previous normal forms</li> </ul>"},{"location":"database_system/normalization#first-1nf","title":"First (1NF)","text":"<ul> <li>No composite or multi-valued attributes in the relation</li> <li>Helps eliminate duplicate data and simplifies queries</li> <li>Example: Student (id: 1, phone: [1234, 5678])</li> <li>Student is not in 1NF because phone has 2 values</li> <li>Break the row into 2 rows to make it 1NF<ul> <li>Student (id: 1, phone: 1234)</li> <li>Student (id: 1, phone: 5678)</li> </ul> </li> </ul>"},{"location":"database_system/normalization#second-2nf","title":"Second (2NF)","text":"<ul> <li>Relation is in 2NF if any one of the following holds true</li> <li>Candidate key is single valued</li> <li>Candidate key is multi valued, but there is no partial dependency in the relation<ul> <li>Any non-prime attribute should not be dependent on any proper subset of any candidate key</li> </ul> </li> <li>Reduces redundant data</li> <li>Student (id, course_id, course_fee)</li> <li>If 100 students are taking the same course, no need to store its fee 100 times</li> <li>Consider X -&gt; Y &amp; A -&gt; Y</li> <li>Let's say X is a composite candidate key {A, B}</li> <li>It is a partial dependency because Y is non-prime and depends only on A<ul> <li>And A is a proper subset of the candidate key {A, B}</li> <li>If A -&gt; Y was not present, it will be in 2NF</li> </ul> </li> <li>If the candidate key X was single valued (say B -&gt; Y)<ul> <li>Then also it will be in 2NF</li> </ul> </li> <li>Proper subset</li> <li>A proper subset is a set that contains some but not all elements of another set</li> <li>E.g. {1} is proper subset of {1, 2}, but {1, 2} is subset (not proper) of {1, 2}</li> <li>Example: StudentCourse (id, course_id, course_fee)</li> <li>It is not in 2NF because<ul> <li>Candidate key here is {id, course_id}</li> <li>But course_id -&gt; course_fee</li> <li>course_id is a proper subset of a candidate key</li> <li>course_fee is a non-prime attribute<ul> <li>It cannot identify a row uniquely even if combined with other attributes</li> </ul> </li> <li>It is a partial dependency and so this relation is not in 2NF</li> </ul> </li> <li>Break the table into 2 tables to make it 2NF<ul> <li>StudentCourse (id, course_id)</li> <li>Course (id, course_fee)</li> </ul> </li> </ul>"},{"location":"database_system/normalization#third-3nf","title":"Third (3NF)","text":"<ul> <li>No transitive dependency for non-prime attributes on any candidate key</li> <li>If A -&gt; B and B -&gt; C, then A -&gt; C is called transitive dependency</li> <li>Ensures that FD is preserved and lossless</li> <li>Alternatively, we can say that for a non-trivial FD X -&gt; Y</li> <li>Atleast one of the following conditions should hold true</li> <li>X is a super key</li> <li>Y is a prime attribute</li> <li>3NF is considered adequate for normal RDBMS</li> <li>Because most of the 3NF tables are free of anomalies</li> <li>Example: Student (id, name, state, country)</li> <li>It is not in 3NF because<ul> <li>id -&gt; state and state -&gt; country</li> <li>Country is a non-prime attribute since the candidate key is {id}</li> <li>But it depends transitively on id (which is candidate key)</li> <li>Alternatively, country is non-prime and state is not super key</li> <li>But state -&gt; country</li> </ul> </li> <li>Break the table into 2 tables to make it 3NF<ul> <li>Student (id, name, state)</li> <li>StateCountry (state, country)</li> </ul> </li> <li>Example 2:</li> <li>StudentCourse (id, course, instructor, instructor_email)<ul> <li>{id, course} -&gt; instructor (a course can have multiple instructors)</li> <li>instructor -&gt; course (an instructor teaches only one course)</li> <li>instructor -&gt; instructor_email</li> <li>{id, instructor} -&gt; course (course can be determined through id &amp; instructor)</li> </ul> </li> <li>Candidate keys<ul> <li>{id, course}, since a student can have multiple courses</li> <li>{id, instructor}, since an instructor teaches only one course</li> </ul> </li> <li>Hence, {id, course} -&gt; instructor -&gt; instructor_email<ul> <li>Which is transitive dependency and hence not in 3NF</li> <li>Alternatively, instructor_email is non-prime and instructor is not super key</li> </ul> </li> <li>Solution<ul> <li>Student (id, course, instructor)</li> <li>Instructor (instructor, instructor_email)</li> </ul> </li> </ul>"},{"location":"database_system/normalization#bcnf","title":"BCNF","text":"<ul> <li>In a FD X -&gt; Y, X must be a super key</li> <li>Advanced form for 3NF</li> <li>This is the last practiced form</li> <li>Forms beyond like 4NF &amp; 5NF are used only for theoritical purposes</li> <li>Example:</li> <li>Student (id, course, branch)<ul> <li>Student (id: 1, course: 'DSA', branch: 'CSE')</li> <li>Student (id: 1, course: 'OS', branch: 'CSE')</li> <li>Student (id: 1, course: 'Networks', branch: 'CSE')</li> </ul> </li> <li>For id -&gt; branch, id is not a super key<ul> <li>Since there can be multiple values with same id</li> </ul> </li> <li>For course -&gt; branch, course is not a super key<ul> <li>Since multiple courses can have same branch</li> </ul> </li> <li>Break the table into 3 tables to make it BCNF<ul> <li>Student (id, branch)</li> <li>StudentCourse (student_id, course_id)</li> <li>Course (id, branch)</li> </ul> </li> <li>Example 2:</li> <li>StudentCourse (id, course, instructor)<ul> <li>{id, course} -&gt; instructor (a course can have multiple instructors)</li> <li>instructor -&gt; course (an instructor teaches only one course)</li> <li>{id, instructor} -&gt; course (course can be determined through id &amp; instructor)</li> </ul> </li> <li>Candidate keys<ul> <li>{id, course}, since a student can have multiple courses</li> <li>{id, instructor}, since an instructor teaches only one course</li> </ul> </li> <li>Here, in instructor -&gt; course, instructor is not a super key<ul> <li>Hence it is not in BCNF</li> </ul> </li> <li>Solution<ul> <li>StudentInstructor (id, instructor)</li> <li>InstructorCourse (instructor, course)</li> </ul> </li> </ul>"},{"location":"database_system/normalization#fourth-4nf","title":"Fourth (4NF)","text":"<ul> <li>No non-trivial multi-valued dependency except candidate key</li> <li>Multi-valued dependency (MVD)</li> <li>If two attributes are independent of one another but both depend on a third attribute</li> <li>Example:</li> <li>Student (id, name, course_name)</li> <li>MVD: name &amp; course_name are independent but id -&gt; name, id -&gt; course_name</li> <li>Solution<ul> <li>Student (id, name)</li> <li>StudentCourse (student_id, course_name)</li> </ul> </li> </ul>"},{"location":"database_system/normalization#fifth-5nf","title":"Fifth (5NF)","text":"<ul> <li>Also called projection-join normal form (PJNF)</li> <li>No join dependency except candidate keys</li> <li>A relation decomposed into two relations must be lossless</li> <li>Lossless Decompositionwhich</li> <li>If relation R (A, B, C) is decomposed into R1 (A, B) &amp; R2 (B, C)</li> <li>It is lossless if the join of R1 &amp; R2 over B should be equal to R</li> <li>It is lossy if the number of joined tuples are more or less than R</li> <li>It is dependency preserving if all the FD are preserved in R1 &amp; R2</li> <li>Example:</li> <li>Course (name, faculty, semester)<ul> <li>Course (name: 'DSA', faculty: 'F1', semester: 1)</li> <li>Course (name: 'DBMS', faculty: 'F1', semester: 2)</li> </ul> </li> <li>R1<ul> <li>Course (name: 'DSA', faculty: 'F1')</li> <li>Course (name: 'DBMS', faculty: 'F1')</li> </ul> </li> <li>R2<ul> <li>Course (faculty: 'F1', semester: 1)</li> <li>Course (faculty: 'F1', semester: 2)</li> </ul> </li> <li>Join (R1, R2)<ul> <li>Course (name: 'DSA', faculty: 'F1', semester: 1)</li> <li>Course (name: 'DSA', faculty: 'F1', semester: 2)</li> <li>Course (name: 'DBMS', faculty: 'F1', semester: 1)</li> <li>Course (name: 'DBMS', faculty: 'F1', semester: 2)</li> </ul> </li> <li>The join is introducing wrong data (loss of data)<ul> <li>A row requires all the 3 attributes to be known (name, faculty, semester)</li> <li>Hence there is a join dependency and it is not in 5NF</li> </ul> </li> <li>Solution<ul> <li>R1 (name, faculty)</li> <li>R2 (name, semester)</li> <li>R3 (faculty, semester)</li> </ul> </li> </ul>"},{"location":"database_system/normalization#finding-normal-forms","title":"Finding Normal Forms","text":"<ul> <li>Find all the candidate keys (C) using attribute closure</li> <li>Divide all attributes as prime and non-prime</li> </ul>"},{"location":"database_system/normalization#example-1","title":"Example 1","text":"<ul> <li>R (A, B, C, D, E) with FD = { A -&gt; D, B -&gt; A, BC -&gt; D, AC -&gt; BE }</li> <li>Candidate keys = { AC, BC }</li> <li>AC is a candidate key since (AC)+ = { A, C, D, B, E }</li> <li>BC is a candidate key since B -&gt; A</li> <li>Prime attributes = { A, B, C }</li> <li>1NF: Yes, no composite attributes</li> <li>2NF: No, D is dependent on A (A -&gt; D)</li> <li>Where A is proper subset of candidate key AC</li> </ul>"},{"location":"database_system/normalization#example-2","title":"Example 2","text":"<ul> <li>R (A, B, C, D, E) with FD = { BC -&gt; D, AC -&gt; BE, B -&gt; E }</li> <li>Candidate keys = { AC }</li> <li>AC is a candidate key since (AC)+ = { A, C, B, E, D }</li> <li>Prime attributes = { A, C }</li> <li>1NF: Yes, no composite attributes</li> <li>2NF: Yes, LHS (BC, AC, B) doesn't have any proper subset of candidate keys</li> <li>3NF: No</li> <li>BC -&gt; D: BC is not a super key, nor D is prime attribute</li> <li>B -&gt; E: B is not a super key, nor E is prime attribute</li> </ul>"},{"location":"database_system/normalization#example-3","title":"Example 3","text":"<ul> <li>R (A, B, C, D, E) with FD = { B -&gt; A, A -&gt; C, BC -&gt; D, AC -&gt; BE}</li> <li>Candidate keys = { A, B }</li> <li>B is a candidate key since (B)+ = { B, A, C, D, E }</li> <li>A is a candidate key since (A)+ = { A, C, B, E, D }</li> <li>Prime attributes = { A, B }</li> <li>1NF: Yes, no composite attributes</li> <li>2NF: Yes, LHS (B, A, BC, AC) doesn't have any proper subset of candidate keys</li> <li>3NF: Yes, All LHS have super key, so no need to check prime attribute in RHS</li> <li>BCNF: Yes, All LHS have super key</li> </ul>"},{"location":"database_system/normalization#denormalization","title":"Denormalization","text":"<ul> <li>Adding redundant data to tables to optimize performance and avoid costly joins</li> <li>Does not mean reversing normalization but adding redundancy after normalization</li> <li>This can make inserts &amp; updates more expensive, but increases accessibility</li> </ul>"},{"location":"database_system/transactions_and_schedules","title":"Transaction and Schedules","text":""},{"location":"database_system/transactions_and_schedules#transaction","title":"Transaction","text":"<ul> <li>Transaction</li> <li>Collection of operations that performs a single logical function in database</li> <li>Operations: Read, Write, Commit, Rollback, Abort</li> </ul>"},{"location":"database_system/transactions_and_schedules#transaction-properties","title":"Transaction properties","text":"<ul> <li>Atomicity</li> <li>Either all operations should execute or none</li> <li>No partial transactions</li> <li>Consistency</li> <li>Data should be consistent everywhere<ul> <li>Debit, credit, sender, receiver, total, remaining, before, after</li> </ul> </li> <li>Any transaction should take the database from one consistent state to another<ul> <li>Maintaining the rules and constraints defined for the data</li> </ul> </li> <li>Isolation</li> <li>Operation permission should be granted to one transaction only</li> <li>No two writes or one read &amp; write should happen simultaneously</li> <li>Ensures that multiple transactions can occur concurrently and independently<ul> <li>Without interference and without leading to inconsistency of database state</li> </ul> </li> <li>Durable</li> <li>Once committed, changes should be permanent even if a system failure occurs</li> <li>Account updates shouldn't be lost</li> <li>Multiple copies of the database should be stored at different locations</li> </ul>"},{"location":"database_system/transactions_and_schedules#schedule","title":"Schedule","text":"<ul> <li>Series of operations from one or more transactions</li> <li>Types</li> <li>Serial</li> <li>Concurrent<ul> <li>Serializable</li> <li>Conflict Serializable</li> <li>View Serializable</li> <li>Non-Serializable</li> <li>Recoverable<ul> <li>Cascading</li> <li>Cascadeless</li> <li>Strict</li> </ul> </li> <li>Non-Recoverable</li> </ul> </li> </ul>"},{"location":"database_system/transactions_and_schedules#serial-schedule","title":"Serial Schedule","text":"<ul> <li>When one transaction executes completely before starting another transaction</li> <li>It is always consistent</li> <li>Has low throughput and less resource utilization</li> </ul>"},{"location":"database_system/transactions_and_schedules#concurrent-schedule","title":"Concurrent Schedule","text":"<ul> <li>When operations of a transaction are interleaved</li> <li>With operations of other transactions of a schedule</li> <li>Can lead to inconsistency</li> <li>Serializable Schedules</li> <li>Used to verify whether the scheduling will lead to any inconsistency</li> <li>These are non-serial transactions that produce an equal outcome when executed serially</li> </ul>"},{"location":"database_system/transactions_and_schedules#conflict-serializable","title":"Conflict Serializable","text":"<ul> <li>If the schedule can be transformed into serial schedule</li> <li>By swapping non-conflicting operations</li> </ul>"},{"location":"database_system/transactions_and_schedules#conflicting-operations","title":"Conflicting Operations","text":"<ul> <li>They belong to separate transactions</li> <li>Both operate on the same data item</li> <li>At least one of them is write operation</li> </ul>"},{"location":"database_system/transactions_and_schedules#examples","title":"Examples","text":"<ul> <li>Example 1:</li> <li>S: R1(A), W1(A), R2(A), W2(A), R1(B), W1(B), R2(B), W2(B)</li> <li>Swapping non-conflicting operations<ul> <li>S1: R1(A), W1(A), R1(B), W1(B), R2(A), W2(A), R2(B), W2(B)</li> </ul> </li> <li>This can be represented as T1 -&gt; T2</li> <li>It can also be rearranged as T2 -&gt; T1</li> <li>Example 2:</li> <li>S: R2(A), W2(A), R1(A), W1(A), R1(B), W1(B), R2(B), W2(B)</li> <li>A needs to be written by T2 first &amp; then needs to be read by T1</li> <li>B needs to be written by T1 first &amp; then needs to be read by T2</li> <li>Hence, it cannot be rearranged as T1 -&gt; T2 or T2 -&gt; T1</li> <li>So it is not conflict serializable</li> </ul>"},{"location":"database_system/transactions_and_schedules#conflict-equivalent","title":"Conflict Equivalent","text":"<ul> <li>Two schedules are conflict equivalent</li> <li>If one can be transformed to another by swapping non-conflicting operations</li> <li>In example 1, S &amp; S1 are conflict equivalent</li> </ul>"},{"location":"database_system/transactions_and_schedules#view-serializable","title":"View Serializable","text":"<ul> <li>A schedule is view serializable if it is view equivalent to a serial schedule</li> <li>Serial Schedule<ul> <li>Transactions are executed one after another without interleaving</li> </ul> </li> <li>View Equivalent<ul> <li>If two schedules produce the same final state of the database</li> <li>And ensure the same read/write behavior for all transactions</li> </ul> </li> <li>There are no overlapping transactions</li> <li>Schedules that are conflict serializable are always view serializale</li> <li>Conditions in both the schedules</li> <li>Read of initial value and write of final value must be same for a data item</li> <li>W -&gt; R conflict must be the same</li> </ul>"},{"location":"database_system/transactions_and_schedules#view-equivalence","title":"View Equivalence","text":"<ul> <li>Two schedules are view equivalent</li> <li>If they produce the same set of results when executed against the same state</li> <li>Order of any two conflicting operations in S1 should be same in S2</li> <li>Conditions</li> <li>Initial Read<ul> <li>If T1 reads the data item A in S1</li> <li>Then T1 should also read A in S2</li> </ul> </li> <li>Updated Read<ul> <li>If T1 reads A written by T2 in S1</li> <li>Then T1 should also read A written by T2 in S2</li> </ul> </li> <li>Final Write<ul> <li>If T1 performs the final write on A in S1</li> <li>Then T1 should also perform the final write on A in S2</li> </ul> </li> </ul>"},{"location":"database_system/transactions_and_schedules#recoverable-schedules","title":"Recoverable Schedules","text":"<ul> <li>Transactions commit only after all the transactions whose changes were read are committed</li> <li>It allows the system to return the database to a consistent state</li> <li>Example:</li> <li>T1 reads A, modifies and writes A</li> <li>T2 reads A, modifies and writes A</li> <li>T1 is committed</li> <li>T2 is committed (Committed after T1, A read by T2 was modified by T1)</li> <li>Cascading Schedule</li> <li>If a transaction fails, all other dependent transactions rolled back or aborted</li> <li>Cascadeless Schedule</li> <li>Transactions read values only after<ul> <li>All the transactions whose changes are to be read are committed</li> </ul> </li> <li>Avoids a series of transaction rollbacks due to abort of a single transaction</li> <li>Strict Schedule</li> <li>A transaction can read or write updated value of another transaction<ul> <li>Only after it is commited or aborted</li> </ul> </li> </ul>"},{"location":"database_system/transactions_and_schedules#non-recoverable-schedules","title":"Non Recoverable Schedules","text":"<ul> <li>If a transaction T2 reads and commits changes made by another transaction T1</li> <li>But later if that transaction T1 is aborted, the value read by T2 will be wrong</li> <li>Since T2 already committed, the schedule is non-recoverable</li> </ul>"},{"location":"database_system/concurrency_control","title":"Concurrency Control","text":"<ul> <li>To increase throughput and efficiency of the system</li> <li>Concurrent schedules &amp; transactions are used</li> <li>Concurrency Control Protocols</li> <li>Set of rules maintained to solve the concurrency control problems</li> <li>Ensures that schedules are serializable, recoverable and maybe cascadeless</li> <li>Categories of protocols</li> <li>Lock Based</li> <li>Graph Based</li> <li>Timestamp Ordering</li> <li>Multiple Granularity</li> <li>Multi-version</li> </ul>"},{"location":"database_system/concurrency_control#concurrency-problems","title":"Concurrency Problems","text":""},{"location":"database_system/concurrency_control#dirty-read-problem-write-read-conflict","title":"Dirty Read Problem (Write Read Conflict)","text":"<ul> <li>When one transaction updates an item but it fails to commit later</li> <li>Meanwhile, another transaction reads the updated value, creating an inconsistency</li> <li>Example</li> <li>T1 modifies database without committing the changes</li> <li>T2 reads the uncommitted data by T1</li> <li>T1 performs rollback</li> <li>To prevent them, SQL provides transaction isolation levels as discussed below</li> </ul>"},{"location":"database_system/concurrency_control#lost-update-problem","title":"Lost Update Problem","text":"<ul> <li>When two or more transactions modify the same data resulting in overwritten or lost updated data</li> <li>Example</li> <li>T1 reads value of an item from the database</li> <li>T2 starts and reads the same database item</li> <li>T1 updates the value and performs a commit</li> <li>T2 updates the same item based on the initial read and performs a commit</li> <li>Update committed by T1 gets overwritten by T2</li> </ul>"},{"location":"database_system/concurrency_control#non-repeatable-read","title":"Non-repeatable Read","text":"<ul> <li>When a transaction reads the same row twice and gets a different value each time</li> <li>This happens if another transaction updates the value between the two reads</li> </ul>"},{"location":"database_system/concurrency_control#phantom-read","title":"Phantom Read","text":"<ul> <li>When a transaction executes a query twice but it retrieves different rows</li> <li>This happens if another transaction adds new rows that match the search criteria</li> </ul>"},{"location":"database_system/concurrency_control#isolation-levels","title":"Isolation Levels","text":"<ul> <li>These specify how transactions should be isolated from one another</li> <li>Prevents the concurrency problems</li> <li>The choice of isolation level depends on specific requirements</li> <li>Higher isolation offers stronger data consistency</li> <li>But longer lock times and increased contention</li> <li>Leading to decreased concurrency and perrformance</li> <li>Read Uncommitted</li> <li>Allows to read uncommitted data from other transactions</li> <li>Can lead to dirty reads, non-repeatable reads, phantom reads</li> <li>Read Committed</li> <li>Allows to read only committed data (prevents dirty reads)</li> <li>Transaction holds a lock on the current row<ul> <li>And prevents operations from other transactions</li> </ul> </li> <li>Repeatable Read</li> <li>Ensures that a transaction always reads the same data for a given query</li> <li>Even if other transactions modify the data in the meantime</li> <li>Prevents dirty reads and non-repeatable reads</li> <li>Transaction holds read locks on the referencing rows<ul> <li>And write locks on the referenced rows</li> </ul> </li> <li>Serializable</li> <li>Ensures that transactions are executed serially</li> <li>Provides highest level of isolation</li> <li>Prevents dirty reads, non-repeatable reads, phantom reads</li> </ul>"},{"location":"database_system/concurrency_control#starvation","title":"Starvation","text":"<ul> <li>When transaction is not able to get the required resources</li> <li>And is continuously delayed or blocked</li> <li>This happens when other transactions are given priority</li> <li>Causes</li> <li>Waiting scheme for locked items is unfair (maybe priority queue)</li> <li>The same transaction is selected as victim repeatedly</li> <li>Resource leak</li> <li>Denial of service attack</li> <li>Solutions</li> <li>Increasing priority</li> <li>Modify victim selection algorithm</li> <li>First come first serve</li> <li>Wait die and wound wait schemes</li> <li>Timeout the waiting transaction after a certain amount of time</li> <li>Resource Reservation: Start execution only when all resources are allocated</li> <li>Preemption</li> <li>Dynamic lock allocation by analyzing the lock requests</li> <li>Parallelism</li> </ul>"},{"location":"database_system/concurrency_control#deadlock","title":"Deadlock","text":"<ul> <li>When two or more transactions are waiting for each other to release resources</li> <li>Both transactions require the lock being hold by the other and none can proceed</li> <li>Conditions</li> <li>Mutual exclusion</li> <li>Hold and wait</li> <li>No preemption</li> <li>Circular wait</li> <li>Avoidance</li> <li>Suitable for smaller database</li> <li>Aquire locks in the same order, wait for the previous transaction</li> <li>Detection</li> <li>Draw a wait for graph and check if there is a cycle</li> <li>Prevention</li> <li>Suitable for larger databases</li> <li>Wait die</li> <li>Wound wait</li> <li>Discussed in detail in timestamp ordering protocol</li> </ul>"},{"location":"database_system/concurrency_control_protocols","title":"Concurrency Control Protocols","text":""},{"location":"database_system/concurrency_control_protocols#lock-based-protocols","title":"Lock Based Protocols","text":"<ul> <li>Each transaction needs to acquire locks before accessing or modifying the data items</li> <li>Shared Lock</li> <li>Read lock, no modification allowed</li> <li>Allows multiple transactions to read the data simultaneously</li> <li>Exclusive Locks</li> <li>Write lock, allows updation</li> <li>Only one transaction can hold this lock on a data item at a time</li> <li>A transaction is allowed to upgrade or downgrade a lock if the conditions are met</li> <li>Simple lock based protocal (binary locking) don't guarantee serializability</li> <li>Additional protocols for positioning of locking &amp; unlocking operations are required</li> <li>Which gives rise to two phase locking protocol</li> <li>Starvation and deadlocks are possible</li> </ul>"},{"location":"database_system/concurrency_control_protocols#locking","title":"Locking","text":"<ul> <li>Lock manager manages the locking requests made by transactions</li> <li>It relies on the process of message passing between transactions and lock manager</li> <li>Lock table</li> <li>Hash table where names of data items are used as hashing index</li> <li>Every locked data item has a linked list associated with it</li> <li>Every node in the list represents a transaction that requested lock<ul> <li>Mode of lock requested (mutual/exclusive)</li> <li>Current status of the request (granted/waiting)</li> </ul> </li> <li>Collisions are handled by separate chaining</li> <li>A node is deleted after unlock or abort</li> </ul>"},{"location":"database_system/concurrency_control_protocols#two-phase-locking-protocol","title":"Two-Phase Locking Protocol","text":"<ul> <li>Phases</li> <li>Growing<ul> <li>The transaction starts acquiring locks before performing any modification to data items</li> <li>Once a lock is acquired, it cannot be released until the end of the execution</li> <li>Upgrading is allowed in growing phase only</li> </ul> </li> <li>Shrinking<ul> <li>The transaction releases all the acquired locks after all the modifications</li> <li>Once it starts releasing the locks, it cannot acquire any locks further</li> <li>Downgrading is allowed in shrinking phase only</li> </ul> </li> <li>Lock Point</li> <li>The point at which the growing phase ends</li> <li>That is, when a transaction takes the final lock</li> <li>Cascading Rollback is possible if the dependent transaction's commit fails</li> <li>To claim an exclusive (write) lock</li> <li>Transaction must acquire a shared (read) lock first</li> <li>And then upgrade it to an exclusive lock</li> <li>Problems</li> <li>Deadlock<ul> <li>Example: L1(A), L2(B), L1(B), L2(A)</li> <li>T1 granted A, T2 granted B</li> <li>T1 waiting for B, T2 waiting for A</li> </ul> </li> <li>Starvation</li> <li>Does not ensure recoverability</li> </ul>"},{"location":"database_system/concurrency_control_protocols#strict-2pl-protocol","title":"Strict 2PL Protocol","text":"<ul> <li>In 2PL, transactions can release any lock before committing</li> <li>In strict 2PL, transactions can release exclusive locks only after they commit</li> <li>Recoverable, Cascadeless</li> <li>Deadlocks are possible</li> <li>Most popular version of 2PL</li> </ul>"},{"location":"database_system/concurrency_control_protocols#rigorous-2pl-protocol","title":"Rigorous 2PL Protocol","text":"<ul> <li>Transactions can release a shared or exclusive lock only after they commit</li> <li>Recoverable, Cascadeless</li> <li>Deadlocks are possible</li> </ul>"},{"location":"database_system/concurrency_control_protocols#conservative-or-static-2pl-protocol","title":"Conservative or Static 2PL Protocol","text":"<ul> <li>The transaction should lock all the items before starting execution</li> <li>By predeclaring its read-set and write-set</li> <li>If any of the predeclared items cannot be locked<ul> <li>Then the transaction should not lock any of the items</li> <li>And wait till all the items are available for locking</li> </ul> </li> <li>Locks can be released at any time</li> <li>Not cascadeless, so does not ensure a strict schedule</li> <li>Deadlock free, since one deadlock condition (hold &amp; wait) is nullified</li> <li>Difficult to use in practice because predeclaration is not possible in many situations</li> </ul>"},{"location":"database_system/concurrency_control_protocols#graph-based-protocols","title":"Graph Based Protocols","text":"<ul> <li>Transactions are represented as nodes in a graph</li> <li>And the conflicts between them as edges</li> <li>If a transaction tries to acquire an exclusive lock on an item</li> <li>And if that is already locked by another transaction</li> <li>Then a conflict edge is added between their nodes</li> <li>When the transaction is completed, its edges are removed</li> <li>Before granting a lock, graph is checked for any cycles</li> <li>If a cycle exists, there is a conflict</li> <li>And one of the transactions needs to be rolled back to break the cycle</li> <li>It can handle complex transactions better than two-phase locking</li> <li>But it's computationally expensive</li> <li>And may not scale well for large databases</li> <li>Tree Based Protocol</li> <li>Simple implementation of graph based protocol</li> <li>Data item A can be locked by T1 only if the parent of A is currently locked by T1</li> <li>Data items can be unlocked at any time</li> </ul>"},{"location":"database_system/concurrency_control_protocols#multiple-granularity-locking","title":"Multiple Granularity Locking","text":"<ul> <li>Various concurrency control protocols perform synchronization on individual data items</li> <li>If a transaction need to access the entire database<ul> <li>It will need to lock each item individually</li> </ul> </li> <li>This is inefficient and it would be simpler if a single lock can lock the entire database</li> <li>But if another transaction needs to access a few data items, it should be able to do that</li> <li>Locking the entire database in that case will result in loss of concurrency</li> <li>Granularity is the size of the data item allowed to lock</li> <li>Multiple granularity means hierarchically breaking up the database into blocks</li> <li>That can be locked and can be tracked what needs to be locked &amp; in what fashion</li> <li>How does the system determine if the root node can be locked</li> <li>If it searches the entire tree, it will nullify the whole purpose of this locking scheme</li> <li>A more efficient way is to introduce a new lock mode (intention lock)</li> </ul>"},{"location":"database_system/concurrency_control_protocols#representation","title":"Representation","text":"<ul> <li>It can be represented graphically as a tree. Example:</li> <li>Root: Entire database</li> <li>1st Level: Areas within the database</li> <li>2nd Level: Files within each area (each file can have only one area)</li> <li>3rd Level: Records within each file</li> <li>Each node can be locked (shared or exclusive) individually</li> <li>When a node is locked, it implicitly locks all the descendants in the same mode</li> </ul>"},{"location":"database_system/concurrency_control_protocols#intention-locks","title":"Intention Locks","text":"<ul> <li>In addition to Shared (S) &amp; Exclusive (X) locks, multiple granularity has 3 additional locks</li> <li>This ensures serializability</li> <li>Intention-Shared (IS)</li> <li>Intention-Exclusive (IX)</li> <li>Shared &amp; Intention-Exclusive (SIX)</li> </ul>"},{"location":"database_system/concurrency_control_protocols#procedure-for-transaction-to-acquire-lock","title":"Procedure for transaction to acquire lock","text":"<ul> <li>Check the lock compatiblity</li> <li>Lock the root of the tree first in any mode</li> <li>Follows 2PL, so deadlocks are possible</li> <li>Locks are acquired top-down (root to leaf) and released bottom-up (leaf to root)</li> <li>Lock can be acquired only</li> <li>If the parent is locked</li> <li>If none of the children is locked</li> <li>Node can be locked in</li> <li>S, IS if the parent is in IX, IS</li> <li>X, IX, SIX if the parent is in IX, SIX</li> </ul>"},{"location":"database_system/concurrency_control_protocols#timestamp-based-protocols","title":"Timestamp Based Protocols","text":"<ul> <li>Each transaction has a timestamp attached to it</li> <li>The timestamps are usually assigned in the order of submission</li> <li>The conflicting pairs of operations can be resolved by their timestamps</li> <li>TS(T) \u2013 Timestamp of transaction T when submitted</li> <li>TS(W(X)): Latest timestamp when any transaction executed W(X) successfully</li> <li>TS(R(X)): Latest timestamp when any transaction executed R(X) successfully</li> </ul>"},{"location":"database_system/concurrency_control_protocols#deadlock-prevention","title":"Deadlock Prevention","text":"<ul> <li>Wait Die</li> <li>An older transaction should wait for a younger transaction</li> <li>If a younger transaction waiting for an older transaction<ul> <li>Younger transaction should be aborted and restarted with the same timestamp</li> </ul> </li> <li>Non-preemptive technique</li> <li>Wound Wait</li> <li>A younger transaction should wait for an older transaction</li> <li>If an older transaction is waiting for a younger transaction<ul> <li>Younger transaction should be aborted and restarted with the same timestamp</li> </ul> </li> <li>Preemptive technique</li> <li>In both cases, younger transaction is aborted</li> <li>Based on the assumption that it will waste less processing effort</li> </ul>"},{"location":"database_system/concurrency_control_protocols#timstamp-ordering-protocol","title":"Timstamp Ordering Protocol","text":"<ul> <li>Ensures that the conflicting operations do not violate the ordering</li> <li>If R(X) and W(X) are conflicting operations</li> <li>Then R(X) is processed before W(X) if and only if TS(T1) &lt; TS(T2)</li> <li>If a schedule doesn't follow a timestamp serializability, reject and rollback the transaction</li> <li>Each transaction is assigned a unique timestamp when it enters the system</li> <li>Ensuring that all operations follow a specific order</li> <li>Making the schedule conflict serializable and deadlock free</li> <li>Cascading rollbacks are possible</li> <li>If T2 occurs before T1</li> <li>Allowed Operations<ul> <li>R1(X), R2(X)</li> </ul> </li> <li>Not Allowed Operations<ul> <li>R1(X), W2(X)</li> <li>W1(X), R2(X)</li> <li>W1(X), W2(X)</li> </ul> </li> <li>Strict Timestamp Ordering</li> <li>A variation where the read or write operation is delayed</li> <li>Until the transaction that wrote the value of the data item is committed or aborted</li> </ul>"},{"location":"database_system/concurrency_control_protocols#working","title":"Working","text":"<ul> <li>If a transaction Ti issues a read(X) operation</li> <li>If TS(T) &lt; TS(W(X)): Abort and rollback</li> <li>If TS(T) &gt;= TS(W(X)): Execute W(X) and set TS(W(X)) to TS(T)</li> <li>All data-item timestamps updated</li> <li>If a transaction Ti issues a write(X) operation</li> <li>If TS(Ti) &lt; RTS(X): Operation rejected</li> <li>If TS(Ti) &lt; WTS(X): Operation rejected and Ti rolled back</li> <li>Else: Operation executed</li> </ul>"},{"location":"database_system/concurrency_control_protocols#thomas-write-rule-write-ahead-logging-protocol","title":"Thomas Write Rule (Write Ahead Logging Protocol)","text":"<ul> <li>Any modification to a database must be written to disk</li> <li>Before the control is returned to a user</li> <li>This ensures that database remains consistent and durable</li> <li>Modification of the basic timestamp ordering protocol</li> <li>Does not enforce conflict serializability</li> <li>But rejects fewer write operations by modifying the check operations for W(X)</li> <li>If T2 occurs before T1</li> <li>Allowed Operations<ul> <li>W1(X), W2(X)</li> <li>R1(X), R2(X)</li> </ul> </li> <li>Not Allowed Operations<ul> <li>R1(X), W2(X)</li> <li>W1(X), R2(X)</li> </ul> </li> </ul>"},{"location":"database_system/concurrency_control_protocols#working_1","title":"Working","text":"<ul> <li>If TS(R(X)) &gt; TS(T): Abort and rollback T</li> <li>If TS(W(X)) &gt; TS(T): Skip the write operation and continue</li> <li>Case of outdated of obsolete writes</li> <li>A transaction has already updated the value of X</li> <li>TO protocol aborts such a transaction</li> <li>Example Schedule: T2(R(X)), T1(W(X)), T2(W(X)) but T1 already wrote X</li> <li>Else: Execute W(X) and set TS(W(X)) to TS(T)</li> </ul>"},{"location":"database_system/recoverability_and_processing","title":"Recoverability and Processing","text":""},{"location":"database_system/recoverability_and_processing#recoverability","title":"Recoverability","text":"<ul> <li>Data can be lost or transactions can fail due to</li> <li>Transaction errors<ul> <li>Transaction irregularities or no longer acceptable</li> <li>May be aborted due to serializability violation or deadlock</li> </ul> </li> <li>System error (logical programming errors)</li> <li>Incorrect command execution, security breaches</li> <li>System crashes, network failures, disk failures, data corruption, viruses</li> <li>Catastrophic failures: fire, theft, overwriting by mistake</li> <li>Recovery techniques are heavily dependent upon a special file called system log</li> <li>It contains info about start and end of each transaction</li> <li>Keeps track of all operations that affect database values</li> </ul>"},{"location":"database_system/recoverability_and_processing#logging","title":"Logging","text":"<ul> <li>Record all the activities and transactions in the database</li> <li>Fields</li> <li>Transaction identifier</li> <li>Data item</li> <li>Old value</li> <li>New value</li> <li>Log based on operations</li> <li>T(i) start: Stores info when a transaction starts</li> <li>T(i) commit: Stores info when a transaction commits</li> <li>T(i) abort: Stores info when a transaction aborts</li> </ul>"},{"location":"database_system/recoverability_and_processing#undo-redo","title":"Undo &amp; Redo","text":"<ul> <li>All modifications must precede by the creation of a log record</li> <li>The system should be able to</li> <li>Undo the operation and set the data item to the old value</li> <li>Redo the operation and set the data item to the new value</li> <li>Redo operations should be idempotent (give the same result when performed again)</li> <li>Should not lead to creating duplicate entities</li> <li>After a system crash</li> <li>Undo the transaction if T-start is present but not T-commit or T-abort</li> <li>Redo the transaction if T-start and T-commit or T-abort is present</li> </ul>"},{"location":"database_system/recoverability_and_processing#checkpoints","title":"Checkpoints","text":"<ul> <li>Checkpoint logs keep track of the list of transactions active at the time of the checkpoint</li> <li>Any modifications by the transactions is written either prior or as part of the checkpoint</li> <li>After a crash, undo or redo needs to be applied only to the transactions in and after the checkpoint</li> </ul>"},{"location":"database_system/recoverability_and_processing#modification-techniques","title":"Modification Techniques","text":"<ul> <li>Deferred Update</li> <li>Transaction doesn't modify the database until partially committed</li> <li>Undo is not needed since the transaction won't have changed anything</li> <li>Redo maybe required for operations recorded in the local transaction workspace</li> <li>Immediate Update</li> <li>Transaction can modify the database while still in execution</li> <li>Both undo &amp; redo are required</li> <li>Caching/Buffering</li> <li>Disk pages that include data items that are to be updated are cached into main memory buffers</li> <li>Then are updated in memory before being written back to disk</li> <li>A collection of in-memory buffers called DBMS cache is kept under the control of DBMS</li> <li>A directory is used to keep track of the database items that are in buffer</li> <li>A dirty bit is associated with each buffer (1 if buffer is modified else 0)</li> <li>Shadow Paging</li> <li>When a transaction begins executing, the current directory is copied into a shadow directory</li> <li>When a page is to be modified, a shadow page is allocated in which changes are made</li> <li>When it is ready to become durable<ul> <li>All pages that refer to the original are updated to refer new replacement page</li> </ul> </li> </ul>"},{"location":"database_system/recoverability_and_processing#backup-techniques","title":"Backup Techniques","text":"<ul> <li>Full Database Backup</li> <li>Differential Backup</li> <li>Stores only the data changes that have occurred since the last full database backup</li> <li>For this, first a full database backup needs to be restored</li> <li>Transaction Log Backup</li> <li>Through this, the database can be recovered to a specific point in time</li> </ul>"},{"location":"database_system/recoverability_and_processing#olap-online-analytical-processing","title":"OLAP (Online Analytical Processing)","text":"<ul> <li>OLAP systems can analyze database information of multiple systems at the current time</li> <li>The primary goal is data analysis and not data processing</li> <li>Online query management system that consists of historical data</li> <li>Any type of data warehouse system is an OLAP system</li> <li>Tables are not normalized</li> <li>Relatively slow due to large amount of data</li> <li>Applications</li> <li>Used for data mining, analytics, decision making, big data</li> <li>Spotify analyzing songs to come up with personalized homepage and playlists</li> <li>Movie recommendation system in netflix</li> <li>Benefits</li> <li>Store planning, analysis, budgeting for business analytics within one platform</li> <li>Helps in handling large volumes of data<ul> <li>Which helps in enterprise-level business applications</li> </ul> </li> <li>Helps in applying security restrictions for data protection</li> <li>Provides multi-dimensional view of data</li> <li>Challenges</li> <li>Requires professionals to handle data due to complex modeling procedure</li> <li>Expensive to implement and maintain for large datasets</li> <li>Requires extraction and transformation of data for analysis which delays the system</li> <li>Updated on periodic basis and not real time</li> </ul>"},{"location":"database_system/recoverability_and_processing#types-of-olap-servers","title":"Types of OLAP Servers","text":"<ul> <li>Relational</li> <li>Data is stored in relational database</li> <li>Based on the premise that<ul> <li>Data need not be stored multi-dimensionally to be viewed multi-dimensionally</li> </ul> </li> <li>Multidimensional</li> <li>Data is stored on disks in a specialized multi-dimensional array structure</li> <li>Has advanced indexing and hashing to locate data and handle sparse arrays</li> <li>Fast data retrieval, optimal for slicing &amp; dicing, perform complex calculations</li> <li>Hybrid of Relational &amp; Multi-dimensional</li> <li>Transparent: Work with existing RDBMS without transfering data to a separate OLAP system</li> </ul>"},{"location":"database_system/recoverability_and_processing#oltp-online-transaction-processing","title":"OLTP (Online Transaction Processing)","text":"<ul> <li>OLTP systems administer day to day transactions in any organization</li> <li>The primary goal is data processing and not data analysis</li> <li>Online data modifying system that consists of operational current data</li> <li>Handles ACID properties during data transactions</li> <li>Tables are normalized</li> <li>Fast as the queries operate on 5% of data</li> <li>Example: ATM center, sending text message, online banking &amp; ticket booking &amp; shopping</li> <li>Benefits</li> <li>Allows users to read, write and delete data operations quickly</li> <li>Helps in increasing users &amp; transactions which helps in real-time access to data</li> <li>Helps in applying multiple security features</li> <li>Helps in making better decisions by providing accurate data or current data</li> <li>Provides data integrity, consistency, and high availability to data</li> <li>Challenges</li> <li>Limited analysis and reporting capability</li> <li>High maintenance costs because of frequent maintenance, backups &amp; recovery</li> <li>Some issues like duplicate or inconsistent data can occur</li> </ul>"},{"location":"database_system/indexing","title":"Indexing","text":"<ul> <li>Data structure technique to quickly locate and access data</li> <li>Minimizes disk accesses required for a query</li> <li>An index entry consists of the search key with value as the data reference</li> <li>Complex columns should not be indexed, it might decrease the performance instead</li> <li>Columns with large datasets but small classification should not be indexed</li> <li>For example, boolean columns since there will be large data for a single key</li> <li>Indexing 10K rows into true &amp; false can deplete performance</li> </ul>"},{"location":"database_system/indexing#indexing-mechanisms","title":"Indexing Mechanisms","text":"<ul> <li>File organization mechanisms followed by indexing methods to store data</li> </ul>"},{"location":"database_system/indexing#sequential-file-organization-or-ordered-index-file","title":"Sequential File Organization (Or Ordered Index File)","text":"<ul> <li>Dense index</li> <li>For every search key in the data file, there is an index record</li> <li>The record contains the search key and the reference to the first data record</li> <li>Sparse index</li> <li>The index record is present for only a few items in the data file</li> <li>The reference in each record points to a block</li> <li>To locate a record<ul> <li>We find the record with the largest search-key value less than or equal to the target</li> </ul> </li> <li>After jumping to the reference pointer<ul> <li>The file is searched sequentially for the target record</li> </ul> </li> <li>Number of accesses required = log(n) + 1, where n is the number of blocks</li> </ul>"},{"location":"database_system/indexing#hash-file-organization","title":"Hash File Organization","text":"<ul> <li>Indices are based on the values distributed uniformly across a range of buckets</li> <li>A hash function determines the bucket to which a value is assigned</li> <li>Clustered or Primary Index</li> <li>Similar records are grouped and indexes are created for these groups</li> <li>In some cases, index is created on non-primary key columns which may not be unique<ul> <li>In such cases, two or more columns are grouped to get unique values</li> </ul> </li> <li>Non-clustered or Secondary Index</li> <li>Nested index through virtual pointers</li> <li>Data is not physically stored in the order of the index</li> <li>Data is present in the leaf nodes</li> <li>Requires more time than clustered index to extract the data by following pointers</li> <li>Multilevel Index</li> <li>As database size grows, indices also grow</li> <li>As the index is stored in main memory, a single level index might become too large</li> <li>It segregates the main block into various smaller blocks<ul> <li>Which ultimately point to the data blocks</li> </ul> </li> <li>B and B+ trees</li> </ul>"},{"location":"database_system/indexing#b-tree","title":"B-Tree","text":"<ul> <li>For storing and searching large amounts of data</li> <li>Traditional binary search trees can become impractical</li> <li>Due to their poor performance and high memory usage</li> <li>Balanced Tree (B-Tree) is a type of self-balancing tree</li> <li>It maintains balance by ensuring that each node has a minimum number of keys</li> <li>This balance guarantees the time complexity of O(log(n))<ul> <li>Regardless of the initial shape of the tree</li> </ul> </li> <li>This is true for operations like insertion, deletion, and searching</li> <li>Can store a large number of keys in a single node</li> <li>This allows the tree to have a larger branching factor and shallower height</li> <li>This shallow height leads to less disk I/O and faster search &amp; insertion</li> <li>Node size is kept equal to disk block</li> <li>It's particularly well suited for storage systems with slow &amp; bulky data access</li> <li>Like hard drives, flash memory</li> <li>When number of keys is high, data is read from disk in form of blocks</li> <li>Example:</li> <li>(100)</li> <li>(35, 65)                              (130, 180)</li> <li>(10, 20) (40, 50) (70, 80, 90)      (110, 120) (140, 160) (190, 240, 260)</li> </ul>"},{"location":"database_system/indexing#properties","title":"Properties","text":"<ul> <li>All leaves are at the same level</li> <li>It's defined by the term minimum degree 't', which depends on disk block size</li> <li>All keys of a node are sorted in ascending order</li> <li>Number of keys in nodes</li> <li>Root: (1) to (2t - 1)</li> <li>Others: (t - 1) to (2t - 1)</li> <li>Number of children: Number of keys + 1</li> <li>Child between two keys k1 &amp; k2 contains all keys from k1 to k2</li> <li>Grows and shrinks from root unlike BST</li> <li>BSTs grow downward &amp; also shrink from downward</li> <li>Time Complexity for insert, delete, search = O(height) = O(log(n))</li> <li>Insertion only happens at leaf node</li> </ul>"},{"location":"database_system/indexing#insertion","title":"Insertion","text":"<ul> <li>Start from the root and traverse down till we reach a leaf node</li> <li>While traversing, keeping check if the next node has space</li> <li>If there's no space</li> <li>Split the leaf node into two and separate the mid</li> <li>Move the mid to the parent node (That's why B-tree grows up)</li> <li>Repeat this process for every iteration if there's no space</li> <li>Add the key in the leaf node</li> <li>Example:</li> <li>We need to insert 52 and we have: (40, 60) -&gt; (45, 50, 55)</li> <li>Shift 50 to parent &amp; insert 52: (40, 50, 60) -&gt; (45, 52, 55)</li> </ul>"},{"location":"database_system/indexing#deletion","title":"Deletion","text":"<ul> <li>Deletion is more complicated than insertion because a key can be deleted from any node</li> <li>When a key is deleted from an internal node, the node's children needs to be rearranged</li> <li>A node should not get too small during deletion</li> <li>Case 1: Key is in a leaf node -&gt; Delete the key</li> <li>Case 2: Key is in an internal node</li> <li>If the parent has at least t keys<ul> <li>Delete the predecessor of the key from parent node</li> <li>Replace the key with the predecessor in the current node</li> </ul> </li> <li>If the parent has fewer than t keys and the child has at least t keys<ul> <li>Then delete the successor of the key from the child node</li> <li>Replace the key with the successor in the current node</li> </ul> </li> <li>If both the parent and the child node has (t - 1) keys<ul> <li>Merge the current and the child node into the parent node</li> <li>The parent node will contain (2t - 1) keys</li> <li>Delete the key from the parent node</li> </ul> </li> <li>Case 3: Key is not in the current node</li> <li>Find the child that may contain the key</li> <li>If the child has only (t - 1) keys but has an immediate sibling with at least t keys<ul> <li>Move a key from the current node to the child</li> <li>Move a key from the child's sibling to the current node</li> </ul> </li> <li>If the child and its immediate siblings have (t - 1) keys<ul> <li>Merge the child with one sibling</li> <li>Move a key from the current node to the merged node as a median</li> </ul> </li> </ul>"},{"location":"database_system/indexing#b-tree_1","title":"B+ tree","text":"<ul> <li>Variation of B-tree where data pointers are stored only at the leaf node</li> <li>The leaf nodes</li> <li>Have an entry for every value of the search field</li> <li>Have a data pointer to the record (or the block that contains the record)</li> <li>Are linked together to provide ordered access to the search field to the records</li> <li>The internal nodes</li> <li>Are only used to guide the search and don't store any data pointer</li> <li>As a result, more key values can be stored in a node</li> <li>Hence, they have a different order than leaf nodes</li> <li>Some search field values from the leaf nodes are repeated in the internal nodes</li> <li>Hence takes more storage</li> <li>B tree stores the data pointers along with the key values in the internal nodes</li> <li>This reduces the number of entries that can be packed into a node</li> <li>And increases the number of levels which increases the search time</li> <li>B+ tree is very useful for range queries and bulk data retrieval</li> </ul>"},{"location":"database_system/indexing#bitmap-indexing","title":"Bitmap Indexing","text":"<ul> <li>Used to improve performance of read-only queries that involve large datasets</li> <li>Used for a most frequently used column with low cardinality</li> <li>Each distinct value in a column is assigned a bit vector</li> <li>The vector contains a bit for each row and represents the presence or absence of the value</li> </ul>"},{"location":"database_system/indexing#inverted-index","title":"Inverted Index","text":"<ul> <li>Used in information retrieval systems to efficiently retrieve documents or web pages</li> <li>Containing a specific term or set of terms</li> <li>Index is organized by terms (words) pointing to a list of documents</li> <li>Types</li> <li>Record level: Contains a list of references to documents for each word</li> <li>Word level: Also contains the positions of each word within a document</li> </ul>"},{"location":"database_system/file_organization","title":"File Organization","text":"<ul> <li>Data is stored in the form of tables in the database</li> <li>But in physical memory it is stored in the form of files</li> <li>File organization refers to logical relationships among various records that constitute the file</li> <li>Particularly with respect to identification and access to any specific record</li> </ul>"},{"location":"database_system/file_organization#types-of-file-organization","title":"Types of File Organization","text":"<ul> <li>Sequential File Organization</li> <li>Pile File Method: Records are stored sequentially in the order of insertion in tables</li> <li>Sorted File Method: Records are inserted in a sorted sequence based on primary or any other key</li> <li>We cannot jump on a particular record, but have to move in a sequential manner</li> <li>Heap File Organization</li> <li>Records are inserted at the end as data blocks</li> <li>If a data block is full, the new record is stored in some other block in the memory</li> <li>It may leave unused memory blocks</li> <li>B/B+ Tree File Organization</li> <li>Cluster File Organization</li> <li>Related tables or records are stored within the same file known as clusters</li> <li>Indexed clusters group records based on the cluster key<ul> <li>And hash clusters group on hash values of a key</li> </ul> </li> <li>These tables can be combined easily using join operation in the cluster file</li> <li>Low performance in large databases</li> <li>Indexed Sequential Access Method</li> <li>Data is stored sequentially but an index is maintained for faster access</li> <li>Not as efficient as fully indexed methods for random access</li> <li>Index maintainance can add overhead in insert &amp; update operation</li> </ul>"},{"location":"database_system/file_organization#hashing-file-organization","title":"Hashing File Organization","text":"<ul> <li>For larger databases with thousands &amp; millions of records, indexing becomes inefficient</li> <li>Because searching a specific record consumes more time</li> <li>Hashing can directly reach the location of a record without searching through indices</li> <li>Hash Table</li> <li>Its size is determined by the total volume of data records in database</li> <li>Each memory location in a hash table is called bucket</li> <li>Each bucket stores a disk block that contains multiple records</li> <li>Hash Function</li> <li>Mathematical function that computes the index or location within hash table for a specified record</li> <li>It determines the speed of fetching data</li> <li>If the hash index is already occupied, it's called collision</li> <li>Collision resolution techniques</li> <li>Chaining<ul> <li>Records are stored as an array or linked list within an index</li> <li>May result in bucket skew</li> <li>If the hash function keeps generating the same index large number of times</li> <li>The remanining data buckets will store minimal data</li> </ul> </li> <li>Open Addressing or Closed Hashing<ul> <li>Store the data in the next available sloto</li> <li>Techniques like linear probing, quadratic probing, double hashing can be used to find it</li> </ul> </li> <li>Types of Hashing in DBMS</li> <li>Static Hashing<ul> <li>Records are directly mapped to a bucket's address</li> </ul> </li> <li>Dynamic Hashing<ul> <li>Records are first mapped to a directory and then mapped to the buckets</li> <li>Data buckets can be added and removed on demand dynamically</li> <li>The buckets grow &amp; shrink according the size of data records</li> <li>Example: If depth is 2, consider 2 LSB as the directory</li> <li>If hash index is 1100110, the directory will be 10</li> </ul> </li> </ul>"},{"location":"database_system/file_organization#raid-redundant-arrays-of-independent-disks","title":"RAID (Redundant Arrays of Independent Disks)","text":"<ul> <li>Combination of multiple disks for increased performance and data redundancy</li> <li>In case of disk failure, we can retrieve the data backed up on another disk</li> <li>Key evaluation points for RAID system</li> <li>Reliability: How many disk faults can it tolerate</li> <li>Availability: What fraction of session time is the system in uptime mode</li> <li>Performance: How good is response time &amp; throughput</li> <li>Capacity: How much useful capacity is available to user given a set of disks</li> <li>To the host system, it appears as a single big disk of linear array of blocks</li> <li>This allows older technologies to be replaced by RAID</li> <li>Levels</li> <li>0: Stripping</li> <li>1: Mirroring</li> <li>2: Bit level stripping with dedicated parity</li> <li>3: Byte level stripping with dedicated parity</li> <li>4: Block level stripping with dedicated parity</li> <li>5: Block level stripping with distributed parity</li> <li>6: Block level stripping with two parity bits</li> </ul>"},{"location":"object_oriented_programming","title":"Object Oriented Programming","text":"<ul> <li>Introduction</li> </ul>"},{"location":"object_oriented_programming/introduction","title":"Introduction","text":"<ul> <li>Break down requirements into classes, functionalities, behaviour</li> <li>Make projects more manageable and predictable</li> <li>Modularization and reusability</li> <li>Static: Belongs to class rather than instance</li> <li>Memory efficient</li> <li>Make common/fixed member static</li> <li>Can be invoked without creating instance/object</li> </ul>"},{"location":"object_oriented_programming/introduction#building-blocks","title":"Building Blocks","text":""},{"location":"object_oriented_programming/introduction#class","title":"Class","text":"<ul> <li>Represents a concept or logical entity</li> <li>Template or blueprint to create objects</li> <li>Non primitive data type</li> <li>Members</li> <li>Objects, methods, instance variables, constructors</li> <li>Access modifiers (public, private, protected, etc.)</li> </ul>"},{"location":"object_oriented_programming/introduction#object","title":"Object","text":"<ul> <li>Instance of a class with allocated memory</li> <li>An entity with identity (unique name), state (data) and behaviour (methods)</li> <li>Can be physical or logical</li> </ul>"},{"location":"object_oriented_programming/introduction#attribute","title":"Attribute","text":"<ul> <li>When objects are instantiated, individual objects contain data that is stored in attributes</li> <li>The state of an object is defined by the data in the object's attributes</li> </ul>"},{"location":"object_oriented_programming/introduction#method","title":"Method","text":"<ul> <li>Represents behaviors and performs actions</li> <li>Promotes reusability and keeps functionality encapsulated inside an object</li> <li>Manipulates object data or attributes</li> </ul>"},{"location":"object_oriented_programming/introduction#principles","title":"Principles","text":""},{"location":"object_oriented_programming/introduction#encapsulation","title":"Encapsulation","text":"<ul> <li>Integration of data and operations in a class</li> <li>Hiding functional details from object</li> <li>Providing mechanics without the overhead of understanding</li> </ul>"},{"location":"object_oriented_programming/introduction#abstraction","title":"Abstraction","text":"<ul> <li>Incomplete class with described but unimplemented operations</li> <li>Implements functionality from abstract class</li> <li>Has-a relationship</li> <li>Interface \u2013 blueprint of class</li> </ul>"},{"location":"object_oriented_programming/introduction#inheritance","title":"Inheritance","text":"<ul> <li>Generalizing entities</li> <li>Parent-child relationship or Is-a relationship</li> <li>Inherits attributes and methods of the parent class</li> <li>Extends functionality of the parent class</li> <li>Adds additional attributes &amp; behaviors</li> </ul>"},{"location":"object_oriented_programming/introduction#polymorphism","title":"Polymorphism","text":"<ul> <li>Multiple definitions of the same method</li> <li>Method Overloading: Differentiating behavior using number of arguments or data type</li> <li>Method Overriding: Modifying behavior in child class</li> </ul>"},{"location":"operating_system","title":"Operating System","text":"<ul> <li>Introduction</li> <li>System Structure</li> <li>Process Management</li> <li>Process Scheduling</li> <li>Process Synchronization</li> <li>Process Synchronization Solutions</li> <li>Process Synchronization Application</li> <li>Thread Management</li> <li>Resource Allocation</li> <li>Memory</li> <li>Memory Management</li> <li>Virtual Memory</li> <li>Storage Management</li> </ul>"},{"location":"operating_system/introduction","title":"Introduction","text":"<ul> <li>Interface between users and hardware</li> <li>Provides an environment to execute programs in a convenient and efficient manner</li> <li>Prevents interfering with proper operation of a system</li> <li>A program running at all times (kernel), with all else being application programs</li> <li>Provides convenience, efficiency (of using resource), throughput (tasks per unit time)</li> <li>Supports developing new system functions without interfering with the system</li> </ul>"},{"location":"operating_system/introduction#responsibilities","title":"Responsibilities","text":"<ul> <li>Execution of processes (management, scheduling, synchronization)</li> <li>Allocation of resources &amp; services (memory, processors, devices, data)</li> <li>Management of resources (CPU, memory, files)</li> </ul>"},{"location":"operating_system/introduction#characteristics","title":"Characteristics","text":"<ul> <li>Device Management: Tracks all devices, and decides which process gets access, when &amp; for how much time</li> <li>Processor Management: Allocates processor to process and de-allocates when no longer required or job is done</li> <li>Memory Management: Tracks &amp; allocates primary memory</li> <li>Storage Management: Stores data in various tracks of hard drive</li> <li>File Management: Allocates &amp; de-allocates resources</li> <li>System Performance: Records delays between requests of a service and the system</li> <li>Job Accounting: Tracks time &amp; resources used by various jobs</li> <li>Error Detection &amp; Debugging: Dumps, traces, error messages, etc.</li> <li>Security management: Prevents unauthorized access by applications &amp; users</li> <li>Compiles &amp; translates high level language to machine language</li> <li>Provides loader to move compiled code to memory for execution</li> <li>Provide routines that handles details of I/O programming</li> </ul>"},{"location":"operating_system/introduction#computer-system","title":"Computer System","text":"<ul> <li>User Interface: Users, application programs</li> <li>System: Utilities, system programs (compilers, loaders, editors), OS</li> <li>Extended Machine: Context save, dispatching, swapping, I/O initiation</li> <li>Hardware: Machine language, micro-programming, CPU, memory, devices</li> </ul>"},{"location":"operating_system/introduction#drivers-for-hardware","title":"Drivers for Hardware","text":"<ul> <li>I/O</li> <li>I/O traffic controller keeps track of status of devices</li> <li>Each device has a handler that resides in a separate process associated with that device</li> <li>It has memory management that includes buffering, caching, spooling and a device driver interface</li> <li>Assemblers</li> <li>Converts an assembly code to object/machine code &amp; instructions required by loader</li> <li>Compiler</li> <li>Converts all the given high level code to machine code and then executes</li> <li>Examples: C, C++, Rust, Go</li> <li>Interpreter</li> <li>Converts high level code to machine code line by line and simultaneously executes it</li> <li>Examples: Python, Ruby</li> <li>Loader</li> <li>A routine that loads an object/machine program in memory and prepares for execution</li> </ul>"},{"location":"operating_system/introduction#components-of-os","title":"Components of OS","text":"<ul> <li>Shell</li> <li>Outermost layer that handles user interaction</li> <li>Kernel</li> <li>Core component that provides services to other components</li> <li>Primary interface between OS &amp; hardware that manages system resources</li> <li>Addresses low level functions<ul> <li>I/O management, device drivers, memory management, application management</li> <li>System calls, process &amp; cpu scheduling</li> </ul> </li> </ul>"},{"location":"operating_system/introduction#types-of-os","title":"Types of OS","text":"<ul> <li>Batch</li> <li>Groups jobs into batches based on similar requirements</li> <li>For example, payroll &amp; bank systems</li> <li>Single Tasking</li> <li>Multi Programming</li> <li>Can execute multiple programs in main memory</li> <li>Multi Tasking</li> <li>Mult-programming OS having round robin scheduling</li> <li>Preemptive: OS can interrupt and switch to another process</li> <li>Cooperative: OS never interrupts to switch to another process</li> <li>Multi Processing</li> <li>Multiple CPUs are used for execution</li> <li>Time Sharing</li> <li>Each task is given some time to execute</li> <li>Processor's time is shared among multiple users</li> <li>Switching jobs is very fast</li> <li>Distributed</li> <li>Multiple computers connected via high-speed buses and share resources</li> <li>Centralized OS over multiple networks that uses single communication channel</li> <li>Network</li> <li>Independent systems connected over a single network and share resources</li> <li>Real Time</li> <li>Processes data and events that have critically defined time contraints</li> <li>Provides ultra-fast performance</li> </ul>"},{"location":"operating_system/introduction#memory","title":"Memory","text":""},{"location":"operating_system/introduction#primary-memory-ram-rom","title":"Primary Memory: RAM &amp; ROM","text":"<ul> <li>RAM (Random Access Memory)</li> <li>Main memory or read-write memory</li> <li>Temporarily stores the data that's currently being used or processed</li> <li>Volatile Memory: Data is lost when power is turned off</li> <li>Faster than ROM &amp; Consumes less power than secondary memory</li> <li>Data can be accessed and edited quickly</li> <li>ROM (Read Only Memory)</li> <li>Permanently stored memory</li> <li>Non-Volatile Memory</li> <li>Data cannot be modified easily</li> <li>Used to stored: BIOS (Basic Input/Output System), firmwares for hardware devices</li> <li>Used in embedded systems, calculators, peripheral devices</li> <li>Consumes less power than secondary memory</li> </ul>"},{"location":"operating_system/introduction#secondary-memory-hard-drive-ssd-usb","title":"Secondary Memory: Hard-drive, SSD, USB","text":""},{"location":"operating_system/introduction#cpu-registers","title":"CPU Registers","text":"<ul> <li>A CPU register stores memory addresses, which is how a processor accesses data from RAM</li> <li>One bit in a register can reference an individual byte in memory</li> <li>Based on how much memory can be accessed by a CPU register, there are 32-bit &amp; 64-bit processors</li> <li>32-bit<ul> <li>Can access 2^32 memory addresses (4 GB of RAM or physical memory)</li> <li>For more than 4 GB of RAM, the system should be 64-bit</li> </ul> </li> <li>64-bit<ul> <li>Can access 2^64 memory addresses (17 * 10^9 GB of RAM or physical memory)</li> </ul> </li> </ul>"},{"location":"operating_system/introduction#system-startup","title":"System Startup","text":""},{"location":"operating_system/introduction#bios-basic-input-output-system","title":"BIOS (Basic Input Output System)","text":"<ul> <li>Initialization</li> <li>BIOS is loaded from ROM and initialises POST</li> <li>POST (Power On Self Test)</li> <li>Initializes hardware devices, runs checks and handles bootable device</li> <li>Bootloader</li> <li>BIOS searches for Master Boot Record (MBR) in 1st sector.</li> <li>MBR contains the code that loads OS called bootloader (LILO, GRUB in Linux)</li> <li>Bootloader is pulled into memory and started</li> <li>Bootloader loads OS in memory</li> <li>Kernel</li> <li>OS starts running and initializes hardware drivers, and then launches kernel</li> <li>Kernel starts the init system</li> <li>Init</li> <li>Determines the run-level of the system (single user, multi user with network, without network, etc)</li> <li>Starts services daemons that support networking, display, devices (keyboard, mouse)</li> </ul>"},{"location":"operating_system/introduction#uefi-unified-extensible-firmware-interface","title":"UEFI (Unified Extensible Firmware Interface)","text":"<ul> <li>Initialization</li> <li>Doesn't look for MBR</li> <li>Maintains a list of valid boot volumes called EFI service partitions</li> <li>POST</li> <li>UEFI scans all of the bootable storage devices for GUID Partition Table (GPT)</li> <li>GPT is an improvement over MBR</li> <li>GPT</li> <li>Doesn't contain boot loader</li> <li>UEFI scans GPT for EFI service partition to boot from</li> <li>Directly loads OS from the right partition</li> <li>If it fails, goes to BIOS type booting called legacy boot (backward compatible)</li> </ul>"},{"location":"operating_system/introduction#bios-vs-uefi","title":"BIOS vs UEFI","text":"<ul> <li>BIOS runs in 16-bit mode, UEFI runs in 32-bit &amp; 64-bit mode</li> <li>BIOS only supports drives less than 2TB, UEFI has much higher limit</li> <li>UEFI comes with improved boot times, efficient power management, and support for larger hard drives &amp; partitions</li> <li>BIOS is stored in ROM, UEFI is stored in non-volatile memory on motherboard</li> <li>BIOS loads OS from bootloader, UEFI directly loads OS from hard drive</li> </ul>"},{"location":"operating_system/system_structure","title":"System Structure","text":""},{"location":"operating_system/system_structure#kernel-operations","title":"Kernel Operations","text":"<ul> <li>Kernel mode (mode bit 0)</li> <li>CPU can execute certain instructions only in kernel mode (privilege instructions)</li> <li>Privilege instructions usually peform operations that required direct access to hardware or privileged resources</li> <li>Example: setting up memory mapping, accessing I/O devices, remove a process from memory</li> <li>Context Switch</li> <li>User mode (mode bit 1)</li> <li>Prevents user program from interfering with OS program</li> <li>Non privileged instructions<ul> <li>Performing computations, accessing user-level resources like files &amp; memory, managing process control</li> </ul> </li> <li>Concept of modes can be extended beyond two</li> <li>Requires more than a single bit mode CPU that support virtualization</li> <li>One of these extra bits is used to indicate when virtual machine manager (VMM) is in control</li> <li>VMM has more privileges than user program but not so many as full kernel</li> </ul>"},{"location":"operating_system/system_structure#system-call","title":"System call","text":"<ul> <li>Programmatic way for a program to request a service from kernel</li> <li>Program is temporarily switched from user mode to kernel mode</li> <li>Implemented in the form of software interrupts</li> <li>Which causes hardware's interrupt handler to transfer control to an appropriate interrupt handler (part of OS)</li> <li>And switches the bit mode to kernel mode</li> <li>Interrupt handler</li> <li>Checks which interrupt was generated and additional parameters (passed through registers)</li> <li>Then calls appropriate kernel service routine to handle the service requested by service call</li> <li>Illegal instuctions are trapped and control is transferred to OS to issue error message &amp; log</li> </ul>"},{"location":"operating_system/system_structure#monolithic-kernel","title":"Monolithic Kernel","text":"<ul> <li>All OS services run in kernel space and share the same memory space</li> <li>Faster than micro-kernel due to direct calls &amp; same memory space</li> <li>If any service fails, it leads to entire system failure</li> <li>Structure</li> <li>Application (Outside Kernel)</li> <li>VFS, System calls</li> <li>IPC, File System</li> <li>Scheduler, Virtual Memory</li> <li>Device driver, Dispatcher</li> <li>Hardware (Outside Kernel)</li> </ul>"},{"location":"operating_system/system_structure#micro-kernel","title":"Micro-Kernel","text":"<ul> <li>Provides only the most basic services (memory management, process scheduling)</li> <li>Reduces the attack surface making it more secure &amp; stable</li> <li>Other services (device drivers, file systems) are implemented as user level processes</li> <li>They communicate with kernel using message passing rather than shared memory</li> <li>Easier to add or remove services making it more modular &amp; flexible but can increase complexity</li> <li>Message passing can be slower than direct system calls in monolithic kernel</li> </ul>"},{"location":"operating_system/system_structure#kernel-io-subsystem","title":"Kernel I/O Subsystem","text":"<ul> <li>Services provided: scheduling, caching, spooling, device reservation, error handling</li> <li>I/O Scheduling</li> <li>Each device has a wait queue for requests</li> <li>When an application issues a blocking I/O system call, it's placed in the queue of the device</li> <li>I/O scheduler rearranges the order to improve the efficiency</li> <li>Buffering</li> <li>Memory area that stores data being transferred between devices or a device &amp; an application</li> <li>Copes with speed mismatch between producer &amp; consumer</li> <li>Provides adaptation for data with different data-transfer sizes</li> <li>Supports copy semantic for the application I/O<ul> <li>Copy semantic</li> <li>If an application wants to write data from buffer to a disc</li> <li>It calls write() system call providing pointer to the buffer<ul> <li>And an integer specifying number of bytes to write</li> </ul> </li> </ul> </li> <li>Caching</li> <li>Fast memory that holds a copy of data for faster access</li> <li>Spooling</li> <li>A buffer that holds the output of a device that cannot accept interleaved data streams</li> <li>For example, a printer where several applications send output concurrently<ul> <li>Without mixing their outputs</li> </ul> </li> </ul>"},{"location":"operating_system/process_management","title":"Process Management","text":"<ul> <li>Program: Collection of instructions that performs a specific task when executed by a computer</li> <li>Process</li> <li>Program in execution with allocated time and resources</li> <li>Can have multiple dynamic instances of the program in execution</li> <li>Process sections</li> <li>Stack: Temporary data like function parameters, return addresses, local variables</li> <li>Heap: Dynamically alloted memory to process during its run time, stores functions</li> <li>Text: Current activity represented by program counter, contents of processor registers</li> <li>Data: Global and static variables</li> <li>Process groups: parent, children, fork, exec, merge</li> </ul>"},{"location":"operating_system/process_management#process-states","title":"Process States","text":"<ul> <li>OS maintains separate queue of PCB for each state</li> <li>New: Process being created in secondary memory</li> <li>Ready: After creation, process is loaded in main memory and marked ready for execution</li> <li>Run: Currently running in CPU</li> <li>Wait (or Block): Requesting access for I/O or critical region</li> <li>Complete (or Terminated): Execution completed and PCB deleted, allocated resources will be released</li> <li>Suspended Ready: Ready process swapped out of main memory, usually when ready queue is full</li> <li>Suspended Wait: Wait process swapped out of main memory, usually when wait queue is full</li> </ul>"},{"location":"operating_system/process_management#states-for-systems","title":"States for Systems","text":"<ul> <li>Single Tasking Systems: not running, running</li> <li>Multi-programming Systems: ready, running, wait</li> <li>5-States Model (general): new, ready, running, wait, terminated</li> <li>7-States Model: new, ready, running, wait, terminated, suspend ready, suspend wait</li> </ul>"},{"location":"operating_system/process_management#context-switching","title":"Context Switching","text":"<ul> <li>Saving context of one process into PCB and loading context of another process</li> <li>Unloaded process is marked from running to ready</li> <li>It happens when</li> <li>High priority task comes to ready state</li> <li>Interrupt occurs</li> <li>Sometimes when user &amp; kernel mode switch<ul> <li>If another process carries out privileged instructions</li> </ul> </li> <li>Preemptive CPU scheduling</li> </ul>"},{"location":"operating_system/process_management#cpu-vs-io-bound","title":"CPU vs I/O Bound","text":"<ul> <li>CPU bound process: Requires more CPU time (spends more time in running state)</li> <li>I/O bound process: Requires more I/O time (spends more time in waiting state)</li> </ul>"},{"location":"operating_system/process_management#process-control-block-pcb","title":"Process Control Block (PCB)","text":"<ul> <li>Pointer: Retains current position when switched from one state to another</li> <li>Process state</li> <li>PID</li> <li>PC (Program counter): Pointer to next instruction</li> <li>CPU registers: Current working variables</li> <li>CPU scheduling info: Privileges, priority</li> <li>Memory management info: Page table, memory limits, segment table</li> <li>Accounting info: CPU usage, time limits, execution ID</li> <li>IO status</li> </ul>"},{"location":"operating_system/process_scheduling","title":"Process Scheduling","text":""},{"location":"operating_system/process_scheduling#timings","title":"Timings","text":"<ul> <li>Arrival Time: At which arrives in ready queue</li> <li>Completion Time: At which execution is completed</li> <li>Burst Time: Required for CPU execution</li> <li>Turnaround time: Arrival to Completion</li> <li>Waiting time: Time spent in ready queue waiting (Turnaround - Burst)</li> <li>Response time: Submission to first response</li> <li>Throughput: Number of processes that complete execution per unit time</li> </ul>"},{"location":"operating_system/process_scheduling#objectives","title":"Objectives","text":"<ul> <li>Maximum utilization of CPU (percentage in use)</li> <li>Fair allocation of CPU</li> <li>Maximum throughput</li> <li>Minimum turnaround time</li> <li>Minimum waiting time and avoid starvation</li> <li>Minimum response time</li> </ul>"},{"location":"operating_system/process_scheduling#categories","title":"Categories","text":"<ul> <li>Non-preemptive</li> <li>Process is removed from CPU only when it has finished execution or switches to wait state</li> <li>High throughput rate</li> <li>Bugs can freeze up the system</li> <li>Wastes CPU time while the process is interacting with I/O</li> <li>Preemptive</li> <li>Process runs for a limited amount of time in CPU and then switched</li> <li>Better average response time</li> <li>Avoids starvation</li> <li>Overhead of more context switching</li> </ul>"},{"location":"operating_system/process_scheduling#schedulers","title":"Schedulers","text":"<ul> <li>Long Term (Job Scheduler)</li> <li>Which process should be brought in ready queue</li> <li>How many processes should be kept in ready state (decides degree of multi-programming)</li> <li>Maintains balance between CPU bound &amp; I/O bound processes</li> <li>Once a decision is taken, it lasts for a long time</li> <li>Short Term (CPU Scheduler)</li> <li>Which process should be executed next (scheduling algorithms are used)</li> <li>Calls dispatcher</li> <li>Runs frequently</li> <li>Medium Term (Swapping Scheduler)</li> <li>Used for swapping (moving process from main to secondary memory &amp; vice versa)</li> <li>Reduces degree of multiprogramming</li> </ul>"},{"location":"operating_system/process_scheduling#dispatcher","title":"Dispatcher","text":"<ul> <li>Module that gives control of CPU to the process selected by scheduler</li> <li>Responsible for moving process from ready to run state &amp; vice versa</li> <li>Takes care of switching context, switching to user mode, jumping to proper location in user pogram</li> </ul>"},{"location":"operating_system/process_scheduling#convoy-effect","title":"Convoy Effect","text":"<ul> <li>Few slow processes slow down the entire system</li> <li>Solution: preemptive algorithms</li> <li>Example</li> <li>I/O bound process runs in CPU and moves to I/O</li> <li>CPU bound process runs in CPU</li> <li>I/O bound process moves to CPU &amp; waits for CPU bound process</li> <li>CPU bound process runs to I/O</li> <li>I/O bound process moves to I/O &amp; waits for CPU bound process</li> </ul>"},{"location":"operating_system/process_scheduling#priority-inversion","title":"Priority Inversion","text":"<ul> <li>Happens when a high priority task ends up waiting for a low priority task</li> <li>Example</li> <li>We have 3 tasks defined by priority: L (Low), M (Medium), H (High)</li> <li>H is waiting on L for I/O</li> <li>So M will run first, then L, and then finally H</li> <li>Priority Inheritance</li> <li>Process holding the shared resource inherits the priority of highest priority process waiting for it</li> <li>This is done only till the lock is released</li> <li>So L will run first, then H, and then finally M</li> </ul>"},{"location":"operating_system/process_scheduling#algorithms","title":"Algorithms","text":""},{"location":"operating_system/process_scheduling#first-come-first-serve-fcfs","title":"First Come First Serve (FCFS)","text":"<ul> <li>Also known as First In First out (FIFO)</li> <li>Waiting time is high</li> <li>Convoy effect can happen (Few slow processes slow down the entire system)</li> <li>Used by other algorithms in case of conflict</li> </ul>"},{"location":"operating_system/process_scheduling#shortest-job-first-sjf","title":"Shortest Job First (SJF)","text":"<ul> <li>Burst time can't be known in advance but can be approximated</li> <li>Process size</li> <li>Process type<ul> <li>OS process: compiler, program manager</li> <li>User process: editors, utility software</li> <li>Interactive process: which have high I/O frequency</li> </ul> </li> <li>Can approximate by averaging last run-times</li> <li>Minimum waiting time among all algorithms</li> <li>Starvation can happen if short jobs keep coming</li> <li>Starvation can be solved using ageing, but defining ageing rate can be challenging</li> <li>Preemptive version: Shortest Remaining Time First (SRTF)</li> </ul>"},{"location":"operating_system/process_scheduling#longest-job-first-ljf","title":"Longest Job First (LJF)","text":"<ul> <li>May lead to convoy effect due to high average waiting time &amp; average turnaround time</li> <li>Preemptive version: Longest Remaining Job First (LRJF)</li> </ul>"},{"location":"operating_system/process_scheduling#priority-scheduling","title":"Priority Scheduling","text":"<ul> <li>If a higher priority process comes, current process is suspended</li> <li>May lead to starvation (Can be solved using ageing or dynamic priority)</li> <li>Priority inversion can happen (Low priority process holds a resource required by high priority process)</li> <li>Inversion avoidance techniques (priority inheritance, priority ceiling protocals) can make it more complicated</li> </ul>"},{"location":"operating_system/process_scheduling#round-robin-rr","title":"Round Robin (RR)","text":"<ul> <li>Preemptive version of FCFS</li> <li>Fixed time slots/quantum/slice over all the processes in a circular fashion</li> <li>High response time for high time quantum</li> <li>High context switch overhead for low time quantum</li> <li>High wait time and reduced throughput depending on time quantum</li> <li>Deciding perfect time quantum is a task</li> </ul>"},{"location":"operating_system/process_scheduling#selfish-round-robin-srr","title":"Selfish Round Robin (SRR)","text":"<ul> <li>Round robin that give better service to existing processes than the new ones</li> <li>Processes in ready list are partitioned into: New and Accepted</li> <li>Priority of new processes increases at rate 'a' and that of accepted processes increases at rate 'b'</li> <li>When priority of a new process reaches that of an accepted process, it becomes an accepted process</li> <li>Poor response time and priority handling</li> </ul>"},{"location":"operating_system/process_scheduling#high-response-ratio-next-hrrn","title":"High Response Ratio Next (HRRN)","text":"<ul> <li>Modification of SJF to reduce starvation</li> <li>Response Ratio = (Waiting Time + Burst Time) / Burst Time</li> </ul>"},{"location":"operating_system/process_scheduling#multilevel-queue","title":"Multilevel Queue","text":"<ul> <li>Divides the ready queue into several separate queues (having their own priority)</li> <li>Different types of processes are queued based on their priority</li> <li>Each queue uses its own scheduling algorithm</li> <li>Starvation may happen</li> <li>Example:</li> <li>System Processes: CPU itself has its processes</li> <li>Interactive Processes: Processes with the same type of interaction</li> <li>Batch Processes: Collecting similar programs in a batch before executing</li> </ul>"},{"location":"operating_system/process_scheduling#multilevel-queue-scheduling-with-feedback","title":"Multilevel Queue Scheduling with Feedback","text":"<ul> <li>Allows processes to move between queues</li> <li>More CPU overhead and complexity</li> <li>Useful because burst time approximation may become more accurate later</li> </ul>"},{"location":"operating_system/process_synchronization","title":"Process Synchronization","text":"<ul> <li>Communication/Coordination/Concurrency control</li> <li>Coordination of execution of multiple processes that use shared resources</li> <li>Ensures that shared resources are accessed in a controlled and predictable manner</li> <li>Resolves the problem of race condition, inconsistency, deadlocks</li> <li>Process types based on synchronization</li> <li>Independent: Execution does not affect other processes</li> <li>Cooperative: Execution affects other processes</li> <li>Goals</li> <li>Avoid race conditions</li> <li>Achieve rules for critical section</li> <li>Performance</li> </ul>"},{"location":"operating_system/process_synchronization#ipc-inter-process-communication","title":"IPC (Inter Process Communication)","text":"<ul> <li>Mechanism through which processes can communicate with each other and synchronize their actions</li> <li>Communication mediums: Shared memory, Message passing</li> </ul>"},{"location":"operating_system/process_synchronization#communication-methods","title":"Communication Methods","text":"<ul> <li>Pipes</li> <li>Unidirectional (similar to keyboard)</li> <li>Data is usually buffered till it's processed by receiver</li> <li>Message Queuing</li> <li>Used to send &amp; receive messages between processes</li> <li>Messages are coordinated via API</li> <li>Semaphores</li> <li>Controls access to shared resource and avoids race condition</li> <li>Shared memory</li> <li>Interchange of data through a defined area of memory</li> <li>Sockets</li> <li>Network communication between processes running on different hosts</li> <li>Allows for system independent connection</li> <li>Each endpoint of a communication is a socket</li> <li>Concatenation of IP address and port</li> <li>Remote Procedural Calls (RPC)</li> <li>Used for distributed computing</li> <li>Allows processes on different hosts to call procedures on each other</li> <li>Program allows a procedure to execute on different address space</li> <li>Primary client-server is implied<ul> <li>Remote process maintains a server component</li> <li>Client processes send messages and get the output</li> </ul> </li> <li>When making a RPC call<ul> <li>The calling environment is suspended and procedure parameters are transferred across the network</li> <li>Procedure is executed on the target environment</li> <li>After execution, the results are transferred back to the calling environment</li> <li>Execution resumes in the calling environment as if returning from a regular procedure call</li> </ul> </li> </ul>"},{"location":"operating_system/process_synchronization#shared-memory","title":"Shared Memory","text":"<ul> <li>A process generates info and keeps it as a record in shared memory</li> <li>Other processes can check this record and use the info</li> <li>Example: Producer-Consumer problem where producer puts items in a common buffer and consumer picks them up</li> </ul>"},{"location":"operating_system/process_synchronization#message-passing","title":"Message Passing","text":"<ul> <li>Establish a communication link and exchange messages using basic primitives</li> <li>At least two primitives are required: send &amp; receive</li> <li>Message size can be fixed (easy for OS designer) or variable (easy for programmer)</li> <li>Message structure</li> <li>Header<ul> <li>Message type &amp; length</li> <li>Source &amp; destination</li> <li>Control info: priority, sequence number, instructions if it runs out of buffer space</li> </ul> </li> <li>Body</li> <li>Example: Producer-Consumer problem where producer sends item as message to consumer</li> </ul>"},{"location":"operating_system/process_synchronization#communication-link","title":"Communication Link","text":"<ul> <li>Capacity: Maximum number of messages that can reside in the queue</li> <li>Can be zero, bounded, unbounded</li> <li>Direct Link</li> <li>A specific process identifier is used for communication</li> <li>It is hard to identify the sender ahead of time</li> <li>Indirect Link</li> <li>A shared mailbox/port is used which consists of queue</li> <li>Sender puts the message in the mailbox and reciever picks them up</li> <li>Multiple communication links with different types can be established between any two processes</li> </ul>"},{"location":"operating_system/process_synchronization#communication-types","title":"Communication Types","text":"<ul> <li>Synchronous/Blocking passing where the message is processed right away</li> <li>Asynchronous/Non-blocking passing where the message kept in wait &amp; processed when the process becomes free</li> <li>For a sender</li> <li>Async passing is preferred so that it doesn't have to wait and can carry out other tasks</li> <li>However, an acknowledgement from receiver is necessary in case it fails</li> <li>For a receiver</li> <li>Sync passing is preferred so that it can send the return data or error message right away</li> <li>Messages can keep failing if the error is not communicated to the sender</li> </ul>"},{"location":"operating_system/process_synchronization#race-condition","title":"Race Condition","text":"<ul> <li>When multiple processes try to access a shared resource (same code, same memory, same variable)</li> <li>They are racing each other to access the resource</li> <li>The output of the shared resource can be wrong for these processes due to lack of clarity</li> <li>The order of these processes may be important to get the final output</li> </ul>"},{"location":"operating_system/process_synchronization#program-sections","title":"Program sections","text":"<ul> <li>Entry Section: Decides the entry of a particular process</li> <li>Critical Section: Only one process is allowed to enter and access or modify shared variable</li> <li>Exit Section: Allows other processes waiting in entry section to enter CS</li> <li>Remainder Section: Everything else</li> </ul>"},{"location":"operating_system/process_synchronization#critical-section","title":"Critical Section","text":"<ul> <li>Regions of program that access shared resources and may cause race condition</li> <li>It must be executed as an atomic operation</li> </ul>"},{"location":"operating_system/process_synchronization#rules","title":"Rules","text":"<ul> <li>Mutual Exclusion</li> <li>Only one process is allowed to run in CS at a time</li> <li>Progress</li> <li>If no process is running in CS</li> <li>Processes not in their remainder section should decide which process will enter its CS next</li> <li>This should happen in a finite time and other processes should not wait indefinitely</li> <li>Bounded Waiting</li> <li>After a process has made a request, there must be a limit for other processes to enter CS</li> <li>A process shouldn't wait endlessly for access</li> </ul>"},{"location":"operating_system/process_synchronization#problems","title":"Problems","text":"<ul> <li>Deadlock: When multiple processes wait for each other to release CS</li> <li>Starvation: When a process or thread is prevented repeatedly from entering CS</li> <li>Overhead: Acquiring &amp; releasing locks or semaphores</li> <li>Impacts Scalability: CS becomes a bottleneck for scalability since access to shared resource is restricted</li> </ul>"},{"location":"operating_system/process_synchronization#solutions","title":"Solutions","text":"<ul> <li>Three important criterias</li> <li>Correctness</li> <li>Maximum concurrency</li> <li>No busy waits: Prefer blocking over busy waits</li> <li>Hardware Approach</li> <li>Software Approach</li> </ul>"},{"location":"operating_system/process_synchronization#hardware-solutions","title":"Hardware Solutions","text":""},{"location":"operating_system/process_synchronization#disabling-interrupts","title":"Disabling Interrupts","text":"<ul> <li>When interrupts are disabled, no process is allowed to perform context switch</li> <li>As a result, it will allow only one process to enter CS</li> <li>Nothing can stop the process from doing its work</li> <li>As OS only switches processes when it gets an interrupt from the clock</li> <li>The CS can't be split between time slices</li> <li>Problems</li> <li>Catastrophic if a process fails to enable its interrupts again</li> <li>Effectively halting the CPU to let the program do everything</li> <li>Ineffective in a multiprocessor system<ul> <li>Where disabling interrupts only seizes the processor that executes the instructions</li> </ul> </li> </ul>"},{"location":"operating_system/process_synchronization#test-and-set-lock-operation-tsl","title":"Test and Set Lock operation (TSL)","text":"<ul> <li>Boolean value which is atomic in nature, i.e. no other interrupt is allowed to access</li> <li>Single instruction to load value of lock in register and set it to 1</li> <li>Provides mutual exclusion and progress but not bounded waiting</li> <li>Priority inversion</li> <li>If process gets pre-empted from CS and leaves the lock, no other process can enter (spin lock)</li> <li>Busy Waiting</li> </ul>"},{"location":"operating_system/process_synchronization#compare-and-swap-operation","title":"Compare and swap operation","text":"<ul> <li>Similar to test &amp; set, but matches the passed value with the expected value</li> </ul>"},{"location":"operating_system/process_synchronization_solutions","title":"Process Synchronization Solutions","text":""},{"location":"operating_system/process_synchronization_solutions#lock-variable","title":"Lock variable","text":"<ul> <li>0 means CS is vacant</li> <li>Process entering CS sets it 1</li> <li>Doesn't provide mutual exclusion in some cases</li> <li>Busy Waiting</li> </ul> <pre><code>while lock != 0: continue\nlock = 1\n# Critical Section\nlock = 0\n</code></pre>"},{"location":"operating_system/process_synchronization_solutions#petersons-solution","title":"Peterson's Solution","text":"<ul> <li>Have 2 shared variables</li> <li>bool flag[2]: Which processes wants to enter CS</li> <li>int turn: Whose turn is to enter CS</li> <li>Satisfies all CS conditions</li> <li>Involves busy waiting (Pi waiting for Pj): not preferred because it wastes CPU cycles</li> <li>Limited to 2 processes at a time</li> <li>Cannot be used in modern architecture with multiple CPUs</li> </ul> <pre><code>while (True):\n  # Pi wants to enter CS\n  flag[i] = True\n\n  # Give preference to Pj to avoid conflicts\n  turn = j\n  # Wait if Pj is executing\n  while (flat[j] &amp;&amp; turn == j): continue\n\n  # Critical Section\n\n  flag[i] = False\n\n  # Remainder Section\n</code></pre>"},{"location":"operating_system/process_synchronization_solutions#dekkers-solution","title":"Dekker's Solution","text":"<ul> <li>One of the first mutual exclusion algorithms. The latest revision satisfies all 3 conditions of CS.</li> <li>Uses shared memory for communication</li> <li>Have 2 shared variables</li> <li>bool flag[2]: Which processes wants to enter CS</li> <li>int turn: Whose turn is to enter CS</li> <li>Involves busy waiting (Pi waiting for Pj)</li> <li>Limited to 2 processes at a time</li> <li>Cannot be used in modern architecture with multiple CPUs</li> </ul> <pre><code>while (True):\n  # Pi wants to enter CS\n  flag[i] = True\n\n  # Wait if Pj is executing\n  while flat[j]:\n    if turn == j:\n      flag[i] = False\n      while turn == j: continue\n      flag[i] = True\n\n  # Critical Section\n\n  turn = j\n  flag[i] = False\n\n  # Remainder Section\n</code></pre>"},{"location":"operating_system/process_synchronization_solutions#bakery-algorithm","title":"Bakery Algorithm","text":"<ul> <li>Follows first come first serve</li> <li>Each process is assigned a number (ticket) in lexicographical order</li> <li>The process with the smallest ticket enters CS</li> <li>If the ticket number is same, then lower PID is given preference</li> <li>No deadlock, no starvation</li> <li>Not scalable (overhead increases with number of processes)</li> <li>High time complexity, Memory overhead, Busy waiting</li> </ul> <pre><code>while True:\n  choosing_number[i] = True\n  number[i] = max(number) + 1\n  choosing_number[i] = False\n\n  for j in range(0, n):\n    while choosing_number[j]: continue\n    while number[j] != 0 and [number[j], j] &lt; [number[i], i]: continue\n\n  # Critical Section\n  number[i] = 0\n  # Remainder Section\n</code></pre>"},{"location":"operating_system/process_synchronization_solutions#semaphore","title":"Semaphore","text":"<ul> <li>Signaling mechanism: A process waiting on a semaphore will be signaled by another process</li> <li>Stores available resources in a variable</li> <li>Types: Counting semaphore, Binary semaphore</li> <li>Uses two atomic operations</li> <li>Wait<ul> <li>Decrements the value for semaphore</li> <li>The caller process will be blocked until another process performs a signal operation</li> </ul> </li> <li>Signal<ul> <li>Increments the value of semaphore</li> </ul> </li> <li>Any process can release a resource by calling signal</li> <li>Limitations</li> <li>Priority inversion</li> <li>Deadlock</li> <li>Busy waiting: To solve maintain a waiting queue</li> </ul> <pre><code>int semaphore = S # Maximum number of processes that can enter CS at this time\n\ndef wait(semaphore):\n  while semaphore &lt;= 0: continue # Wait till CS is available\n  semaphore -= 1\n\ndef signal(sempahore):\n  semaphore += 1\n\n# Process P\nwait(semaphore)\n# Critical Section\nsignal(semaphore)\n# Remainder Section\n</code></pre>"},{"location":"operating_system/process_synchronization_solutions#mutex","title":"Mutex","text":"<ul> <li>Mutual Exclusion Object</li> <li>Locking or ownership mechanism</li> <li>Unlike semaphore, it is not a variable but an object</li> <li>Operations</li> <li>Lock</li> <li>Unlock</li> <li>Only the process that has the lock can unlock the resource</li> <li>Can be used as Binary semaphore, but vice-versa is not true</li> <li>Priority inversion is solved by priority inheritance</li> </ul> <pre><code>def lock():\n  while not available: continue\n  available = False\n\ndef unlock():\n  available = True\n\n# Process P\nlock()\n# Critical Section\nunlock()\n# Remainder Section\n</code></pre>"},{"location":"operating_system/process_synchronization_solutions#monitors","title":"Monitors","text":"<ul> <li>A module that encapsulates a shared resource and provides access through a set of procedures</li> <li>Used to simplify implementation of concurrent programs by providing high level abstraction</li> <li>Provides mutual exclusion</li> <li>There are condition variables (with their own queues) on which wait and signal are performed</li> <li>Waiting processes are suspended and put in the queue of the condition variable</li> <li>Processes outside the monitor can't access internal variables but can call its procedures</li> <li>Eliminates the need for complex synchronization primitives like semaphores &amp; mutex, but can be less efficient</li> </ul>"},{"location":"operating_system/process_synchronization_application","title":"Process Synchronization Application","text":""},{"location":"operating_system/process_synchronization_application#producer-consumer","title":"Producer Consumer","text":"<ul> <li>Also known as Bounded Buffer Problem</li> <li>Details</li> <li>We have a buffer of fixed size</li> <li>Producer produces an item and puts it in the buffer</li> <li>Consumer consumes an item by picking up from the buffer</li> <li>Problems</li> <li>Both processes may try to update the buffer at the same time<ul> <li>Which can lead to data loss &amp; inconsistency</li> </ul> </li> <li>Consumer might consume faster, so it might have to wait</li> <li>Producer might produce faster which can lead to buffer overflow</li> <li>There may be multiple producers &amp; consumers, and same item may be processed multiple times</li> <li>Solution</li> <li>Use a mutex for locking &amp; unlocking the buffer</li> <li>Use a semaphore for empty slots</li> <li>Use a semaphore for occupied slots</li> <li>Variations</li> <li>Unbounded buffer</li> <li>Sleep and wake<ul> <li>Producer sleeps if consumer is not consuming</li> <li>Consumer sleeps if producer is not producing</li> <li>Each wake up the other when process starts</li> <li>Problem</li> <li>Producer starts when consumer was about to sleep</li> <li>Consumer will sleep and afterwards producer as consumer is not consuming</li> </ul> </li> </ul> <pre><code>def producer():\n  while True:\n    wait(empty_slots)\n    lock(buffer)\n    # Put in buffer\n    unlock(buffer)\n    signal(occupied_slots)\n\ndef consumer():\n  while True:\n    wait(full_slots)\n    lock(buffer)\n    # Consume from buffer\n    unlock(buffer)\n    signal(occupied_slots)\n</code></pre>"},{"location":"operating_system/process_synchronization_application#dining-philosophers","title":"Dining Philosophers","text":"<ul> <li>There is one chopstick/fork between two philosophers</li> <li>A philosopher can eat only if he picks up two chopsticks</li> <li>Deadlock will happen if all philosophers pick their left chopstick simultaneously. Solutions:</li> <li>Odd philosophers pick left chopstick first &amp; even ones pick right chopstick first</li> <li>Both chopsticks should be available before picking up</li> <li>Solution</li> <li>Mutex to ensure that only one philosopher attempts to pick up a fork at a time</li> <li>One semaphore per philosopher</li> <li>One state per philosopher (thinking, hungry, or eating)</li> </ul> <pre><code>def philosopher(index):\n  while True:\n    think(index)\n    take_forks(index)\n    eat(index)\n    put_forks(index)\n\ndef check(index):\n  if state[index] == 'hungry' and state[left] != 'eating' and state[right] != 'eating':\n    philosopher_semaphore[index].wait()\n    state[index] = 'eating'\n\ndef take_forks(index):\n  mutex.lock()\n  state[index] = 'hungry'\n  check(index)\n  mutex.unlock()\n\ndef put_forks(index)\n  mutex.lock()\n  state[index] = 'thinking'\n  check(left)\n  check(right)\n  mutex.unlock()\n  philosopher_semaphore[index].signal()\n\ndef think(index):\n  time.sleep(random.randint(1, 5))\n\ndef eat(index):\n  time.sleep(random.randint(1, 3))\n</code></pre>"},{"location":"operating_system/process_synchronization_application#readers-writers","title":"Readers Writers","text":"<ul> <li>A resource (e.g. file) shared between multiple users or processes</li> <li>Reading: Any number of readers can read the write_semaphore<ul> <li>No one is allowed to write because the changes won't be visible to readers</li> </ul> </li> <li>Writing: Only the writer is allowed access<ul> <li>No one else can write or read because the changes won't be visible to others</li> </ul> </li> <li>Solution</li> <li>Semaphore<ul> <li>Semaphore to control write action to the write_semaphore</li> <li>Variable to track reader count</li> <li>Mutex to control edits to reader count</li> </ul> </li> <li>Monitor<ul> <li>Gives equal chance to both readers &amp; writers</li> <li>If writer is active, readers queue up</li> <li>If readers are active, writers queue up</li> </ul> </li> <li>Types: Reader is given preference, Writer is given preference, Both have equal preference</li> </ul> <pre><code>def writer():\n  while True:\n    wait(write_semaphore)\n\n    # Write\n\n    signal(write_semaphore)\n\ndef reader():\n  while True:\n    # Reader wants to enter\n    wait(read_mutex)\n    read_count += 1\n    # Disable writer access, readers are being preferred\n    if read_count == 1: wait(write_semaphore)\n    signal(read_mutex)\n\n    # Reading\n\n    # Reader wants to exit\n    wait(read_mutex)\n    read_count -= 1\n    # Enable writer access\n    if read_count == 0: signal(write_semaphore)\n    signal(read_mutex)\n</code></pre>"},{"location":"operating_system/process_synchronization_application#sleeping-barber","title":"Sleeping Barber","text":"<ul> <li>Details</li> <li>There is one barber and a number of chairs for waiting customers</li> <li>Customers arrive at random times and take a chair if available to wait</li> <li>If no chairs are available, the customer leaves</li> <li>When the barber is finished with a customer, he picks up the next customer</li> <li>If there are no customers, the barber goes to sleep</li> <li>Solution</li> <li>Semaphore for the barber's chair</li> <li>Semaphore for the waiting chairs</li> <li>Mutex to update waiting chairs</li> <li>It can become complex if multiple barbers are employed</li> </ul> <pre><code>def barber():\n  while True:\n    barber_semaphore.wait()\n    mutex.lock()\n\n    if len(waiting_customers) &gt; 0\n      customer = waiting_customers.pop(0)\n      mutex.unlock()\n\n      cut_hair()\n      customer_semaphore.signal()\n    else:\n      mutex.unlock()\n\ndef customer(index):\n  mutex.lock()\n\n  if len(waiting_customers) &lt; number_of_chairs:\n    waiting_customers.append(index)\n    mutex.unlock()\n\n    barber_semaphore.signal()\n    customer_semaphore.wait()\n    get_haircut()\n  else:\n    mutex.unlock()\n</code></pre>"},{"location":"operating_system/thread_management","title":"Thread Management","text":""},{"location":"operating_system/thread_management#thread","title":"Thread","text":"<ul> <li>Basic unit of CPU utilization</li> <li>Flow of execution through the process code</li> <li>Execution unit in a process</li> <li>Process has its own memory space and resources</li> <li>Threads operate within the same process with shared memory space and resources</li> <li>Separate flow of control with parallelism/concurrency</li> <li>Enables multiple threads to collaborate and work efficiently within a single program</li> <li>Fast communication due to shared memory</li> <li>Threads are most effective in multi-processors, otherwise context switch can be an overhead</li> <li>Each thread has Thread Control Block (TCB) and can be assigned priority</li> <li>Shares with peer threads: Code segment, Data segment, Open files</li> <li>Have its own: Program Counter (PC), System Registers, Stack</li> <li>Advantages</li> <li>Communication and Response</li> <li>Fast Context Switch</li> <li>Resource Sharing</li> <li>Enhanced Throughput</li> <li>Daemon</li> <li>Disk and Execution Monitor</li> <li>It is a long running background process that acts on request</li> </ul>"},{"location":"operating_system/thread_management#types","title":"Types","text":"<ul> <li>User level</li> <li>Not created using system calls and kernel does not manage them</li> <li>More efficient than kernel-level, context switch time is less, easier implementation</li> <li>If one thread causes a page fault, the entire process blocks</li> <li>Cannot benefit from multiprocessing</li> <li>Application dependent and OS independent</li> <li>Kernel level</li> <li>Have their own thread table to keep track and kernel helps in their management</li> <li>Slower than user-level, context switch time is more, complex implementation</li> <li>Can schedule multiple threads of the same process on different processors</li> <li>OS dependent</li> </ul>"},{"location":"operating_system/thread_management#threading-issues","title":"Threading Issues","text":"<ul> <li>Fork and Exec calls</li> <li>fork(): Does the new process duplicate all the threads or keep it single threaded</li> <li>exec(): The program specified as parameter will replace the entire process including all the threads</li> <li>Signal Handling</li> <li>Signal is used to notify a process that a particular event has happened</li> <li>Every signal has a default signal handler that the kernel runs when handling the signal</li> <li>This default action can be overriden by a user defined signal handler</li> <li>Thread Cancellation</li> <li>A browser often loads a web page using several threads (each image is loaded in a separate thread)</li> <li>When stop button is pressed, all threads loading the page are cancelled</li> <li>Cancellation may occur in 2 different scenarios<ul> <li>Async: One thread immediately terminates the target thread</li> <li>Deferred: Target thread continuously checks whether it should terminate</li> </ul> </li> <li>Thread Local Storage</li> <li>In some circumstances, a thread might need its own copy of data (e.g. in transaction processing)</li> <li>Scheduler Activations</li> <li>One scheme of communication between user level thread and kernel</li> <li>Kernel provides an application with a set of virtual processors<ul> <li>The application can schedule user threads onto an available virtual processor</li> </ul> </li> </ul>"},{"location":"operating_system/thread_management#multi-tasking","title":"Multi-tasking","text":"<ul> <li>Multi-tasking OS gives the perception of running multiple processes simultaneously</li> <li>By dividing system resources and switching very fast between them</li> <li>Process based multi-tasking</li> <li>Process is the smallest unit</li> <li>Example: listening music and browsing internet at the same time</li> <li>Thread based multi-tasking</li> <li>Thread is the smallest unit</li> <li>Example: In a browser, navigating through a webpage and downloading a file at the same time</li> </ul>"},{"location":"operating_system/thread_management#zombie-process","title":"Zombie Process","text":"<ul> <li>Once a process is executed or terminated, its process descriptor stays in memory</li> <li>It sends a signal (SIGCHILD in linux) to its parent and enters into zombie state (EXIT_ZOMBIE in linux)</li> <li>The parent process then executes wait() system call to read the dead process's information</li> <li>After wait() is called, the zombie process is completely removed from memory</li> <li>This normally happens very quickly, so zombie processes are not accumulated in the system</li> <li>If zombie processes accumulate, they will take space in process table</li> <li>The process table has finite size and the system won't be able to generate new processes</li> </ul>"},{"location":"operating_system/resource_allocation","title":"Resource Allocation","text":""},{"location":"operating_system/resource_allocation#deadlock","title":"Deadlock","text":"<ul> <li>Situation where a set of processes are blocked because</li> <li>Each process is holding a resource</li> <li>And waiting for another resource acquired by some other process</li> <li>Example: P1 has R1 &amp; waiting for R2 and P2 has R2 &amp; waiting for R1</li> <li>Safe State: In which deadlock doesn't occur</li> <li>Deadlock Conditions: all four occur simultaneously</li> <li>Mutual Exclusion: Two or more resources are non-shareable (only one process can use at a time)</li> <li>Hold and Wait: A process is holding at least one resource and waiting for other resources at the same time</li> <li>No Preemption: A resource cannot be taken away from a process unless the process releases it</li> <li>Circular Wait: A set of processes waiting on each other in circular form</li> <li>Deadlock Handling Mechanisms</li> <li>Prevention</li> <li>Avoidance</li> <li>Detection and Recovery</li> <li>Ignorance</li> </ul>"},{"location":"operating_system/resource_allocation#livelock","title":"Livelock","text":"<ul> <li>When two or more processes continually repeat the same interaction</li> <li>In response to changes in other processes without doing any useful work</li> <li>All processes in livelock are running concurrently while in deadlock they are in waiting state</li> </ul>"},{"location":"operating_system/resource_allocation#deadlock-prevention","title":"Deadlock Prevention","text":"<ul> <li>Achieved by solving or avoiding one of the four conditions</li> <li>Mutual Exclusion</li> <li>May not be possible since some resources are inherently non-shareable (like printer)</li> <li>Hold and Wait</li> <li>Allocate all resources at the start and release at the end of the process</li> <li>Will lead to low utilization since other processes can't use it</li> <li>May lead to starvation</li> <li>Preemption</li> <li>Preempt the resources when required by high priority process</li> <li>Circular wait</li> <li>Assign priority number to each resource</li> <li>Process can't request a lesser priority resource, i.e. a resource being used by other process</li> </ul>"},{"location":"operating_system/resource_allocation#deadlock-avoidance","title":"Deadlock Avoidance","text":"<ul> <li>Checking if system is in safe state at every step</li> <li>Request for resource will be granted only for safe state</li> <li>If it is in unsafe state, OS will backtrack one step</li> <li>Ensure that all information about resources is known before the execution (Resource allocation state)</li> <li>Available and allocated resources</li> <li>Maximum resources demanded by the processes</li> <li>Limitation: Process may not use all the resources demanded initially</li> <li>Achieves correctness of data but decreases performance</li> <li>Banker's algorithm is used</li> </ul>"},{"location":"operating_system/resource_allocation#resource-allocation-graph-rag","title":"Resource Allocation Graph (RAG)","text":"<ul> <li>Process: circles</li> <li>Resources: rectangles, number of instances are denoted by dots</li> <li>Requesting: arrow from P to R</li> <li>Allocated: arrow from R to P</li> <li>It's a deadlock if a cycle forms</li> <li>If a resource has multiple instances, there must be that many cycles for deadlock</li> </ul>"},{"location":"operating_system/resource_allocation#bankers-algorithm","title":"Banker's algorithm","text":"<ul> <li>Used in banking system to check if a loan can be sanctioned to a person</li> <li>Resource allocation and deadlock avoidance</li> <li>Input for resources: Maximum requirement, Allocated, Available, Requested</li> <li>Allows a request only if there's a safe state</li> <li>Requested resources &lt;= Max required resources</li> <li>Requested resources &lt;= Available resources</li> <li>Timeouts can be implemented to avoid deadlocks</li> <li>Example</li> <li>There are 4 resources: [A B C D]</li> <li>Total: [2 6 3 4]</li> <li>Available: [1 3 1 0]</li> <li>Allocated: [1 3 2 4]<ul> <li>P1 = [1 2 1 2]</li> <li>P2 = [0 1 3 2]</li> </ul> </li> <li>Max:<ul> <li>P1 = [2 2 2 3]</li> <li>P2 = [0 1 5 3]</li> </ul> </li> <li>Needed: Max - Allocated<ul> <li>P1 = [1 0 1 1]</li> <li>P2 = [0 0 2 1]</li> </ul> </li> </ul>"},{"location":"operating_system/resource_allocation#deadlock-detection-and-recovery","title":"Deadlock Detection and Recovery","text":"<ul> <li>Periodically check if deadlock occurred</li> <li>Detect deadlock</li> <li>Resource Allocation Graph (complicated for multiple instanced resources)</li> <li>Banker's Algorithm</li> <li>System Modeling: Mathematical model of the system and states</li> <li>Timestamping: If any process is waiting for a resource held by a process with lower timestamp</li> <li>Manual Intervention</li> <li>Inform the operator and let them handle manually</li> <li>Automatic Recovery</li> <li>Preempt the resources</li> <li>Rollback to previous safe state</li> <li>Abort all the processes: Computations may be lost</li> <li>Abort one process at at time: The process can be selected based on<ul> <li>Priority, progress, process type, resources consumed, resources required</li> <li>Only one process should not be targeted repeateadly which may cause starvation</li> </ul> </li> </ul>"},{"location":"operating_system/resource_allocation#deadlock-ignorance","title":"Deadlock Ignorance","text":"<ul> <li>If deadlock is very rare, let it happen and reboot the system</li> <li>For normal users, windows, linux</li> <li>Performance will decrease if it uses deadlock mechanism</li> </ul>"},{"location":"operating_system/resource_allocation#resource-allocation-techniques","title":"Resource Allocation Techniques","text":"<ul> <li>Resource Pool</li> <li>There is a common pool of resources</li> <li>Resource Partitioning</li> <li>OS decides beforehand about what resources should be allocated to which process</li> <li>Divides resources to many resource partitions which are allocated as such</li> <li>A resource table records the partition and its current allocation status</li> <li>If a partition contains more resources than required, then they are wasted</li> </ul>"},{"location":"operating_system/resource_allocation#deadlock-in-distributed-systems","title":"Deadlock in Distributed Systems","text":"<ul> <li>In distributed systems, deadlock can neither be prevented or avoided</li> <li>Only deadlock detection can be implemented</li> <li>Approaches</li> <li>Centralized: Only one responsible node to detect deadlock<ul> <li>But can lead to excessive workload on one node and single point of failure</li> </ul> </li> <li>Distributed: Different nodes work together to detect deadlock</li> <li>Hierarchical: Most advantageous with combination of centralized and distributed approaches<ul> <li>Selected nodes are responsible for deadlock detection which are controlled by a single node</li> </ul> </li> </ul>"},{"location":"operating_system/memory","title":"Memory","text":"<ul> <li>Required to save data and instructions either temporarily or permanently</li> <li>Divided into cells or registers having an unique location or address</li> <li>Each register stores one bit of data</li> <li>Every data is converted to binary before storing</li> <li>Word</li> <li>Group of bits where a memory unit stores binary information</li> <li>Group of 8 bits is called a byte</li> <li>Memory Unit</li> <li>Data lines: Provide the info to be stored</li> <li>Control inputs: Specify the direction of transfer</li> <li>Address selection lines: Specify the word chosen, 2^k words can be accessed using k address lines</li> <li>Units of Memory</li> <li>Bit: Smallest unit that stores binary value (0 or 1)</li> <li>Byte: 8 bits, can represent 2^8 = 256 values</li> <li>KiloByte: 1024 Bytes</li> <li>MegaByte: 1024 KB</li> <li>GigaByte, TeraByte, PetaByte</li> </ul>"},{"location":"operating_system/memory#memory-heirarchy","title":"Memory Heirarchy","text":"<ul> <li>Enhancement to organize the memory such that access time is minimized</li> <li>Based on program behavior known as locality of references</li> <li>Locality of references: Tendency of a processor to access the same set of memory locations</li> <li>Repetitively over a short period of time</li> <li>Some types of memory like cache and main memory are faster than others</li> <li>But have less size and are more expensive</li> <li>Types</li> <li>Internal or Primary Memory<ul> <li>Directly accessible by the processor</li> <li>Main memory, cache, CPU registers</li> </ul> </li> <li>External or Secondary<ul> <li>Peripheral storage devices accessible by the processor via an I/O module</li> <li>Magnetic disk, optical disk, magnetic tape</li> </ul> </li> </ul>"},{"location":"operating_system/memory#hierarchy-design","title":"Hierarchy Design","text":""},{"location":"operating_system/memory#registers","title":"Registers","text":"<ul> <li>Small high-speed memory units located in CPU that stores most frequently used data and instructions</li> <li>Have fastest access time and smallest storage capacity (16 to 64 bits)</li> </ul>"},{"location":"operating_system/memory#cache","title":"Cache","text":"<ul> <li>Small fast memory unit located close to CPU</li> <li>That stores recently accessed data from the main memory</li> <li>Minimizes access time for CPU by storing temporary data</li> <li>Or acting as a middleware between CPU &amp; original location</li> <li>Typically integrated directly into CPU chip</li> <li>Or placed on a separate chip with a bus interconnect with CPU</li> </ul>"},{"location":"operating_system/memory#main-memory","title":"Main Memory","text":"<ul> <li>Primary memory of a computer system, has larger capacity than cache memory but is slower</li> <li>RAM</li> <li>Read write memory that is volatile and stores data &amp; instructions currently in use by CPU</li> <li>Writing data is faster</li> <li>Static RAM<ul> <li>Stores binary info in flip flops and requires constant power supply</li> <li>Faster access time and used to implememt cache memory but expensive than DRAM</li> <li>Complex internal circuitry and less capacity than DRAM</li> </ul> </li> <li>Dynamic RAM<ul> <li>Stores binary info as a charge in capacitor</li> <li>Requires refreshing circuitry to maintain the charge after a few milliseconds</li> <li>Contains more memory cells per unit area compared to SRAM</li> </ul> </li> <li>ROM</li> <li>Read only memory that is non-volatile and stores important info used to operate the system</li> <li>Writing data is slower</li> <li>Masked ROM: Hard wired devices with a pre-programmed collection of data, were the first ROMs</li> <li>Programmable ROM: Modifiable once by the user, initially blank and can't be erased once written</li> <li>Erasable PROM: Extension of PROM that can be erased using UV rays</li> <li>Electrically Erasable PROM: Can erase (using electric field) and reprogramme upto 10,000 times</li> </ul>"},{"location":"operating_system/memory#secondary-storage","title":"Secondary Storage","text":"<ul> <li>Non volatile memory that has a large storage capacity and stores data not currently in use by CPU</li> <li>Has the slowest access time and typically least expensive type of memory</li> <li>Example: Hard disk drive (HDD), Solid state drive (SSD)</li> <li>Virtual Memory: Using secondary memory as if it was a part of the main memory if there's a shortage</li> <li>Magnetic storage devices use magnetic fields to store and retrieve data</li> <li>Solid state storage devices use semiconductor based memory chips to store data</li> </ul>"},{"location":"operating_system/memory#magnetic-disk","title":"Magnetic Disk","text":"<ul> <li>Circular plates fabricated with metal or plastic or magnetized material</li> <li>Works at high speed inside computer and frequently used</li> </ul>"},{"location":"operating_system/memory#magnetic-tape","title":"Magnetic Tape","text":"<ul> <li>Magnetic recording device covered with plastic film, generally used for backup of data</li> <li>Access time is slower and requires some time for accessing the strip</li> </ul>"},{"location":"operating_system/memory_management","title":"Memory Management","text":"<ul> <li>Memory management is the functionality which manages primary memory</li> <li>Moves processes between main memory and disk during execution</li> <li>Keeps track of each memory location whether it's allocated or free</li> <li>Allocates memory dynamically to the programs when requested<ul> <li>And de-allocates for reuse when no longer needed</li> </ul> </li> <li>Memory Management Unit (MMU) handles these tasks</li> <li>Requirements</li> <li>Relocation: Relocate the process when swapped back if the previous location is occupied by another process</li> <li>Protection: One process should not write to the address of another process (accidental or incidental)</li> <li>Sharing: Allow controlled access to shared memory, share copy of process where required</li> <li>Organization of logical &amp; physical memory</li> <li>Programs always execute in main memory, so larger the main memory, larger the multiprogramming</li> </ul>"},{"location":"operating_system/memory_management#memory-allocation-and-partitioning","title":"Memory Allocation and Partitioning","text":""},{"location":"operating_system/memory_management#placement-algorithms","title":"Placement Algorithms","text":"<ul> <li>OS decides which free block to allocate when a process is loaded into main memory</li> <li>First fit: First available block which is large enough</li> <li>Best fit: First smallest sufficient partition</li> <li>Consumes a lot of process time to search</li> <li>May not always be the best algorithm<ul> <li>It depends on how the memory can be distributed among all processes</li> </ul> </li> <li>Worst fit: Largest sufficient partition</li> <li>Next fit: Similar to first fit, but will be searched from the last allocation point</li> </ul>"},{"location":"operating_system/memory_management#allocation-methods","title":"Allocation Methods","text":"<ul> <li>Single Continguous: Except the reserved memory for OS, all memory is available to a process</li> <li>Partitioned: Memory is divided into different blocks or partitions and allocated based on requirements</li> <li>Paged: Memory is divided into fixed size units called page frames and used as virtual memory</li> <li>Segmented: Memory is divided into different segments</li> <li>Segment is a logical grouping of the process data or code</li> <li>Allocated memory doesn\u2019t have to be contiguous</li> <li>Most OS use segmentation with paging<ul> <li>A process is divided into segments and each segment has pages</li> </ul> </li> </ul>"},{"location":"operating_system/memory_management#fragmentation","title":"Fragmentation","text":"<ul> <li>When many of the free blocks are too small to satisfy any request</li> <li>External: Memory not contiguous, requires memory shuffling</li> <li>Internal: Allocated memory larger than required</li> <li>Defragmentation</li> </ul>"},{"location":"operating_system/memory_management#contiguous-partitioning","title":"Contiguous Partitioning","text":"<ul> <li>Processes can only be allocated contiguous or adjacent blocks of memory</li> </ul>"},{"location":"operating_system/memory_management#fixed-or-static-partitioning","title":"Fixed or Static Partitioning","text":"<ul> <li>Main memory is divided into fixed number of partitions but the sizes may vary with no overlaps</li> <li>Each partition is assigned to a specific process or user, OS occupies the first partition</li> <li>Typically allocated at boot time and remains dedicated to a process till it terminates or releases</li> <li>Advantages</li> <li>Simple and easy to implement</li> <li>Minimum memory can be ensured for each process</li> <li>Prevents processes from interfering into each other's memory space</li> <li>Disadvantages</li> <li>Internal fragmentation (memory in partition remains unused)</li> <li>External fragmentation (since partitions are contiguous, some parts of memory may remain unused)</li> <li>Process size limitation (cannot exceed than the allocated partition)</li> <li>Limits the number of processes running concurrently (each process requires a dedicated partition)</li> <li>Used in embedded systems, real-time systems, limited memory systems</li> </ul>"},{"location":"operating_system/memory_management#variable-or-dynamic-partitioning","title":"Variable or Dynamic Partitioning","text":"<ul> <li>Partitions are not made before execution but during run-time</li> <li>Partition is created depending on the process requirements avoiding internal fragmentation</li> <li>Number of partitions is not fixed and depends upon the incoming processes and the main memory size</li> <li>First partition is reserved for OS</li> <li>Keeping track of partitions: Bitmap, Linked List</li> <li>Advantages: No interal fragmentation, no limitation on multiprogramming, no limitation on process size</li> <li>Disadvantages: External fragmentation, complex memory allocation</li> </ul>"},{"location":"operating_system/memory_management#non-contiguous-partitioning","title":"Non-Contiguous Partitioning","text":"<ul> <li>Processes can be allocated a series of non-contiguous blocks of memory that can be located anywhere</li> <li>Pointers are used to link the blocks and track the blocks allocated to a process</li> <li>Use of pointers introduces an overhead in allocation &amp; de-allocation</li> <li>Need to maintain page table for each process</li> </ul>"},{"location":"operating_system/memory_management#paging","title":"Paging","text":"<ul> <li>Logical memory or process address space is divided into blocks of same size called pages</li> <li>Main memory is divided into small fixed sized blocks of physical memory called frames</li> <li>No external fragmentation since frame size is generally equal to page size</li> <li>Retrieving processes from secondary storage into main memory in form of pages is also called paging</li> <li>Internal fragmentation can happen in the last page of the process</li> <li>Logical address</li> <li>Page number: Bits that represent the page in logical address space</li> <li>Page offset: Bits that represent a particular word in a page</li> <li>p|d (logical) -&gt; f|d (physical)</li> <li>Physical address</li> <li>Frame number</li> <li>Frame offset</li> <li>Translation Lookaside Buffer (TLB) is special fast lookup hardware cache</li> <li>It is used to track recently used page table entries</li> </ul>"},{"location":"operating_system/memory_management#segmentation","title":"Segmentation","text":"<ul> <li>A process is divided into segments (main program, functions, procedures, variables, etc)</li> <li>Segments may not be of same sizes which can lead to external fragmentation</li> <li>It gives user's view of process which paging does not</li> <li>Segment table maps logical and physical addresses</li> </ul>"},{"location":"operating_system/memory_management#address-spaces","title":"Address Spaces","text":""},{"location":"operating_system/memory_management#logical-or-virtual-address","title":"Logical or Virtual Address","text":"<ul> <li>Virtual address generated by CPU during program execution relative to the program's address space</li> <li>Provides a layer of abstraction that allows processes to access memory without knowing physical addresses</li> <li>Memory management unit (MMU) translates logical addresses into physical addresses using page table</li> <li>Page table maps each logical page number to a physical frame number</li> <li>Process/logical address space</li> <li>Set of logical addresses that a process references in its code</li> <li>OS maps logical addresses to physical addresses at the time of memory allocation to the program</li> <li>Uses</li> <li>Allows efficient memory management using paging and segmentation</li> <li>Can extend physical memory by disk</li> <li>Memory protection</li> <li>Less I/O needed to load or swap program in memory</li> </ul>"},{"location":"operating_system/memory_management#physical-address","title":"Physical Address","text":"<ul> <li>Actual address in main memory where data is stored</li> <li>Physical addresses are not exposed to processes or users</li> <li>Physical address space does not change</li> <li>Example</li> <li>Physical address = 12 bits, physical address space = 2^12 = 4 * 1024 = 4K words</li> <li>Logical address = 13 bits, physical address space = 2^13 = 8 * 1024 = 8K words</li> </ul>"},{"location":"operating_system/memory_management#address-binding","title":"Address Binding","text":"<ul> <li>Process of mapping one address space to another address space</li> <li>Done by Memory management unit (MMU) (address translation unit in particular)</li> </ul>"},{"location":"operating_system/memory_management#contiguous-memory-allocation","title":"Contiguous Memory Allocation","text":"<ul> <li>In contiguous memory allocation, it is not a difficult task</li> <li>If the base address of the process is known, next addresses can be found out</li> <li>MMU is a combination of two registers: Base register &amp; limit register</li> <li>Base Register (Relocation Register)</li> <li>Contains starting physical address of the process</li> <li>Limit Register</li> <li>Mentions the limit relative to the base address on the region occupied by the process</li> <li>Logical address generated by CPU is first checked by limit register</li> <li>If the value of the logical address is less than the limit register<ul> <li>The base address stored in the relocation register is added to the logical address to get the physical address</li> </ul> </li> <li>If the value of the logical address is greater than the limit register<ul> <li>CPU traps to the OS and OS terminates the program by giving fatal error</li> </ul> </li> </ul>"},{"location":"operating_system/memory_management#non-contiguous-memory-allocation","title":"Non-contiguous Memory Allocation","text":"<ul> <li>Processes can be allocated anywhere in the available space</li> <li>The address translation is difficult, some techniques are Paging &amp; Segmentation</li> <li>Different data structures and hardware support like TLB are required</li> </ul>"},{"location":"operating_system/memory_management#types","title":"Types","text":"<ul> <li>Compile Time</li> <li>If it is known at the compile time where the process will reside in memory<ul> <li>Then an absolute address is generated</li> </ul> </li> <li>Physical address is embedded to the executable of the program during compilation</li> <li>Loading executable as a process in memory is very fast</li> <li>If the generated address space is preoccupied by other processes, then the program crashes<ul> <li>The program needs to be recompiled to change the address space</li> </ul> </li> <li>Load Time</li> <li>If it is not known at the compile time where the process will reside<ul> <li>Then a relocatable address is generated</li> </ul> </li> <li>The loader translates the relocatable address to an absolute address</li> <li>To generate an absolute address<ul> <li>The base address of the process in main memory is added to all logical addresses by the loader</li> </ul> </li> <li>If the base address of the process changes, the process needs to be reloaded</li> <li>Execution Time</li> <li>The stage where instructions are in memory and are being processed by CPU</li> <li>Additional memory may be allocated and de-allocated</li> <li>Used if a process can be moved from one memory to another during execution</li> </ul>"},{"location":"operating_system/memory_management#page-table","title":"Page Table","text":"<ul> <li>Data structure used by OS to keep track of the mapping between logical and physical addresses</li> <li>Contents of Page Table Entry (PTE)</li> <li>Frame Number (or Address Translation Bit): Frame number in which the page is present (physical address)</li> <li>Present/Absent Bit (or Valid/Invalid Bit): If the page is not present, it is called Page Fault</li> <li>Protection Bit: Specifies protection like read, write, etc.</li> <li>Reference Bit: Whether the page was referred in the last cycle or not</li> <li>Caching Enabled/Disabled: Caching is disabled when the latest info is required</li> <li>Modified Bit (or Dirty Bit): If a page is modified, it has to be written or saved somewhere on page replacement</li> <li>The size and format of PTE can vary depending on the architecture of the system and the OS</li> </ul>"},{"location":"operating_system/memory_management#allocating-kernel-memory","title":"Allocating Kernel Memory","text":""},{"location":"operating_system/memory_management#buddy-system","title":"Buddy System","text":"<ul> <li>Divides memory into blocks of fixed size, each block has size in the power of two</li> <li>Follows best fit strategy</li> <li>On getting a request, it finds the smallest available block with sufficient size</li> <li>If the block is larger than required, it is split into two smaller blocks of equal size (buddies)</li> <li>This is repeated till the requested size is achieved</li> <li>Split strategies: Binary, fibonacci, weighted, tertiary</li> <li>Advantages</li> <li>Easy to implement and can handle wide range of memory sizes</li> <li>Coalescing (how quickly adjacent buddies can be combined to form a larger segment)</li> <li>Address calculation is easy</li> <li>Disadvantages: Internal fragmentation, can be inefficient in allocating small amounts of memory</li> </ul>"},{"location":"operating_system/memory_management#slab-system","title":"Slab System","text":"<ul> <li>Divides memory into slabs of fixed size consisting of a set of objects of the same type</li> <li>Slab</li> <li>Made up of one or more physically contiguous pages</li> <li>Container of data associated with objects of specific kind of the containing cache</li> <li>Possible states depending on the available objects: full, empty, partial</li> <li>Cache</li> <li>Small amount of very fast memory, consists of one or more slabs</li> <li>Single cache for each unique kernel data structure (e.g. file objects, semaphores, process descriptors)</li> <li>On getting a request, it attempts to assign free object from a partial slab and then from an empty slab</li> <li>If these slabs are not available, a new slab is allocated from contiguous physical pages and assigned to a cache</li> <li>When the object is released and marked free, it returns to its cache</li> <li>Advantages:</li> <li>Efficient in allocating small amounts of memory since objects are created in advance</li> <li>Prevents fragmentation</li> <li>Disadvantages: Complex to implement, may require more memory overhead</li> </ul>"},{"location":"operating_system/memory_management#garbage-collector","title":"Garbage Collector","text":"<ul> <li>Prevents memory leaks and fragmentation</li> <li>Dynamic approach to automatic memory management and heap allocation</li> <li>That processes and identifies memory no longer referenced</li> <li>Dynamic memory management process that finds dead memory blocks and reallocates them</li> <li>3 primary approaches</li> <li>Mark and sweep: Reclaiming available memory</li> <li>Reference counting<ul> <li>Allocated object contains reference count of referencing number</li> <li>When memory count is 0, object is garbage and destroyed</li> <li>Freed memory returns to heap memory</li> </ul> </li> <li>Copy collection: Two partitions. When one is full, relocate and compact to second</li> <li>Buffer Overflow</li> </ul>"},{"location":"operating_system/memory_management#memory-leak","title":"Memory Leak","text":"<ul> <li>When memory which is no longer needed is not released</li> <li>When an object is stored in memory but cannot be accessed by running code</li> </ul>"},{"location":"operating_system/virtual_memory","title":"Virtual Memory","text":"<ul> <li>Storage allocation scheme where secondary memory can be addressed as if it were part of the main memory</li> <li>The basis is non-contiguous memory allocation and the software component is called Virtual Memory Manager (VMM)</li> <li>The part of secondary memory used for virtual memory is called swap space or swap file</li> <li>A process can be swapped in and out of the main memory to make room for other components</li> <li>It occupies different places in main memory at different times during the execution</li> <li>Allows more processes to be maintained in the same amount of main memory</li> <li>A process can be broken into pieces and only the required pieces can be kept in the main memory</li> <li>It is permitted by the combination of dynamic run-time address translation and a page or segment table</li> <li>Also allows a large process to be broken down, even if it's larger than the main memory</li> <li>Logical address space thus can be larger than physical address space</li> <li>The size is limited by the addressing scheme of the system and the secondary memory available</li> <li>Challenges</li> <li>Overhead due to the movement between the main memory and the secondary memory</li> <li>Increased risk of data loss or corruption (if hard disk fails or power outage during transfer)</li> <li>Increased complexity of the memory management system</li> </ul>"},{"location":"operating_system/virtual_memory#demand-paging","title":"Demand Paging","text":"<ul> <li>The process of loading a page into memory on demand (when a page fault or memory access fault occurs)</li> <li>Process</li> <li>When the CPU tries to access a page not in memory, it generates an interrupt indicating a memory access fault</li> <li>OS puts the interrupted process in blocking state and it must bring the required page in the memory</li> <li>OS searches for the required page in the logical address space</li> <li>The require page is brought from logical address space to physical address space<ul> <li>Page replacement algorithms are used to decide replacing the page in physical address space</li> </ul> </li> <li>The page table is updated accordingly</li> <li>A signal is sent to CPU to continue the process execution and place the process back into the ready state</li> <li>The time taken to perform these steps is called page fault service time</li> <li>Page replacement algorithm</li> <li>Minimize page misses, processor time, cost of primary storage</li> <li>Reference string</li> <li>FIFO, LRU, LFU, MFU, Optimal page algorithm, Page buffering algorithm</li> <li>Belady's Anamoly</li> <li>Generally, page faults decrease if frames are increased</li> <li>But sometimes the opposite occurs and is termed as belady's anamoly</li> <li>Commonly occurs in FIFO</li> </ul>"},{"location":"operating_system/virtual_memory#swapping","title":"Swapping","text":"<ul> <li>The process of removing all the pages of a process from memory</li> <li>Or marking them for removal by the normal page replacement process</li> <li>Suspending a process ensures that it is not runnable while it is swapped out</li> <li>At some time later, the system swaps back the process from the secondary to the main memory</li> </ul>"},{"location":"operating_system/virtual_memory#thrashing","title":"Thrashing","text":"<ul> <li>If the OS throws out a page just before it is to be used, it will have to get that page back immediately</li> <li>Too much of this activity leads to thrashing where the system spends most of its time swapping pages</li> <li>This decreases CPU utilization and increases the time taken for execution</li> <li>Causes</li> <li>Increasing multi-programming after a certain degree which decreases the number of frames per process</li> <li>Lack of frames: If a process is not allocated a sufficient amount of frames</li> <li>Improper page replacement policy</li> <li>Recovery</li> <li>Instruct the long-term scheduler not to bring the processes into memory after the threshold</li> <li>If the system is already thrashing, instruct the mid-term scheduler to suspend some of the processes</li> </ul>"},{"location":"operating_system/virtual_memory#frame-allocation","title":"Frame Allocation","text":"<ul> <li>Static Allocation: The number of frame allocations to a process is fixed</li> <li>Dynamic Allocation: The number of frame allocations to a process changes</li> </ul>"},{"location":"operating_system/virtual_memory#paging-policies","title":"Paging Policies","text":"<ul> <li>Fetch Policy: Decides when a page should be loaded into the memory</li> <li>Replacement Policy: Decides when a page in memory should be replaced</li> <li>Placement Policy: Decides where in memory should a page be loaded</li> </ul>"},{"location":"operating_system/virtual_memory#memory-interleaving","title":"Memory Interleaving","text":"<ul> <li>Technique that divides memory into a number of modules such that successive words are placed in different modules</li> <li>Most significant bit provides the address of the module</li> <li>Least signiciant bit provides the address of the data in the module</li> <li>Example</li> <li>Consider these addresses with data in parenthesis 0000 (1), 0001 (2), 0010 (3), 0011 (4), ...<ul> <li>Module 00: 00 (1), 01 (2), 10 (3), 11 (4)</li> <li>Module 01: 00 (5), 01 (6), 10 (7), 11 (8)</li> <li>Module 10: 00 (9), 01 (10), 10 (11), 11 (12)</li> <li>Module 11: 00 (13), 01 (14), 10 (15), 11 (16)</li> </ul> </li> <li>To get the data at 0111, it will look in the module 01 with address 11 and fetch 8 as the data</li> <li>Usage</li> <li>Whenever a cache miss occurs, the data is to be fetched from the main memory</li> <li>But the main memory is slower than cache, so memory interleaving increases the access time</li> </ul>"},{"location":"operating_system/virtual_memory#inverted-page-table","title":"Inverted Page Table","text":"<ul> <li>Most OS implement a separate page table for each process</li> <li>A considerable amount of memory is occupied by page tables only</li> <li>Multilevel paging schemes further increase the space required for storing page tables</li> <li>Inverted Page Table is a data structure used to map physical memory pages to virtual memory pages</li> <li>It is stored in secondary memory instead of main memory</li> <li>Unlike Page Table, which is per process, IPT is system wide that contains an entry for each physical memory page</li> </ul>"},{"location":"operating_system/virtual_memory#segmentation","title":"Segmentation","text":"<ul> <li>A process is divided into chunks (not necessarily of the same sizes) called segments</li> <li>Need not be placed in contiguous memory, so no internal fragmentation</li> <li>The size of a segment is decided by its purpose in the program</li> <li>Why required</li> <li>In paging, a process is divided into pages without considering the relative parts of the code</li> <li>This may lead multiple pages to be loaded in memory that might have been included in a single page</li> <li>Segmentation was introduced so that related code can be combined in a single block</li> <li>There is no simple relationship between logical addresses and physical addresses in segmentation</li> <li>Types</li> <li>Virtual Memory Segmentation: Not done all at once, may or may not take place at the run-time</li> <li>Simple Segmentation: Done all together at run-time</li> <li>Segment Table</li> <li>Base Address: Starting physical address for the segments</li> <li>Segment Limit (or Segment Offset): Length of a segment</li> <li>Advantages</li> <li>Takes less space than page table</li> <li>Similar to the user's perception of physical memory</li> <li>Segment size is specified by the user, while in paging the page size in specified by hardware</li> <li>Segmentation operating system</li> <li>Disadvatages</li> <li>Can lead to external fragmentation due to swapping of processes</li> <li>Access time increases due to segment table</li> <li>More complex implementation than paging</li> <li>Managing multiple segments per process can be challenging and might increase segmentation faults</li> </ul>"},{"location":"operating_system/storage_management","title":"Storage Management","text":""},{"location":"operating_system/storage_management#file-system","title":"File System","text":"<ul> <li>Method used by OS to store, organize and manage data on a storage device using files and directories</li> <li>Types</li> <li>FAT (File Allocation Table): Older file system</li> <li>NTFS (New Technology File System): Modern file system that supports permissions, compression, encryption</li> <li>Ext (Extended File System): Commonly used in linux and unix</li> <li>HFS (Hierarchical File System): Used by mac OS</li> <li>APFS (Apple File System): New file system for mac OS</li> <li>File: Collection of related information used to store and manage data in the computer system</li> <li>Directory: Collection of files</li> <li>Contains information about files: attributes, location, ownership</li> <li>Directory is itself a file accessible by file management routines</li> <li>Helps in grouping files and locating files quickly</li> </ul>"},{"location":"operating_system/storage_management#file-allocation-methods","title":"File Allocation Methods","text":"<ul> <li>Continuous Allocation</li> <li>A single continuous set of block is allocated at the time of file creation</li> <li>Pre-allocation strategy using variable size portions</li> <li>File allocation table needs a single entry for each file, with starting block and length</li> <li>Linked or Non-contiguous Allocation</li> <li>Individual blocks contain pointer to the next block, any free block can be added to the chain</li> <li>Although pre-allocation is possible, it is more common to allocate as needed</li> <li>If the pointer of any block is lost, the file will be truncated</li> <li>Supports only sequential access of files</li> <li>File allocation table needs a single entry for each file, with starting block and length</li> <li>Indexed Allocation</li> <li>File allocation table contains a separate one-level index for each file</li> <li>The index has one entry for each block allocated to the file</li> <li>The allocation can be on basis of fixed-size or variable-size blocks</li> <li>Supports both sequential and direct access to the file</li> </ul>"},{"location":"operating_system/storage_management#disk-free-space-management","title":"Disk Free Space Management","text":"<ul> <li>Space not allocated to any file also needs to be managed</li> <li>To know what blocks are available on a disk, a disk allocation table is required</li> <li>Bit Tables</li> <li>A vector containing one bit is used for each block on the disk: 0 for free blocks, 1 for occupied blocks</li> <li>Works well with any file allocation method, and easy to find contiguous free blocks</li> <li>Free Block List</li> <li>Each block is assigned a number sequentially</li> <li>List of the numbers of all free blocks is maintained in a reserved block of the disk</li> </ul>"},{"location":"operating_system/storage_management#unix-file-system","title":"Unix File System","text":"<ul> <li>Files are organized in multi-level hierarchy structure called directory tree</li> <li>At the top of the file system is the root directory (represented by '/')</li> <li>All other files are descendants of root</li> <li>Each file and directory has an owner, a group, and permissions</li> <li>Supports symbolic links: pointers to other files or directories</li> <li>Without the need of physically moving them around</li> </ul>"},{"location":"operating_system/storage_management#structure","title":"Structure","text":"<ul> <li>/: root</li> <li>/bin (binaries): fundamental utilities like ls, cp</li> <li>/boot: files required for successful booting</li> <li>/dev (devices): contains file representations of peripheral &amp; pseudo devices</li> <li>/etc: system wide configuration files &amp; system databases</li> <li>/home: home directories for users</li> <li>/lib: system libraries, critical files like kernel modules or device drivers</li> <li>/media: default mount point for removable devices like USB drives</li> <li>/mnt (mount): file system mount points, used if the system uses multiple hard disks or disk partitions</li> <li>Also used for file remote/network file systems, CD/DVD drives</li> <li>/proc: procfs virtual file system showing info about processes as files</li> <li>/root: home directory for the super user 'root'</li> <li>Not kept in /home in case specific maintenance needs to be performed</li> <li>During which other file systems are not available</li> <li>/tmp: temporary files, many systems clear it upon startup</li> <li>/usr: originally held user home directories which is now done by /home</li> <li>Now holds executables, libraries, shared resources that are not system critical</li> <li>/usr/bin: stores binary programs distributed with OS not residing in /bin &amp; /sbin</li> <li>/usr/include: stores development headers used throughout the system, mostly used by #include in C/C++</li> <li>/usr/lib: required libraries and data files for programs stored in /usr</li> <li>/var (variable): files that may change often especially in size</li> <li>/var/log: system log files</li> <li>/var/mail: stores incoming mails</li> <li>/var/spool: contains print jobs, mail spools and other queued tasks</li> <li>/var/tmp: temporary files which should be preserved between system reboots</li> </ul>"},{"location":"operating_system/storage_management#types-of-unix-files","title":"Types of Unix Files","text":"<ul> <li>Ordinary files: Files containing data, text, program instructions</li> <li>Special files: Represents a physical device used for I/O like printer, tape drive</li> <li>Character special file: Data is transferred one character at a time (raw device access)</li> <li>Block special file: Data is transferred in large fixed-size blocks (block device access)</li> <li>Directories: Store both special &amp; ordinary files</li> <li>Pipes: UNIX allows linking commands using a pipe</li> <li>The pipe acts as a temporary file which holds data from one command until read by another</li> <li>Sockets: Special file that allows for advanced inter-process communication</li> <li>It is a stream of data, similar to network stream &amp; network sockets</li> <li>But all transactions are local to the file system</li> <li>Symbolic link: Used to reference some other file in the file system</li> </ul>"},{"location":"operating_system/storage_management#file-access-methods","title":"File Access Methods","text":"<ul> <li>Sequential Access</li> <li>Information in the file is processed in order, one record after the other</li> <li>Most common and simplest access method</li> <li>Read: It moves the pointer ahead by one</li> <li>Write: It allocates memory and moves the pointer to the end of the file</li> <li>Advantages<ul> <li>Less prone to data corruption as the data is written sequentially and not randomly</li> <li>More efficient method for reading large files, as it only reads the required data</li> <li>Reliable method for backup and restore operations</li> </ul> </li> <li>Disadvantages<ul> <li>Does not allow quick access to a specific record in the file</li> <li>Not suitable for applications that require frequent updates or modifications to the file</li> <li>Space between records cannot be used by other records</li> </ul> </li> <li>Index Sequential Access</li> <li>Constructs an index for the file, which contains the pointers to various blocks</li> <li>Direct Access (or Relative Access)</li> <li>A fixed length logical record that allows to read and write record rapidly in no particular order</li> <li>The file is viewed as a numbered sequence of block or record</li> <li>Relative Record Access</li> <li>Records are accessed relative to the current position of the file pointer</li> <li>Requires fixed length records and may not be flexible enough for some applications</li> <li>Difficult to insert or delete records in the middle of a file<ul> <li>Without disrupting the relative positions of other records</li> </ul> </li> <li>Content Addressable Access</li> <li>Hash function is used to calculate a unique key for each record or block based on its content</li> <li>Any record or block can be accessed by specifying its key</li> <li>Ideal for searching large databases or file systems</li> <li>Allows easy insertion and deletion of records or blocks</li> <li>There is an overhead of calculating hashes and possibility of collision</li> </ul>"},{"location":"operating_system/storage_management#disk-or-io-scheduling","title":"Disk or I/O Scheduling","text":"<ul> <li>Only one I/O request can be served at a time by the disk controller</li> <li>Two or more requests may be far from each other which can result in greater disk arm movement</li> <li>Hard drives are one of the slowest parts of the system and needs to be accessed in an efficient manner</li> <li>Key Terms</li> <li>Seek time: Time take to locate the disk arm to a specified track where the data is to be read or written</li> <li>Rotational Latency: Time taken by the desired sector to rotate into a position<ul> <li>So that read/write heads can be accessed</li> </ul> </li> <li>Transfer time: Time taken to transfer data, depends on rotating speed and size of data</li> <li>Disk access time = Seek time + Rotational latency + Transfer time</li> <li>Disk Response time: Average time spent by a request to wait for I/O</li> </ul>"},{"location":"operating_system/storage_management#spooling","title":"Spooling","text":"<ul> <li>SPOOL: Simultaneous Peripheral Operations On-Line</li> <li>Similar to a buffering mechanism in which data is temporarily held</li> <li>To be used and executed by a device, program or system</li> <li>Data is sent to and stored in memory or other volatile storage until the program requests for execution</li> <li>Devices like printers, keyboard, mouse are slow relative to the rest of the system creating a bottleneck</li> <li>Spooling resolves this by accumulating data, instructions &amp; processes from multiple sources in a request queue</li> <li>Which is then processed in a FIFO manner</li> <li>Batch processing systems also use spooling to maintain a queue of ready-to-run jobs</li> <li>Which can be started as soon as the system has resources</li> <li>Allows multiple processes to write documents to a print queue without waiting and resume their work</li> </ul>"},{"location":"operating_system/storage_management#difference-from-buffering","title":"Difference from Buffering","text":"<ul> <li>Main memory has an area called buffer to store or hold data temporarily</li> <li>That is being transmitted between two devices or between a device &amp; an application</li> <li>Helps in matching the speed of data stream between the sender and the receiver</li> </ul>"},{"location":"operating_system/storage_management#raid","title":"RAID:","text":"<ul> <li>0</li> <li>1 \u2013 Clone</li> <li>2 \u2013 Error correcting code and bits</li> <li>3 \u2013 Byte level stripking with parity disk</li> <li>4 \u2013 Block level striping with parity disk</li> <li>5 \u2013 Block level striping with distributed parity</li> <li>6 \u2013 extends 5 with one more parity block</li> <li>10 \u2013 combine raids 1 and 0</li> </ul>"}]}